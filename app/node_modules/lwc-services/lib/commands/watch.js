"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const cli_ux_1 = require("cli-ux");
const fs = require("fs");
const path = require("path");
const webpack = require("webpack");
const webpackMerge = require("webpack-merge");
const lwcConfig_1 = require("../config/lwcConfig");
const webpack_config_1 = require("../config/webpack.config");
const watch_1 = require("../messages/watch");
const logger_1 = require("../utils/logger");
const spawn = require('child_process').spawn;
const rollupConfig = path.resolve(__dirname, '../config/rollup.config.js');
class Watch extends command_1.Command {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    async run() {
        const { flags } = this.parse(Watch);
        // eslint-disable-next-line no-console
        console.clear();
        logger_1.welcome();
        if (flags.bundler === 'webpack') {
            // Check if custom webpack config is passed, and if it really exists.
            if (flags.webpack) {
                if (!fs.existsSync(flags.webpack)) {
                    logger_1.log(watch_1.messages.errors.no_webpack);
                    return;
                }
            }
            let webpackConfig = webpack_config_1.generateWebpackConfig(flags.mode);
            lwcConfig_1.lwcConfig.devServer.contentBase = lwcConfig_1.lwcConfig.sourceDir;
            webpackConfig.devServer = lwcConfig_1.lwcConfig.devServer;
            // Merging custom webpack config file
            if (flags.webpack) {
                logger_1.log(watch_1.messages.logs.custom_configuration);
                const webpackConfigCustom = require(path.resolve(process.cwd(), flags.webpack));
                webpackConfig = webpackMerge.smart(webpackConfig, webpackConfigCustom);
            }
            if (flags.host && flags.host !== lwcConfig_1.lwcConfig.devServer.host) {
                webpackConfig.devServer.host = flags.host;
            }
            if (flags.port && flags.port !== lwcConfig_1.lwcConfig.devServer.port) {
                webpackConfig.devServer.port = flags.port;
            }
            logger_1.log(watch_1.messages.logs.build_start);
            // Lazy loading
            const WebpackDevServer = require('webpack-dev-server');
            const compiler = webpack(webpackConfig);
            const app = new WebpackDevServer(compiler, webpackConfig.devServer);
            app.listen(webpackConfig.devServer.port, webpackConfig.devServer.host, () => {
                const protocol = 'http';
                const url = `${protocol}://${webpackConfig.devServer.host}:${webpackConfig.devServer.port}`;
                logger_1.log(watch_1.messages.logs.local_server_listening, url);
                if (flags.open) {
                    cli_ux_1.default.open(url);
                }
            });
        }
        else {
            const HOST = flags.host && flags.host !== lwcConfig_1.lwcConfig.devServer.host
                ? flags.host
                : lwcConfig_1.lwcConfig.devServer.host;
            const PORT = flags.port && flags.port !== lwcConfig_1.lwcConfig.devServer.port
                ? flags.port
                : lwcConfig_1.lwcConfig.devServer.port;
            const MODE = flags.mode || 'development';
            const OPEN = flags.open;
            const ENV_PARAMS = [
                `DEV_HOST_OPEN:${OPEN}`,
                `DEV_HOST:${HOST}`,
                `DEV_PORT:${PORT}`,
                `NODE_ENV:${MODE}`
            ].join(',');
            // This looks super wonky... and it may be super wonky. ;-)
            const args = [
                './node_modules/rollup/dist/bin/rollup',
                '-c',
                rollupConfig,
                '--environment',
                ENV_PARAMS,
                '--watch'
            ];
            const rollupSpawn = spawn('node', args);
            rollupSpawn.on('error', (err) => {
                logger_1.log({ message: `${err}`, emoji: 'sos' });
            });
            // It's super weird that the debug message is passed via stderr. But it is what it is.
            rollupSpawn.stderr.on('data', (data) => {
                logger_1.log({ message: `${data}`, emoji: 'rainbow' });
            });
            const protocol = 'http';
            const url = `${protocol}://${HOST}:${PORT}`;
            logger_1.log(watch_1.messages.logs.local_server_listening, url);
        }
    }
}
exports.default = Watch;
Watch.description = watch_1.messages.description;
Watch.examples = watch_1.messages.help.examples;
Watch.flags = {
    help: command_1.flags.help({ char: 'h' }),
    mode: command_1.flags.string({
        char: 'm',
        description: watch_1.messages.flags.mode,
        default: lwcConfig_1.lwcConfig.mode
    }),
    host: command_1.flags.string({
        char: 'i',
        description: watch_1.messages.flags.host,
        default: lwcConfig_1.lwcConfig.devServer.host
    }),
    open: command_1.flags.boolean({
        char: 'o',
        description: watch_1.messages.flags.open,
        default: lwcConfig_1.lwcConfig.devServer.open
    }),
    port: command_1.flags.integer({
        char: 'p',
        description: watch_1.messages.flags.port,
        default: lwcConfig_1.lwcConfig.devServer.port
    }),
    webpack: command_1.flags.string({
        char: 'w',
        description: watch_1.messages.flags.webpack
    }),
    bundler: command_1.flags.string({
        char: 'b',
        description: watch_1.messages.flags.bundler,
        default: lwcConfig_1.lwcConfig.bundler
    })
};
