"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var t = __importStar(require("@babel/types"));
var normalize_property_name_1 = __importDefault(require("./normalize-property-name"));
var TokenType;
(function (TokenType) {
    TokenType[TokenType["Identifier"] = 0] = "Identifier";
    TokenType[TokenType["ObjectLiteral"] = 1] = "ObjectLiteral";
    TokenType[TokenType["ArrayLiteral"] = 2] = "ArrayLiteral";
})(TokenType || (TokenType = {}));
function isTokenMatchingNode(token, node) {
    return ((token.type === TokenType.Identifier && t.isIdentifier(node, { name: token.name })) ||
        (token.type === TokenType.ArrayLiteral && t.isArrayExpression(node)) ||
        (token.type === TokenType.ObjectLiteral && t.isObjectExpression(node)));
}
function isMemberExpressionMatchingTokens(memberExpression, tokens) {
    var propertyChain = [];
    // Populate the list of properties accessed in the member expression
    var currentNode = memberExpression;
    while (currentNode) {
        var property = normalize_property_name_1.default(currentNode.property, currentNode.computed);
        propertyChain.unshift(property);
        if (t.isMemberExpression(currentNode.object)) {
            currentNode = currentNode.object;
        }
        else {
            // If the object is not MemberExpression exit the loop
            propertyChain.unshift(currentNode.object);
            currentNode = undefined;
        }
    }
    // console.log(propertyChain)
    if (tokens.length !== propertyChain.length) {
        return false;
    }
    return tokens.every(function (token, index) {
        return isTokenMatchingNode(token, propertyChain[index]);
    });
}
function parsePattern(pattern) {
    var tokens = pattern.split('.');
    return tokens.map(function (part) {
        var token;
        switch (part) {
            case '[]':
                token = { type: TokenType.ArrayLiteral };
                break;
            case '{}':
                token = { type: TokenType.ObjectLiteral };
                break;
            default:
                token = {
                    type: TokenType.Identifier,
                    name: part,
                };
        }
        return token;
    });
}
/**
 * Returns a new MemberExpression matcher, to match a member expression against a pattern.
 *
 * @param pattern the pattern string expressed as a chained expression lookup.
 *
 * @example
 * const matchObjectAssign = memberExpressionMatcher('Object.assign');
 * const match = matchObjectAssign(node);
 */
function default_1(pattern) {
    var tokens = parsePattern(pattern);
    return function (node) {
        return isMemberExpressionMatchingTokens(node, tokens);
    };
}
exports.default = default_1;
//# sourceMappingURL=module.js.map