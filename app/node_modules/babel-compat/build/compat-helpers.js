/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const getHelper = require('@babel/helpers').get;
const t = require('@babel/types');
const generate = require('@babel/generator').default;

/**
 * List of all the supported babel helpers.
 */
const HELPERS_WHITELIST = [
    'AsyncGenerator',
    'AwaitValue',
    'applyDecoratedDescriptor',
    'arrayWithHoles',
    'arrayWithoutHoles',
    'assertThisInitialized',
    'asyncGeneratorDelegate',
    'asyncIterator',
    'asyncToGenerator',
    'awaitAsyncGenerator',
    'classCallCheck',
    'classNameTDZError',
    'classStaticPrivateFieldSpecGet',
    'classStaticPrivateFieldSpecSet',
    'createClass',
    'decorate',
    'defaults',
    'defineEnumerableProperties',
    'defineProperty',
    'extends',
    'get',
    'inherits',

    'construct',
    'getPrototypeOf',
    'setPrototypeOf',
    'superPropBase',

    'inheritsLoose',
    'initializerDefineProperty',
    'initializerWarningHelper',
    'instanceof',
    'isNativeFunction',
    'iterableToArray',
    'iterableToArrayLimit',
    'iterableToArrayLimitLoose',
    'jsx',

    'newArrowCheck',
    'nonIterableRest',
    'nonIterableSpread',
    'objectDestructuringEmpty',
    'objectSpread',
    'objectWithoutProperties',
    'objectWithoutPropertiesLoose',
    'possibleConstructorReturn',
    'readOnlyError',
    'set',
    'skipFirstGeneratorNext',
    'slicedToArray',
    'slicedToArrayLoose',
    'taggedTemplateLiteral',
    'taggedTemplateLiteralLoose',
    'temporalRef',
    'temporalUndefined',
    'toArray',
    'toConsumableArray',
    'toPropertyKey',
    'typeof',
    'wrapAsyncGenerator',
    'wrapNativeSuper',
];

// Helpers that do not need any COMPAT transform
const PURE_HELPERS = ['classCallCheck'];

const helpers = HELPERS_WHITELIST;
const pureHelpers = PURE_HELPERS;

// Transform the nested helpers to be relative so we dont need intrinsic dependencies
function tranformRelativeImports(helperRoot) {
    helperRoot.nodes.forEach((node) => {
        if (t.isImportDeclaration(node)) {
            node.source.value = `./${node.source.value}`;
        }
    });
    return helperRoot;
}

function generateHelperAST(helperName) {
    if (HELPERS_WHITELIST.includes(helperName)) {
        const helperNodes = getHelper(helperName);
        return tranformRelativeImports(helperNodes);
    }
}

function generateHelperSource(helperName) {
    const helperAstNode = generateHelperAST(helperName);
    const helperAstRoot = helperAstNode.nodes;
    const program = t.program(helperAstRoot, undefined, 'module');
    return generate(program).code;
}

function isPureHelper(helperName) {
    return PURE_HELPERS.includes(helperName);
}

module.exports = {
    helpers: helpers,
    pureHelpers,
    generateHelperAST,
    isPureHelper,
    generateHelperSource,
};
