"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateTransformOptions = exports.validateCompileOptions = exports.validateOptions = exports.validateNormalizedCompileOptions = void 0;
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const utils_1 = require("./utils");
const errors_1 = require("@lwc/errors");
const DEFAULT_OPTIONS = {
    baseDir: '',
    isExplicitImport: false,
};
const DEFAULT_DYNAMIC_CMP_CONFIG = {
    loader: '',
    strictSpecifier: true,
};
const DEFAULT_STYLESHEET_CONFIG = {
    customProperties: {
        allowDefinition: false,
        resolution: { type: 'native' },
    },
};
const DEFAULT_OUTPUT_CONFIG = {
    env: {},
    minify: false,
    compat: false,
    sourcemap: false,
};
const KNOWN_ENV = new Set(['NODE_ENV']);
function validateNormalizedCompileOptions(options) {
    validateOptions(options);
    validateOutputConfig(options.outputConfig);
    validateStylesheetConfig(options.stylesheetConfig);
}
exports.validateNormalizedCompileOptions = validateNormalizedCompileOptions;
function validateOptions(options) {
    errors_1.invariant(!utils_1.isUndefined(options), errors_1.CompilerValidationErrors.MISSING_OPTIONS_OBJECT, [options]);
    if (!utils_1.isUndefined(options.stylesheetConfig)) {
        validateStylesheetConfig(options.stylesheetConfig);
    }
    if (!utils_1.isUndefined(options.outputConfig)) {
        validateOutputConfig(options.outputConfig);
    }
}
exports.validateOptions = validateOptions;
function validateCompileOptions(options) {
    validateOptions(options);
    errors_1.invariant(utils_1.isString(options.name), errors_1.CompilerValidationErrors.INVALID_NAME_PROPERTY, [
        options.name,
    ]);
    errors_1.invariant(utils_1.isString(options.namespace), errors_1.CompilerValidationErrors.INVALID_NAMESPACE_PROPERTY, [
        options.namespace,
    ]);
    errors_1.invariant(!utils_1.isUndefined(options.files) && !!Object.keys(options.files).length, errors_1.CompilerValidationErrors.INVALID_FILES_PROPERTY);
    for (const key of Object.keys(options.files)) {
        const value = options.files[key];
        errors_1.invariant(!utils_1.isUndefined(value) && utils_1.isString(value), errors_1.CompilerValidationErrors.UNEXPECTED_FILE_CONTENT, [key, value]);
    }
    return normalizeOptions(options);
}
exports.validateCompileOptions = validateCompileOptions;
function validateTransformOptions(options) {
    validateOptions(options);
    return normalizeOptions(options);
}
exports.validateTransformOptions = validateTransformOptions;
function validateStylesheetConfig(config) {
    const { customProperties } = config;
    if (!utils_1.isUndefined(customProperties)) {
        const { allowDefinition, resolution } = customProperties;
        errors_1.invariant(utils_1.isUndefined(allowDefinition) || utils_1.isBoolean(allowDefinition), errors_1.CompilerValidationErrors.INVALID_ALLOWDEFINITION_PROPERTY, [allowDefinition]);
        if (!utils_1.isUndefined(resolution)) {
            errors_1.invariant(utils_1.isObject(resolution), errors_1.CompilerValidationErrors.INVALID_RESOLUTION_PROPERTY, [
                resolution,
            ]);
            const { type } = resolution;
            errors_1.invariant(type === 'native' || type === 'module', errors_1.CompilerValidationErrors.INVALID_TYPE_PROPERTY, [type]);
        }
    }
}
function isUndefinedOrBoolean(property) {
    return utils_1.isUndefined(property) || utils_1.isBoolean(property);
}
function validateOutputConfig(config) {
    errors_1.invariant(isUndefinedOrBoolean(config.minify), errors_1.CompilerValidationErrors.INVALID_MINIFY_PROPERTY, [config.minify]);
    errors_1.invariant(isUndefinedOrBoolean(config.compat), errors_1.CompilerValidationErrors.INVALID_COMPAT_PROPERTY, [config.compat]);
    errors_1.invariant(isUndefinedOrBoolean(config.sourcemap), errors_1.CompilerValidationErrors.INVALID_SOURCEMAP_PROPERTY, [config.sourcemap]);
    if (!utils_1.isUndefined(config.env)) {
        errors_1.invariant(utils_1.isObject(config.env), errors_1.CompilerValidationErrors.INVALID_ENV_PROPERTY, [
            config.env,
        ]);
        for (const [key, value] of Object.entries(config.env)) {
            errors_1.invariant(KNOWN_ENV.has(key), errors_1.CompilerValidationErrors.UNKNOWN_ENV_ENTRY_KEY, [key]);
            errors_1.invariant(utils_1.isString(value), errors_1.CompilerValidationErrors.INVALID_ENV_ENTRY_VALUE, [
                key,
                value,
            ]);
        }
    }
}
function normalizeOptions(options) {
    const outputConfig = {
        ...DEFAULT_OUTPUT_CONFIG,
        ...options.outputConfig,
    };
    const stylesheetConfig = {
        customProperties: {
            ...DEFAULT_STYLESHEET_CONFIG.customProperties,
            ...(options.stylesheetConfig && options.stylesheetConfig.customProperties),
        },
    };
    const experimentalDynamicComponent = {
        ...DEFAULT_DYNAMIC_CMP_CONFIG,
        ...options.experimentalDynamicComponent,
    };
    return {
        ...DEFAULT_OPTIONS,
        ...options,
        stylesheetConfig,
        outputConfig,
        experimentalDynamicComponent,
    };
}
//# sourceMappingURL=options.js.map