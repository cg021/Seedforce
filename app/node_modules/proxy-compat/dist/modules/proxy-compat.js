/* proxy-compat-disable */
function __extends(d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var _a = Object, getOwnPropertyNames = _a.getOwnPropertyNames, create = _a.create, keys = _a.keys, getOwnPropertyDescriptor = _a.getOwnPropertyDescriptor, preventExtensions = _a.preventExtensions, defineProperty = _a.defineProperty, hasOwnProperty = _a.hasOwnProperty, isExtensible = _a.isExtensible, getPrototypeOf = _a.getPrototypeOf, setPrototypeOf = _a.setPrototypeOf;
var _b = Array.prototype, ArraySlice = _b.slice, ArrayShift = _b.shift, ArrayUnshift = _b.unshift, ArrayConcat = _b.concat;
var isArray = Array.isArray;

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function isUndefined(value) {
    return value === undefined;
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function getOwnPropertyDescriptor$1(replicaOrAny, key) {
    if (isCompatProxy(replicaOrAny)) {
        return replicaOrAny.getOwnPropertyDescriptor(key);
    }
    return getOwnPropertyDescriptor(replicaOrAny, key);
}
function getOwnPropertyNames$1(replicaOrAny) {
    if (isCompatProxy(replicaOrAny)) {
        return replicaOrAny.ownKeys().filter(function (key) { return key.constructor !== Symbol; }); // TODO: only strings
    }
    return getOwnPropertyNames(replicaOrAny);
}
// https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys
// https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys
function OwnPropertyKeys(O) {
    return ArrayConcat.call(Object.getOwnPropertyNames(O), Object.getOwnPropertySymbols(O));
}
function assign(replicaOrAny) {
    if (replicaOrAny == null) { // TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
    }
    var to = Object(replicaOrAny);
    for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];
        if (nextSource != null) { // Skip over if undefined or null
            var objectKeys = OwnPropertyKeys(nextSource);
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < objectKeys.length; i += 1) {
                var nextKey = objectKeys[i];
                var descriptor = getOwnPropertyDescriptor$1(nextSource, nextKey);
                if (descriptor !== undefined && descriptor.enumerable === true) {
                    setKey(to, nextKey, getKey(nextSource, nextKey));
                }
            }
        }
    }
    return to;
}
function hasOwnProperty$1(key) {
    if (isCompatProxy(this)) {
        var descriptor = this.getOwnPropertyDescriptor(key);
        return !isUndefined(descriptor);
    }
    else {
        return hasOwnProperty.call(this, key);
    }
}
function keys$1(replicaOrAny) {
    if (isCompatProxy(replicaOrAny)) {
        var all = replicaOrAny.forIn();
        var result = [];
        // tslint:disable-next-line:forin
        for (var prop in all) {
            var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
            if (desc && desc.enumerable === true) {
                result.push(prop);
            }
        }
        return result;
    }
    else {
        return keys(replicaOrAny);
    }
}
function values(replicaOrAny) {
    if (isCompatProxy(replicaOrAny)) {
        var all = replicaOrAny.forIn();
        var result = [];
        // tslint:disable-next-line:forin
        for (var prop in all) {
            var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
            if (desc && desc.enumerable === true) {
                result.push(getKey(replicaOrAny, prop));
            }
        }
        return result;
    }
    else {
        // Calling `Object.values` instead of dereferencing the method during the module evaluation
        // since `Object.values` gets polyfilled at the module evaluation.
        return Object.values(replicaOrAny);
    }
}
function entries(replicaOrAny) {
    if (isCompatProxy(replicaOrAny)) {
        var all = replicaOrAny.forIn();
        var result = [];
        // tslint:disable-next-line:forin
        for (var prop in all) {
            var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
            if (desc && desc.enumerable === true) {
                result.push([
                    prop,
                    getKey(replicaOrAny, prop)
                ]);
            }
        }
        return result;
    }
    else {
        // Calling `Object.entries` instead of dereferencing the method during the module evaluation
        // since `Object.entries` gets polyfilled at the module evaluation.
        return Object.entries(replicaOrAny);
    }
}
function defineProperty$1(replicaOrAny, prop, descriptor) {
    if (isCompatProxy(replicaOrAny)) {
        replicaOrAny.defineProperty(prop, descriptor);
        return replicaOrAny;
    }
    else {
        return defineProperty(replicaOrAny, prop, descriptor);
    }
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var ProxyTypeObject = 1;
var ProxyTypeArray = 2;
// Proto chain check might be needed because of usage of a limited polyfill
// https://github.com/es-shims/get-own-property-symbols
// In this case, because this polyfill is assing all the stuff to Object.prototype to keep
// all the other invariants of Symbols, we need to do some manual checks here for the slow patch.
var isNotNativeSymbol;
var inOperator = function inOperatorCompat(obj, key) {
    if (isNotNativeSymbol === undefined) {
        if (typeof Symbol === 'undefined') {
            throw new Error('Symbol is not available. Make sure to apply symbol polyfill before calling inOperator');
        }
        isNotNativeSymbol = typeof Symbol() === 'object';
    }
    if (isNotNativeSymbol) {
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        if (key && key.constructor === Symbol) {
            while (obj) {
                if (getOwnPropertySymbols(obj).indexOf(key) !== -1) {
                    return true;
                }
                obj = getPrototypeOf(obj);
            }
            return false;
        }
        return key in obj;
    }
    return key in obj;
};
var defaultHandlerTraps = {
    get: function (target, key) {
        return target[key];
    },
    set: function (target, key, newValue) {
        target[key] = newValue;
        return true;
    },
    apply: function (targetFn, thisArg, argumentsList) {
        return targetFn.apply(thisArg, argumentsList);
    },
    construct: function (targetFn, argumentsList, newTarget) {
        return new (targetFn.bind.apply(targetFn, [void 0].concat(argumentsList)))();
    },
    defineProperty: function (target, property, descriptor) {
        defineProperty(target, property, descriptor);
        return true;
    },
    deleteProperty: function (target, property) {
        return delete target[property];
    },
    ownKeys: function (target) {
        return OwnPropertyKeys(target);
    },
    has: function (target, propertyKey) {
        return inOperator(target, propertyKey);
    },
    preventExtensions: function (target) {
        preventExtensions(target);
        return true;
    },
    getOwnPropertyDescriptor: getOwnPropertyDescriptor,
    getPrototypeOf: getPrototypeOf,
    isExtensible: isExtensible,
    setPrototypeOf: setPrototypeOf,
};
var lastRevokeFn;
var proxyTrapFalsyErrors = {
    set: function (target, key) {
        throw new TypeError("'set' on proxy: trap returned falsish for property '" + key + "'");
    },
    deleteProperty: function (target, key) {
        throw new TypeError("'deleteProperty' on proxy: trap returned falsish for property '" + key + "'");
    },
    setPrototypeOf: function (target, proto) {
        throw new TypeError("'setPrototypeOf' on proxy: trap returned falsish");
    },
    preventExtensions: function (target, proto) {
        throw new TypeError("'preventExtensions' on proxy: trap returned falsish");
    },
    defineProperty: function (target, key, descriptor) {
        throw new TypeError("'defineProperty' on proxy: trap returned falsish for property '" + key + "'");
    }
};
function proxifyProperty(proxy, key, descriptor) {
    var enumerable = descriptor.enumerable, configurable = descriptor.configurable;
    defineProperty(proxy, key, {
        enumerable: enumerable,
        configurable: configurable,
        get: function () {
            return proxy.get(key);
        },
        set: function (value) {
            proxy.set(key, value);
        },
    });
}
var XProxy = /** @class */ (function () {
    function XProxy(target, handler) {
        var targetIsFunction = typeof target === 'function';
        var targetIsArray = isArray(target);
        if ((typeof target !== 'object' || target === null) && !targetIsFunction) {
            throw new Error("Cannot create proxy with a non-object as target");
        }
        if (typeof handler !== 'object' || handler === null) {
            throw new Error("new XProxy() expects the second argument to an object");
        }
        // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.
        // The caller might get the wrong revoke function if a user replaces or wraps XProxy
        // to call itself, but that seems unlikely especially when using the polyfill.
        var throwRevoked = false;
        lastRevokeFn = function () {
            throwRevoked = true;
        };
        // Define proxy as Object, or Function (if either it's callable, or apply is set).
        // tslint:disable-next-line:no-this-assignment
        var proxy = this; // reusing the already created object, eventually the prototype will be resetted
        if (targetIsFunction) {
            proxy = function Proxy() {
                var usingNew = (this && this.constructor === proxy);
                var args = ArraySlice.call(arguments);
                if (usingNew) {
                    return proxy.construct(args, this);
                }
                else {
                    return proxy.apply(this, args);
                }
            };
        }
        var _loop_1 = function (trapName) {
            defineProperty(proxy, trapName, {
                value: function () {
                    if (throwRevoked) {
                        throw new TypeError("Cannot perform '" + trapName + "' on a proxy that has been revoked");
                    }
                    var args = ArraySlice.call(arguments);
                    ArrayUnshift.call(args, target);
                    var h = handler[trapName] ? handler : defaultHandlerTraps;
                    var value = h[trapName].apply(h, args);
                    if (proxyTrapFalsyErrors[trapName] && value === false) {
                        proxyTrapFalsyErrors[trapName].apply(proxyTrapFalsyErrors, args);
                    }
                    return value;
                },
                writable: false,
                enumerable: false,
                configurable: false,
            });
        };
        // tslint:disable-next-line:forin
        for (var trapName in defaultHandlerTraps) {
            _loop_1(trapName);
        }
        var proxyDefaultHasInstance;
        var SymbolHasInstance = Symbol.hasInstance;
        var FunctionPrototypeSymbolHasInstance = Function.prototype[SymbolHasInstance];
        defineProperty(proxy, SymbolHasInstance, {
            get: function () {
                var hasInstance = proxy.get(SymbolHasInstance);
                // We do not want to deal with any Symbol.hasInstance here
                // because we need to do special things to check prototypes.
                // Symbol polyfill adds Symbol.hasInstance to the function prototype
                // so if we have that here, we need to return our own.
                // If the value we get from this function is different, that means
                // user has supplied custom function so we need to respect that.
                if (hasInstance === FunctionPrototypeSymbolHasInstance) {
                    return proxyDefaultHasInstance || (proxyDefaultHasInstance = function (inst) {
                        return defaultHasInstance(inst, proxy);
                    });
                }
                return hasInstance;
            },
            configurable: false,
            enumerable: false
        });
        defineProperty(proxy, '_ES5ProxyType', {
            value: targetIsArray ? ProxyTypeArray : ProxyTypeObject,
            configurable: false,
            enumerable: false,
            writable: true,
        });
        defineProperty(proxy, 'forIn', {
            value: function () {
                return proxy.ownKeys().reduce(function (o, key) {
                    o[key] = void 0;
                    return o;
                }, create(null));
            },
            configurable: false,
            enumerable: false,
            writable: false,
        });
        var SymbolIterator = Symbol.iterator;
        defineProperty(proxy, SymbolIterator, {
            enumerable: false,
            configurable: true,
            get: function () {
                return this.get(SymbolIterator);
            },
            set: function (value) {
                this.set(SymbolIterator, value);
            },
        });
        if (targetIsArray) {
            var trackedLength_1 = 0;
            var adjustArrayIndex_1 = function (newLength) {
                // removing old indexes from proxy when needed
                while (trackedLength_1 > newLength) {
                    delete proxy[--trackedLength_1];
                }
                // add new indexes to proxy when needed
                for (var i = trackedLength_1; i < newLength; i += 1) {
                    proxifyProperty(proxy, i, {
                        enumerable: true,
                        configurable: true,
                    });
                }
                trackedLength_1 = newLength;
            };
            defineProperty(proxy, 'length', {
                enumerable: false,
                configurable: true,
                get: function () {
                    var proxyLength = proxy.get('length');
                    // check if the trackedLength matches the length of the proxy
                    if (proxyLength !== trackedLength_1) {
                        adjustArrayIndex_1(proxyLength);
                    }
                    return proxyLength;
                },
                set: function (value) {
                    proxy.set('length', value);
                },
            });
            // building the initial index. this is observable by the proxy
            // because we access the length property during the construction
            // of the proxy, but it should be fine...
            adjustArrayIndex_1(proxy.get('length'));
        }
        return proxy;
    }
    // tslint:disable-next-line:member-ordering
    XProxy.revocable = function (target, handler) {
        var p = new XProxy(target, handler);
        return {
            proxy: p,
            revoke: lastRevokeFn,
        };
    };
    XProxy.prototype.push = function () {
        var push$1 = this.get('push');
        if (push$1 === Array.prototype.push) {
            push$1 = push;
        }
        return push$1.apply(this, arguments);
    };
    XProxy.prototype.pop = function () {
        var pop$1 = this.get('pop');
        if (pop$1 === Array.prototype.pop) {
            pop$1 = pop;
        }
        return pop$1.apply(this, arguments);
    };
    XProxy.prototype.concat = function () {
        var concat = this.get('concat');
        if (concat === Array.prototype.concat) {
            concat = concat$1;
        }
        return concat.apply(this, arguments);
    };
    XProxy.prototype.splice = function () {
        var splice$1 = this.get('splice');
        if (splice$1 === Array.prototype.splice) {
            splice$1 = splice;
        }
        return splice$1.apply(this, arguments);
    };
    XProxy.prototype.shift = function () {
        var shift$1 = this.get('shift');
        if (shift$1 === Array.prototype.shift) {
            shift$1 = shift;
        }
        return shift$1.apply(this, arguments);
    };
    XProxy.prototype.unshift = function () {
        var unshift$1 = this.get('unshift');
        if (unshift$1 === Array.prototype.unshift) {
            unshift$1 = unshift;
        }
        return unshift$1.apply(this, arguments);
    };
    XProxy.prototype.toJSON = function () {
        if (this._ES5ProxyType === ProxyTypeArray) {
            var unwrappedArray = [];
            var length = this.get('length');
            for (var i = 0; i < length; i++) {
                unwrappedArray[i] = this.get(i);
            }
            return unwrappedArray;
        }
        else {
            var toJSON = this.get('toJSON');
            if (toJSON !== undefined && typeof toJSON === 'function') {
                return toJSON.apply(this, arguments);
            }
            var keys = this.ownKeys();
            var unwrappedObject = {};
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var enumerable = this.getOwnPropertyDescriptor(key).enumerable;
                if (enumerable) {
                    unwrappedObject[key] = this.get(key);
                }
            }
            return unwrappedObject;
        }
    };
    return XProxy;
}());

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function defaultHasInstance(instance, Type) {
    // We have to grab getPrototypeOf here
    // because caching it at the module level is too early.
    // We need our shimmed version.
    var getPrototypeOf = Object.getPrototypeOf;
    var instanceProto = getPrototypeOf(instance);
    var TypeProto = getKey(Type, 'prototype');
    while (instanceProto !== null) {
        if (instanceProto === TypeProto) {
            return true;
        }
        instanceProto = getPrototypeOf(instanceProto);
    }
    return false;
}
// NOTE: For performance reasons, the "_ES5ProxyType" key should be checked without
// using this function, unless `replicaOrAny._ES5ProxyType` might throw unexpectedly.
function isCompatProxy(replicaOrAny) {
    return replicaOrAny && replicaOrAny._ES5ProxyType;
}
var getKey = function (replicaOrAny, k1) {
    return replicaOrAny._ES5ProxyType ?
        replicaOrAny.get(k1) :
        replicaOrAny[k1];
};
var getKeys2 = function (replicaOrAny, k1, k2) {
    var replicaOrAny1 = replicaOrAny._ES5ProxyType ? replicaOrAny.get(k1) : replicaOrAny[k1];
    return replicaOrAny1._ES5ProxyType ? replicaOrAny1.get(k2) : replicaOrAny1[k2];
};
var getKeys3 = function (replicaOrAny, k1, k2, k3) {
    var replicaOrAny1 = replicaOrAny._ES5ProxyType ? replicaOrAny.get(k1) : replicaOrAny[k1];
    var replicaOrAny2 = replicaOrAny1._ES5ProxyType ? replicaOrAny1.get(k2) : replicaOrAny1[k2];
    return replicaOrAny2._ES5ProxyType ? replicaOrAny2.get(k3) : replicaOrAny2[k3];
};
var getKeys4 = function (replicaOrAny, k1, k2, k3, k4) {
    var replicaOrAny1 = replicaOrAny._ES5ProxyType ? replicaOrAny.get(k1) : replicaOrAny[k1];
    var replicaOrAny2 = replicaOrAny1._ES5ProxyType ? replicaOrAny1.get(k2) : replicaOrAny1[k2];
    var replicaOrAny3 = replicaOrAny2._ES5ProxyType ? replicaOrAny2.get(k3) : replicaOrAny2[k3];
    return replicaOrAny3._ES5ProxyType ? replicaOrAny3.get(k4) : replicaOrAny3[k4];
};
var getKeys = function (replicaOrAny) {
    var l = arguments.length;
    for (var i = 1; i < l; i++) {
        var key = arguments[i];
        replicaOrAny = replicaOrAny._ES5ProxyType ? replicaOrAny.get(key) : replicaOrAny[key];
    }
    return replicaOrAny;
};
var callKey0 = function (replicaOrAny, key) {
    return getKey(replicaOrAny, key).call(replicaOrAny);
};
var callKey1 = function (replicaOrAny, key, a1) {
    return getKey(replicaOrAny, key).call(replicaOrAny, a1);
};
var callKey2 = function (replicaOrAny, key, a1, a2) {
    return getKey(replicaOrAny, key).call(replicaOrAny, a1, a2);
};
var callKey3 = function (replicaOrAny, key, a1, a2, a3) {
    return getKey(replicaOrAny, key).call(replicaOrAny, a1, a2, a3);
};
var callKey4 = function (replicaOrAny, key, a1, a2, a3, a4) {
    return getKey(replicaOrAny, key).call(replicaOrAny, a1, a2, a3, a4);
};
var callKey = function (replicaOrAny, key) {
    var fn = getKey(replicaOrAny, key);
    var l = arguments.length;
    var args = [];
    for (var i = 2; i < l; i++) {
        args[i - 2] = arguments[i];
    }
    return fn.apply(replicaOrAny, args);
};
var setKey = function (replicaOrAny, key, newValue) {
    return replicaOrAny._ES5ProxyType ?
        replicaOrAny.set(key, newValue) :
        replicaOrAny[key] = newValue;
};
var setKeyPostfixIncrement = function (replicaOrAny, key) {
    var originalValue = getKey(replicaOrAny, key);
    setKey(replicaOrAny, key, originalValue + 1);
    return originalValue;
};
var setKeyPostfixDecrement = function (replicaOrAny, key) {
    var originalValue = getKey(replicaOrAny, key);
    setKey(replicaOrAny, key, originalValue - 1);
    return originalValue;
};
var deleteKey = function (replicaOrAny, key) {
    if (replicaOrAny._ES5ProxyType) {
        return replicaOrAny.deleteProperty(key);
    }
    delete replicaOrAny[key];
};
var inKey = function (replicaOrAny, key) {
    if (isCompatProxy(replicaOrAny)) {
        return replicaOrAny.has(key);
    }
    return inOperator(replicaOrAny, key);
};
var iterableKey = function (replicaOrAny) {
    if (isCompatProxy(replicaOrAny)) {
        return replicaOrAny.forIn();
    }
    return replicaOrAny;
};
function instanceOfKey(instance, Type) {
    var instanceIsCompatProxy = isCompatProxy(instance);
    if (!isCompatProxy(Type) && !instanceIsCompatProxy) {
        return instance instanceof Type;
    }
    // TODO: Once polyfills are transpiled to compat
    // We can probably remove the below check
    if (instanceIsCompatProxy) {
        return defaultHasInstance(instance, Type);
    }
    return Type[Symbol.hasInstance](instance);
}
function concat(replicaOrAny) {
    var fn = getKey(replicaOrAny, 'concat');
    if (fn === Array.prototype.concat) {
        fn = concat$1;
    }
    var args = [];
    var l = arguments.length;
    for (var i = 1; i < l; i++) {
        args[i - 1] = arguments[i];
    }
    return fn.apply(replicaOrAny, args);
}
function hasOwnProperty$2(replicaOrAny) {
    var fn = getKey(replicaOrAny, 'hasOwnProperty');
    if (fn === hasOwnProperty) {
        fn = hasOwnProperty$1;
    }
    var args = [];
    var l = arguments.length;
    for (var i = 1; i < l; i++) {
        args[i - 1] = arguments[i];
    }
    return fn.apply(replicaOrAny, args);
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// https://tc39.github.io/ecma262/#sec-array.isarray
// Important: The Array.isArray method is not dereferenced. This way it calls the polyfilled
// version of it, even if the polyfill is applied after the proxy-compat evaluation.
function isArray$1(replicaOrAny) {
    return isCompatProxy(replicaOrAny) ?
        replicaOrAny._ES5ProxyType === ProxyTypeArray :
        Array.isArray(replicaOrAny);
}
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.pop
function pop() {
    // 1. Let O be ? ToObject(this value).
    var O = Object(this);
    // 2. Let len be ? ToLength(? Get(O, "length")).
    var len = O.length;
    // 3. If len is zero, then
    if (len === 0) {
        // a. Perform ? Set(O, "length", 0, true). noop
        // b. Return undefined.
        return undefined;
        // 4. Else len > 0,
    }
    else if (len > 0) {
        // a. Let newLen be len-1.
        var newLen = len - 1;
        // b. Let index be ! ToString(newLen).
        var index = newLen;
        // c. Let element be ? Get(O, index).
        var element = getKey(O, index);
        // d. Perform ? DeletePropertyOrThrow(O, index).
        deleteKey(O, index);
        // e. Perform ? Set(O, "length", newLen, true).
        setKey(O, 'length', newLen);
        // f. Return element.
        return element;
    }
}
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.push
function push() {
    var O = Object(this);
    var n = O.length;
    var items = ArraySlice.call(arguments);
    while (items.length) {
        var E = ArrayShift.call(items);
        setKey(O, n, E);
        n += 1;
    }
    setKey(O, 'length', n);
    return O.length;
}
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.concat
function concat$1() {
    var O = Object(this);
    var A = [];
    var N = 0;
    var items = ArraySlice.call(arguments);
    ArrayUnshift.call(items, O);
    while (items.length) {
        var E = ArrayShift.call(items);
        if (isArray$1(E)) {
            var k = 0;
            var length = E.length;
            for (k; k < length; k += 1, N += 1) {
                var subElement = getKey(E, k);
                A[N] = subElement;
            }
        }
        else {
            A[N] = E;
            N += 1;
        }
    }
    return A;
}
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.shift
function shift() {
    // 1. Let O be ? ToObject(this value).
    var O = Object(this);
    // 2. Let len be ? ToLength(? Get(O, "length")).
    var len = O.length;
    // 3. If len is zero, then
    if (len === 0) {
        // a. Perform ? Set(O, "length", 0, true). noop
        // b. Return undefined.
        return undefined;
    }
    // 4. Let first be ? Get(O, "0").
    var first = getKey(O, 0);
    // 5. Let k be 1.
    var k = 1;
    // 6. Repeat, while k < len
    while (k < len) {
        // a. Let from be ! ToString(k).
        var from = k;
        // b. Let to be ! ToString(k-1).
        var to = k - 1;
        // c. Let fromPresent be ? HasProperty(O, from).
        var fromPresent = hasOwnProperty$1.call(O, from);
        // d. If fromPresent is true, then
        if (fromPresent) {
            // i. Let fromVal be ? Get(O, from).
            var fromVal = getKey(O, from);
            // ii. Perform ? Set(O, to, fromVal, true).
            setKey(O, to, fromVal);
        }
        else { // e. Else fromPresent is false,
            // i. Perform ? DeletePropertyOrThrow(O, to).
            deleteKey(O, to);
        }
        // f. Increase k by 1.
        k += 1;
    }
    // 7. Perform ? DeletePropertyOrThrow(O, ! ToString(len-1)).
    deleteKey(O, len - 1);
    // 8. Perform ? Set(O, "length", len-1, true).
    setKey(O, 'length', len - 1);
    // 9. Return first.
    return first;
}
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.unshift
function unshift() {
    var O = Object(this);
    var len = O.length;
    var argCount = arguments.length;
    var k = len;
    while (k > 0) {
        var from = k - 1;
        var to = k + argCount - 1;
        var fromPresent = hasOwnProperty$1.call(O, from);
        if (fromPresent) {
            var fromValue = O[from];
            setKey(O, to, fromValue);
        }
        else {
            deleteKey(O, to);
        }
        k -= 1;
    }
    var j = 0;
    var items = ArraySlice.call(arguments);
    while (items.length) {
        var E = ArrayShift.call(items);
        setKey(O, j, E);
        j += 1;
    }
    O.length = len + argCount;
    return O.length;
}
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.splice
function splice(start, deleteCount) {
    var argLength = arguments.length;
    // 1. Let O be ? ToObject(this value).
    var O = Object(this);
    // 2. Let len be ? ToLength(? Get(O, "length")).
    var len = O.length;
    // 3. Let relativeStart be ? ToInteger(start).
    var relativeStart = start;
    // 4. If relativeStart < 0, let actualStart be max((len + relativeStart), 0);
    // else let actualStart be min(relativeStart, len).
    var actualStart = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
    var actualDeleteCount;
    // 5. If the number of actual arguments is 0, then
    if (argLength === 0) {
        // a. Let insertCount be 0.
        // insertCount = 0 // not needed
        // b. Let actualDeleteCount be 0.
        actualDeleteCount = 0;
    }
    else if (argLength === 1) {
        // 6. Else if the number of actual arguments is 1, then
        // a. Let insertCount be 0.
        // insertCount = 0 // not needed
        // b. Let actualDeleteCount be len - actualStart.
        actualDeleteCount = len - actualStart;
    }
    else {
        // 7. Else,
        // a. Let insertCount be the number of actual arguments minus 2.
        // insertCount = argLength - 2; //not neede
        // b. Let dc be ? ToInteger(deleteCount).
        var dc = deleteCount;
        // c. Let actualDeleteCount be min(max(dc, 0), len - actualStart).
        actualDeleteCount = Math.min(Math.max(dc, 0), len - actualStart);
    }
    // 8. If len+insertCount-actualDeleteCount > 2^53-1, throw a TypeError exception
    // (noop)
    // 9. Let A be ? ArraySpeciesCreate(O, actualDeleteCount).
    var A = [];
    // 10. Let k be 0.
    var k = 0;
    // 11. Repeat, while k < actualDeleteCount
    while (k < actualDeleteCount) {
        // a. Let from be ! ToString(actualStart+k).
        var from = actualStart + k;
        // b. Let fromPresent be ? HasProperty(O, from).
        var fromPresent = hasOwnProperty$1.call(O, from);
        // c. If fromPresent is true, then
        if (fromPresent) {
            // i. Let fromValue be ? Get(O, from).
            var fromValue = O[from];
            // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(k), fromValue).
            A[k] = fromValue;
        }
        // d. Increment k by 1.
        k++;
    }
    // 12. Perform ? Set(A, "length", actualDeleteCount, true).
    // A.length = actualDeleteCount;
    // 13. Let items be a List whose elements are, in left to right order, the portion of the actual argument
    //     list starting with the third argument. The list is empty if fewer than three arguments were passed.
    var items = ArraySlice.call(arguments, 2) || [];
    // 14. Let itemCount be the number of elements in items.
    var itemCount = items.length;
    // 15. If itemCount < actualDeleteCount, then
    if (itemCount < actualDeleteCount) {
        // a. Let k be actualStart.
        k = actualStart;
        // b. Repeat, while k < (len - actualDeleteCount)
        while (k < len - actualDeleteCount) {
            // i. Let from be ! ToString(k+actualDeleteCount).
            var from = k + actualDeleteCount;
            // ii. Let to be ! ToString(k+itemCount).
            var to = k + itemCount;
            // iii. Let fromPresent be ? HasProperty(O, from).
            var fromPresent = hasOwnProperty$1.call(O, from);
            // iv. If fromPresent is true, then
            if (fromPresent) {
                // 1. Let fromValue be ? Get(O, from).
                var fromValue = O[from];
                // 2. Perform ? Set(O, to, fromValue, true).
                setKey(O, to, fromValue);
            }
            else {
                // v. Else fromPresent is false,
                // 1. Perform ? DeletePropertyOrThrow(O, to).
                deleteKey(O, to);
            }
            // vi. Increase k by 1.
            k++;
        }
        // c. Let k be len.
        k = len;
        // d. Repeat, while k > (len - actualDeleteCount + itemCount)
        while (k > len - actualDeleteCount + itemCount) {
            // i. Perform ? DeletePropertyOrThrow(O, ! ToString(k-1)).
            deleteKey(O, k - 1);
            // ii. Decrease k by 1.
            k--;
        }
    }
    else if (itemCount > actualDeleteCount) {
        // 16. Else if itemCount > actualDeleteCount, then
        // a. Let k be (len - actualDeleteCount).
        k = len - actualDeleteCount;
        // b. Repeat, while k > actualStart
        while (k > actualStart) {
            // i. Let from be ! ToString(k + actualDeleteCount - 1).
            var from = k + actualDeleteCount - 1;
            // ii. Let to be ! ToString(k + itemCount - 1).
            var to = k + itemCount - 1;
            // iii. Let fromPresent be ? HasProperty(O, from).
            var fromPresent = hasOwnProperty$1.call(O, from);
            // iv. If fromPresent is true, then
            if (fromPresent) {
                // 1. Let fromValue be ? Get(O, from).
                var fromValue = O[from];
                // 2. Perform ? Set(O, to, fromValue, true).
                setKey(O, to, fromValue);
            }
            else {
                // v. Else fromPresent is false,
                // 1. Perform ? DeletePropertyOrThrow(O, to).
                deleteKey(O, to);
            }
            // vi. Decrease k by 1.
            k--;
        }
    }
    // 17. Let k be actualStart.
    k = actualStart;
    // 18. Repeat, while items is not empty
    while (items.length) {
        // a. Remove the first element from items and let E be the value of that element.
        var E = items.shift();
        // b. Perform ? Set(O, ! ToString(k), E, true).
        setKey(O, k, E);
        // c. Increase k by 1.
        k++;
    }
    // 19. Perform ? Set(O, "length", len - actualDeleteCount + itemCount, true).
    setKey(O, 'length', len - actualDeleteCount + itemCount);
    // 20. Return A.
    return A;
}

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
function getPrototypeOf$1(replicaOrAny) {
    if (isCompatProxy(replicaOrAny)) {
        return replicaOrAny.getPrototypeOf();
    }
    return getPrototypeOf(replicaOrAny);
}
function setPrototypeOf$1(replicaOrAny, proto) {
    if (isCompatProxy(replicaOrAny)) {
        return replicaOrAny.setPrototypeOf(proto);
    }
    return setPrototypeOf(replicaOrAny, proto);
}
function preventExtensions$1(replicaOrAny) {
    if (isCompatProxy(replicaOrAny)) {
        return replicaOrAny.preventExtensions();
    }
    return preventExtensions(replicaOrAny);
}
function isExtensible$1(replicaOrAny) {
    if (isCompatProxy(replicaOrAny)) {
        return replicaOrAny.isExtensible();
    }
    return isExtensible(replicaOrAny);
}
// Object patches
// TODO: Instead of monkey patching, move all of these to be compatInstrinsicMethods
// like the ones right below.
Object.preventExtensions = preventExtensions$1;
Object.getOwnPropertyNames = getOwnPropertyNames$1;
Object.isExtensible = isExtensible$1;
Object.setPrototypeOf = setPrototypeOf$1;
Object.getPrototypeOf = getPrototypeOf$1;
// We need to ensure that added compat methods are not-enumerable to avoid leaking
// when using for ... in without guarding via Object.hasOwnProperty.
Object.defineProperties(Object, {
    compatKeys: { value: keys$1, enumerable: false },
    compatValues: { value: values, enumerable: false },
    compatEntries: { value: entries, enumerable: false },
    compatDefineProperty: { value: defineProperty$1, enumerable: false },
    compatAssign: { value: assign, enumerable: false },
    compatGetOwnPropertyDescriptor: { value: getOwnPropertyDescriptor$1, enumerable: false }
});
Object.defineProperties(Object.prototype, {
    compatHasOwnProperty: { value: hasOwnProperty$1, enumerable: false }
});
// Array patches
Object.defineProperties(Array, {
    compatIsArray: { value: isArray$1, enumerable: false }
});
Object.defineProperties(Array.prototype, {
    compatUnshift: { value: unshift, enumerable: false },
    compatConcat: { value: concat$1, enumerable: false },
    compatPush: { value: push, enumerable: false },
});
function overrideProxy() {
    return Proxy.__COMPAT__;
}
function makeGlobal(obj) {
    var global = (function () { return this; })() || Function('return this')();
    global.Proxy = obj;
}
// At this point Proxy can be the real Proxy (function) a noop-proxy (object with noop-keys) or undefined
var FinalProxy = typeof Proxy !== 'undefined' ? Proxy : {};
if (typeof FinalProxy !== 'function' || overrideProxy()) {
    FinalProxy = /** @class */ (function (_super) {
        __extends(Proxy, _super);
        function Proxy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Proxy;
    }(XProxy));
}
FinalProxy.isCompat = true;
FinalProxy.getKey = getKey;
FinalProxy.getKeys = getKeys;
FinalProxy.getKeys2 = getKeys2;
FinalProxy.getKeys3 = getKeys3;
FinalProxy.getKeys4 = getKeys4;
FinalProxy.callKey = callKey;
FinalProxy.callKey0 = callKey0;
FinalProxy.callKey1 = callKey1;
FinalProxy.callKey2 = callKey2;
FinalProxy.callKey3 = callKey3;
FinalProxy.callKey4 = callKey4;
FinalProxy.setKey = setKey;
FinalProxy.setKeyPostfixIncrement = setKeyPostfixIncrement;
FinalProxy.setKeyPostfixDecrement = setKeyPostfixDecrement;
FinalProxy.deleteKey = deleteKey;
FinalProxy.inKey = inKey;
FinalProxy.iterableKey = iterableKey;
FinalProxy.instanceOfKey = instanceOfKey;
FinalProxy.concat = concat;
FinalProxy.hasOwnProperty = hasOwnProperty$2;
if (typeof Proxy === 'undefined') {
    makeGlobal(FinalProxy);
}
var FinalProxy$1 = FinalProxy;

export default FinalProxy$1;
