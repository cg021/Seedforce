"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var methods_1 = require("./methods");
var intrinsics_1 = require("./intrinsics");
var utils_1 = require("./utils");
function getOwnPropertyDescriptor(replicaOrAny, key) {
    if (methods_1.isCompatProxy(replicaOrAny)) {
        return replicaOrAny.getOwnPropertyDescriptor(key);
    }
    return intrinsics_1.getOwnPropertyDescriptor(replicaOrAny, key);
}
exports.getOwnPropertyDescriptor = getOwnPropertyDescriptor;
function getOwnPropertyNames(replicaOrAny) {
    if (methods_1.isCompatProxy(replicaOrAny)) {
        return replicaOrAny.ownKeys().filter(function (key) { return key.constructor !== Symbol; }); // TODO: only strings
    }
    return intrinsics_1.getOwnPropertyNames(replicaOrAny);
}
exports.getOwnPropertyNames = getOwnPropertyNames;
// https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys
// https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys
function OwnPropertyKeys(O) {
    return intrinsics_1.ArrayConcat.call(Object.getOwnPropertyNames(O), Object.getOwnPropertySymbols(O));
}
exports.OwnPropertyKeys = OwnPropertyKeys;
function assign(replicaOrAny) {
    if (replicaOrAny == null) { // TypeError if undefined or null
        throw new TypeError('Cannot convert undefined or null to object');
    }
    var to = Object(replicaOrAny);
    for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];
        if (nextSource != null) { // Skip over if undefined or null
            var objectKeys = OwnPropertyKeys(nextSource);
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < objectKeys.length; i += 1) {
                var nextKey = objectKeys[i];
                var descriptor = getOwnPropertyDescriptor(nextSource, nextKey);
                if (descriptor !== undefined && descriptor.enumerable === true) {
                    methods_1.setKey(to, nextKey, methods_1.getKey(nextSource, nextKey));
                }
            }
        }
    }
    return to;
}
exports.assign = assign;
function hasOwnProperty(key) {
    if (methods_1.isCompatProxy(this)) {
        var descriptor = this.getOwnPropertyDescriptor(key);
        return !utils_1.isUndefined(descriptor);
    }
    else {
        return intrinsics_1.hasOwnProperty.call(this, key);
    }
}
exports.hasOwnProperty = hasOwnProperty;
function keys(replicaOrAny) {
    if (methods_1.isCompatProxy(replicaOrAny)) {
        var all = replicaOrAny.forIn();
        var result = [];
        // tslint:disable-next-line:forin
        for (var prop in all) {
            var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
            if (desc && desc.enumerable === true) {
                result.push(prop);
            }
        }
        return result;
    }
    else {
        return intrinsics_1.keys(replicaOrAny);
    }
}
exports.keys = keys;
function values(replicaOrAny) {
    if (methods_1.isCompatProxy(replicaOrAny)) {
        var all = replicaOrAny.forIn();
        var result = [];
        // tslint:disable-next-line:forin
        for (var prop in all) {
            var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
            if (desc && desc.enumerable === true) {
                result.push(methods_1.getKey(replicaOrAny, prop));
            }
        }
        return result;
    }
    else {
        // Calling `Object.values` instead of dereferencing the method during the module evaluation
        // since `Object.values` gets polyfilled at the module evaluation.
        return Object.values(replicaOrAny);
    }
}
exports.values = values;
function entries(replicaOrAny) {
    if (methods_1.isCompatProxy(replicaOrAny)) {
        var all = replicaOrAny.forIn();
        var result = [];
        // tslint:disable-next-line:forin
        for (var prop in all) {
            var desc = replicaOrAny.getOwnPropertyDescriptor(prop);
            if (desc && desc.enumerable === true) {
                result.push([
                    prop,
                    methods_1.getKey(replicaOrAny, prop)
                ]);
            }
        }
        return result;
    }
    else {
        // Calling `Object.entries` instead of dereferencing the method during the module evaluation
        // since `Object.entries` gets polyfilled at the module evaluation.
        return Object.entries(replicaOrAny);
    }
}
exports.entries = entries;
function defineProperty(replicaOrAny, prop, descriptor) {
    if (methods_1.isCompatProxy(replicaOrAny)) {
        replicaOrAny.defineProperty(prop, descriptor);
        return replicaOrAny;
    }
    else {
        return intrinsics_1.defineProperty(replicaOrAny, prop, descriptor);
    }
}
exports.defineProperty = defineProperty;
//# sourceMappingURL=module.js.map