"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var methods_1 = require("./methods");
var object_1 = require("./object");
var xproxy_1 = require("./xproxy");
var intrinsics_1 = require("./intrinsics");
// https://tc39.github.io/ecma262/#sec-array.isarray
// Important: The Array.isArray method is not dereferenced. This way it calls the polyfilled
// version of it, even if the polyfill is applied after the proxy-compat evaluation.
function isArray(replicaOrAny) {
    return methods_1.isCompatProxy(replicaOrAny) ?
        replicaOrAny._ES5ProxyType === xproxy_1.ProxyTypeArray :
        Array.isArray(replicaOrAny);
}
exports.isArray = isArray;
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.pop
function pop() {
    // 1. Let O be ? ToObject(this value).
    var O = Object(this);
    // 2. Let len be ? ToLength(? Get(O, "length")).
    var len = O.length;
    // 3. If len is zero, then
    if (len === 0) {
        // a. Perform ? Set(O, "length", 0, true). noop
        // b. Return undefined.
        return undefined;
        // 4. Else len > 0,
    }
    else if (len > 0) {
        // a. Let newLen be len-1.
        var newLen = len - 1;
        // b. Let index be ! ToString(newLen).
        var index = newLen;
        // c. Let element be ? Get(O, index).
        var element = methods_1.getKey(O, index);
        // d. Perform ? DeletePropertyOrThrow(O, index).
        methods_1.deleteKey(O, index);
        // e. Perform ? Set(O, "length", newLen, true).
        methods_1.setKey(O, 'length', newLen);
        // f. Return element.
        return element;
    }
}
exports.pop = pop;
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.push
function push() {
    var O = Object(this);
    var n = O.length;
    var items = intrinsics_1.ArraySlice.call(arguments);
    while (items.length) {
        var E = intrinsics_1.ArrayShift.call(items);
        methods_1.setKey(O, n, E);
        n += 1;
    }
    methods_1.setKey(O, 'length', n);
    return O.length;
}
exports.push = push;
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.concat
function concat() {
    var O = Object(this);
    var A = [];
    var N = 0;
    var items = intrinsics_1.ArraySlice.call(arguments);
    intrinsics_1.ArrayUnshift.call(items, O);
    while (items.length) {
        var E = intrinsics_1.ArrayShift.call(items);
        if (isArray(E)) {
            var k = 0;
            var length = E.length;
            for (k; k < length; k += 1, N += 1) {
                var subElement = methods_1.getKey(E, k);
                A[N] = subElement;
            }
        }
        else {
            A[N] = E;
            N += 1;
        }
    }
    return A;
}
exports.concat = concat;
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.shift
function shift() {
    // 1. Let O be ? ToObject(this value).
    var O = Object(this);
    // 2. Let len be ? ToLength(? Get(O, "length")).
    var len = O.length;
    // 3. If len is zero, then
    if (len === 0) {
        // a. Perform ? Set(O, "length", 0, true). noop
        // b. Return undefined.
        return undefined;
    }
    // 4. Let first be ? Get(O, "0").
    var first = methods_1.getKey(O, 0);
    // 5. Let k be 1.
    var k = 1;
    // 6. Repeat, while k < len
    while (k < len) {
        // a. Let from be ! ToString(k).
        var from = k;
        // b. Let to be ! ToString(k-1).
        var to = k - 1;
        // c. Let fromPresent be ? HasProperty(O, from).
        var fromPresent = object_1.hasOwnProperty.call(O, from);
        // d. If fromPresent is true, then
        if (fromPresent) {
            // i. Let fromVal be ? Get(O, from).
            var fromVal = methods_1.getKey(O, from);
            // ii. Perform ? Set(O, to, fromVal, true).
            methods_1.setKey(O, to, fromVal);
        }
        else { // e. Else fromPresent is false,
            // i. Perform ? DeletePropertyOrThrow(O, to).
            methods_1.deleteKey(O, to);
        }
        // f. Increase k by 1.
        k += 1;
    }
    // 7. Perform ? DeletePropertyOrThrow(O, ! ToString(len-1)).
    methods_1.deleteKey(O, len - 1);
    // 8. Perform ? Set(O, "length", len-1, true).
    methods_1.setKey(O, 'length', len - 1);
    // 9. Return first.
    return first;
}
exports.shift = shift;
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.unshift
function unshift() {
    var O = Object(this);
    var len = O.length;
    var argCount = arguments.length;
    var k = len;
    while (k > 0) {
        var from = k - 1;
        var to = k + argCount - 1;
        var fromPresent = object_1.hasOwnProperty.call(O, from);
        if (fromPresent) {
            var fromValue = O[from];
            methods_1.setKey(O, to, fromValue);
        }
        else {
            methods_1.deleteKey(O, to);
        }
        k -= 1;
    }
    var j = 0;
    var items = intrinsics_1.ArraySlice.call(arguments);
    while (items.length) {
        var E = intrinsics_1.ArrayShift.call(items);
        methods_1.setKey(O, j, E);
        j += 1;
    }
    O.length = len + argCount;
    return O.length;
}
exports.unshift = unshift;
// http://www.ecma-international.org/ecma-262/#sec-array.prototype.splice
function splice(start, deleteCount) {
    var argLength = arguments.length;
    // 1. Let O be ? ToObject(this value).
    var O = Object(this);
    // 2. Let len be ? ToLength(? Get(O, "length")).
    var len = O.length;
    // 3. Let relativeStart be ? ToInteger(start).
    var relativeStart = start;
    // 4. If relativeStart < 0, let actualStart be max((len + relativeStart), 0);
    // else let actualStart be min(relativeStart, len).
    var actualStart = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
    var actualDeleteCount;
    // 5. If the number of actual arguments is 0, then
    if (argLength === 0) {
        // a. Let insertCount be 0.
        // insertCount = 0 // not needed
        // b. Let actualDeleteCount be 0.
        actualDeleteCount = 0;
    }
    else if (argLength === 1) {
        // 6. Else if the number of actual arguments is 1, then
        // a. Let insertCount be 0.
        // insertCount = 0 // not needed
        // b. Let actualDeleteCount be len - actualStart.
        actualDeleteCount = len - actualStart;
    }
    else {
        // 7. Else,
        // a. Let insertCount be the number of actual arguments minus 2.
        // insertCount = argLength - 2; //not neede
        // b. Let dc be ? ToInteger(deleteCount).
        var dc = deleteCount;
        // c. Let actualDeleteCount be min(max(dc, 0), len - actualStart).
        actualDeleteCount = Math.min(Math.max(dc, 0), len - actualStart);
    }
    // 8. If len+insertCount-actualDeleteCount > 2^53-1, throw a TypeError exception
    // (noop)
    // 9. Let A be ? ArraySpeciesCreate(O, actualDeleteCount).
    var A = [];
    // 10. Let k be 0.
    var k = 0;
    // 11. Repeat, while k < actualDeleteCount
    while (k < actualDeleteCount) {
        // a. Let from be ! ToString(actualStart+k).
        var from = actualStart + k;
        // b. Let fromPresent be ? HasProperty(O, from).
        var fromPresent = object_1.hasOwnProperty.call(O, from);
        // c. If fromPresent is true, then
        if (fromPresent) {
            // i. Let fromValue be ? Get(O, from).
            var fromValue = O[from];
            // ii. Perform ? CreateDataPropertyOrThrow(A, ! ToString(k), fromValue).
            A[k] = fromValue;
        }
        // d. Increment k by 1.
        k++;
    }
    // 12. Perform ? Set(A, "length", actualDeleteCount, true).
    // A.length = actualDeleteCount;
    // 13. Let items be a List whose elements are, in left to right order, the portion of the actual argument
    //     list starting with the third argument. The list is empty if fewer than three arguments were passed.
    var items = intrinsics_1.ArraySlice.call(arguments, 2) || [];
    // 14. Let itemCount be the number of elements in items.
    var itemCount = items.length;
    // 15. If itemCount < actualDeleteCount, then
    if (itemCount < actualDeleteCount) {
        // a. Let k be actualStart.
        k = actualStart;
        // b. Repeat, while k < (len - actualDeleteCount)
        while (k < len - actualDeleteCount) {
            // i. Let from be ! ToString(k+actualDeleteCount).
            var from = k + actualDeleteCount;
            // ii. Let to be ! ToString(k+itemCount).
            var to = k + itemCount;
            // iii. Let fromPresent be ? HasProperty(O, from).
            var fromPresent = object_1.hasOwnProperty.call(O, from);
            // iv. If fromPresent is true, then
            if (fromPresent) {
                // 1. Let fromValue be ? Get(O, from).
                var fromValue = O[from];
                // 2. Perform ? Set(O, to, fromValue, true).
                methods_1.setKey(O, to, fromValue);
            }
            else {
                // v. Else fromPresent is false,
                // 1. Perform ? DeletePropertyOrThrow(O, to).
                methods_1.deleteKey(O, to);
            }
            // vi. Increase k by 1.
            k++;
        }
        // c. Let k be len.
        k = len;
        // d. Repeat, while k > (len - actualDeleteCount + itemCount)
        while (k > len - actualDeleteCount + itemCount) {
            // i. Perform ? DeletePropertyOrThrow(O, ! ToString(k-1)).
            methods_1.deleteKey(O, k - 1);
            // ii. Decrease k by 1.
            k--;
        }
    }
    else if (itemCount > actualDeleteCount) {
        // 16. Else if itemCount > actualDeleteCount, then
        // a. Let k be (len - actualDeleteCount).
        k = len - actualDeleteCount;
        // b. Repeat, while k > actualStart
        while (k > actualStart) {
            // i. Let from be ! ToString(k + actualDeleteCount - 1).
            var from = k + actualDeleteCount - 1;
            // ii. Let to be ! ToString(k + itemCount - 1).
            var to = k + itemCount - 1;
            // iii. Let fromPresent be ? HasProperty(O, from).
            var fromPresent = object_1.hasOwnProperty.call(O, from);
            // iv. If fromPresent is true, then
            if (fromPresent) {
                // 1. Let fromValue be ? Get(O, from).
                var fromValue = O[from];
                // 2. Perform ? Set(O, to, fromValue, true).
                methods_1.setKey(O, to, fromValue);
            }
            else {
                // v. Else fromPresent is false,
                // 1. Perform ? DeletePropertyOrThrow(O, to).
                methods_1.deleteKey(O, to);
            }
            // vi. Decrease k by 1.
            k--;
        }
    }
    // 17. Let k be actualStart.
    k = actualStart;
    // 18. Repeat, while items is not empty
    while (items.length) {
        // a. Remove the first element from items and let E be the value of that element.
        var E = items.shift();
        // b. Perform ? Set(O, ! ToString(k), E, true).
        methods_1.setKey(O, k, E);
        // c. Increase k by 1.
        k++;
    }
    // 19. Perform ? Set(O, "length", len - actualDeleteCount + itemCount, true).
    methods_1.setKey(O, 'length', len - actualDeleteCount + itemCount);
    // 20. Return A.
    return A;
}
exports.splice = splice;
//# sourceMappingURL=module.js.map