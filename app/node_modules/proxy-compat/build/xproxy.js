"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
var array_1 = require("./array");
var methods_1 = require("./methods");
var object_1 = require("./object");
var intrinsics_1 = require("./intrinsics");
exports.ProxyTypeObject = 1;
exports.ProxyTypeArray = 2;
// Proto chain check might be needed because of usage of a limited polyfill
// https://github.com/es-shims/get-own-property-symbols
// In this case, because this polyfill is assing all the stuff to Object.prototype to keep
// all the other invariants of Symbols, we need to do some manual checks here for the slow patch.
var isNotNativeSymbol;
exports.inOperator = function inOperatorCompat(obj, key) {
    if (isNotNativeSymbol === undefined) {
        if (typeof Symbol === 'undefined') {
            throw new Error('Symbol is not available. Make sure to apply symbol polyfill before calling inOperator');
        }
        isNotNativeSymbol = typeof Symbol() === 'object';
    }
    if (isNotNativeSymbol) {
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        if (key && key.constructor === Symbol) {
            while (obj) {
                if (getOwnPropertySymbols(obj).indexOf(key) !== -1) {
                    return true;
                }
                obj = intrinsics_1.getPrototypeOf(obj);
            }
            return false;
        }
        return key in obj;
    }
    return key in obj;
};
var defaultHandlerTraps = {
    get: function (target, key) {
        return target[key];
    },
    set: function (target, key, newValue) {
        target[key] = newValue;
        return true;
    },
    apply: function (targetFn, thisArg, argumentsList) {
        return targetFn.apply(thisArg, argumentsList);
    },
    construct: function (targetFn, argumentsList, newTarget) {
        return new (targetFn.bind.apply(targetFn, [void 0].concat(argumentsList)))();
    },
    defineProperty: function (target, property, descriptor) {
        intrinsics_1.defineProperty(target, property, descriptor);
        return true;
    },
    deleteProperty: function (target, property) {
        return delete target[property];
    },
    ownKeys: function (target) {
        return object_1.OwnPropertyKeys(target);
    },
    has: function (target, propertyKey) {
        return exports.inOperator(target, propertyKey);
    },
    preventExtensions: function (target) {
        intrinsics_1.preventExtensions(target);
        return true;
    },
    getOwnPropertyDescriptor: intrinsics_1.getOwnPropertyDescriptor,
    getPrototypeOf: intrinsics_1.getPrototypeOf,
    isExtensible: intrinsics_1.isExtensible,
    setPrototypeOf: intrinsics_1.setPrototypeOf,
};
var lastRevokeFn;
var proxyTrapFalsyErrors = {
    set: function (target, key) {
        throw new TypeError("'set' on proxy: trap returned falsish for property '" + key + "'");
    },
    deleteProperty: function (target, key) {
        throw new TypeError("'deleteProperty' on proxy: trap returned falsish for property '" + key + "'");
    },
    setPrototypeOf: function (target, proto) {
        throw new TypeError("'setPrototypeOf' on proxy: trap returned falsish");
    },
    preventExtensions: function (target, proto) {
        throw new TypeError("'preventExtensions' on proxy: trap returned falsish");
    },
    defineProperty: function (target, key, descriptor) {
        throw new TypeError("'defineProperty' on proxy: trap returned falsish for property '" + key + "'");
    }
};
function proxifyProperty(proxy, key, descriptor) {
    var enumerable = descriptor.enumerable, configurable = descriptor.configurable;
    intrinsics_1.defineProperty(proxy, key, {
        enumerable: enumerable,
        configurable: configurable,
        get: function () {
            return proxy.get(key);
        },
        set: function (value) {
            proxy.set(key, value);
        },
    });
}
var XProxy = /** @class */ (function () {
    function XProxy(target, handler) {
        var targetIsFunction = typeof target === 'function';
        var targetIsArray = intrinsics_1.isArray(target);
        if ((typeof target !== 'object' || target === null) && !targetIsFunction) {
            throw new Error("Cannot create proxy with a non-object as target");
        }
        if (typeof handler !== 'object' || handler === null) {
            throw new Error("new XProxy() expects the second argument to an object");
        }
        // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.
        // The caller might get the wrong revoke function if a user replaces or wraps XProxy
        // to call itself, but that seems unlikely especially when using the polyfill.
        var throwRevoked = false;
        lastRevokeFn = function () {
            throwRevoked = true;
        };
        // Define proxy as Object, or Function (if either it's callable, or apply is set).
        // tslint:disable-next-line:no-this-assignment
        var proxy = this; // reusing the already created object, eventually the prototype will be resetted
        if (targetIsFunction) {
            proxy = function Proxy() {
                var usingNew = (this && this.constructor === proxy);
                var args = intrinsics_1.ArraySlice.call(arguments);
                if (usingNew) {
                    return proxy.construct(args, this);
                }
                else {
                    return proxy.apply(this, args);
                }
            };
        }
        var _loop_1 = function (trapName) {
            intrinsics_1.defineProperty(proxy, trapName, {
                value: function () {
                    if (throwRevoked) {
                        throw new TypeError("Cannot perform '" + trapName + "' on a proxy that has been revoked");
                    }
                    var args = intrinsics_1.ArraySlice.call(arguments);
                    intrinsics_1.ArrayUnshift.call(args, target);
                    var h = handler[trapName] ? handler : defaultHandlerTraps;
                    var value = h[trapName].apply(h, args);
                    if (proxyTrapFalsyErrors[trapName] && value === false) {
                        proxyTrapFalsyErrors[trapName].apply(proxyTrapFalsyErrors, args);
                    }
                    return value;
                },
                writable: false,
                enumerable: false,
                configurable: false,
            });
        };
        // tslint:disable-next-line:forin
        for (var trapName in defaultHandlerTraps) {
            _loop_1(trapName);
        }
        var proxyDefaultHasInstance;
        var SymbolHasInstance = Symbol.hasInstance;
        var FunctionPrototypeSymbolHasInstance = Function.prototype[SymbolHasInstance];
        intrinsics_1.defineProperty(proxy, SymbolHasInstance, {
            get: function () {
                var hasInstance = proxy.get(SymbolHasInstance);
                // We do not want to deal with any Symbol.hasInstance here
                // because we need to do special things to check prototypes.
                // Symbol polyfill adds Symbol.hasInstance to the function prototype
                // so if we have that here, we need to return our own.
                // If the value we get from this function is different, that means
                // user has supplied custom function so we need to respect that.
                if (hasInstance === FunctionPrototypeSymbolHasInstance) {
                    return proxyDefaultHasInstance || (proxyDefaultHasInstance = function (inst) {
                        return methods_1.defaultHasInstance(inst, proxy);
                    });
                }
                return hasInstance;
            },
            configurable: false,
            enumerable: false
        });
        intrinsics_1.defineProperty(proxy, '_ES5ProxyType', {
            value: targetIsArray ? exports.ProxyTypeArray : exports.ProxyTypeObject,
            configurable: false,
            enumerable: false,
            writable: true,
        });
        intrinsics_1.defineProperty(proxy, 'forIn', {
            value: function () {
                return proxy.ownKeys().reduce(function (o, key) {
                    o[key] = void 0;
                    return o;
                }, intrinsics_1.create(null));
            },
            configurable: false,
            enumerable: false,
            writable: false,
        });
        var SymbolIterator = Symbol.iterator;
        intrinsics_1.defineProperty(proxy, SymbolIterator, {
            enumerable: false,
            configurable: true,
            get: function () {
                return this.get(SymbolIterator);
            },
            set: function (value) {
                this.set(SymbolIterator, value);
            },
        });
        if (targetIsArray) {
            var trackedLength_1 = 0;
            var adjustArrayIndex_1 = function (newLength) {
                // removing old indexes from proxy when needed
                while (trackedLength_1 > newLength) {
                    delete proxy[--trackedLength_1];
                }
                // add new indexes to proxy when needed
                for (var i = trackedLength_1; i < newLength; i += 1) {
                    proxifyProperty(proxy, i, {
                        enumerable: true,
                        configurable: true,
                    });
                }
                trackedLength_1 = newLength;
            };
            intrinsics_1.defineProperty(proxy, 'length', {
                enumerable: false,
                configurable: true,
                get: function () {
                    var proxyLength = proxy.get('length');
                    // check if the trackedLength matches the length of the proxy
                    if (proxyLength !== trackedLength_1) {
                        adjustArrayIndex_1(proxyLength);
                    }
                    return proxyLength;
                },
                set: function (value) {
                    proxy.set('length', value);
                },
            });
            // building the initial index. this is observable by the proxy
            // because we access the length property during the construction
            // of the proxy, but it should be fine...
            adjustArrayIndex_1(proxy.get('length'));
        }
        return proxy;
    }
    // tslint:disable-next-line:member-ordering
    XProxy.revocable = function (target, handler) {
        var p = new XProxy(target, handler);
        return {
            proxy: p,
            revoke: lastRevokeFn,
        };
    };
    XProxy.prototype.push = function () {
        var push = this.get('push');
        if (push === Array.prototype.push) {
            push = array_1.push;
        }
        return push.apply(this, arguments);
    };
    XProxy.prototype.pop = function () {
        var pop = this.get('pop');
        if (pop === Array.prototype.pop) {
            pop = array_1.pop;
        }
        return pop.apply(this, arguments);
    };
    XProxy.prototype.concat = function () {
        var concat = this.get('concat');
        if (concat === Array.prototype.concat) {
            concat = array_1.concat;
        }
        return concat.apply(this, arguments);
    };
    XProxy.prototype.splice = function () {
        var splice = this.get('splice');
        if (splice === Array.prototype.splice) {
            splice = array_1.splice;
        }
        return splice.apply(this, arguments);
    };
    XProxy.prototype.shift = function () {
        var shift = this.get('shift');
        if (shift === Array.prototype.shift) {
            shift = array_1.shift;
        }
        return shift.apply(this, arguments);
    };
    XProxy.prototype.unshift = function () {
        var unshift = this.get('unshift');
        if (unshift === Array.prototype.unshift) {
            unshift = array_1.unshift;
        }
        return unshift.apply(this, arguments);
    };
    XProxy.prototype.toJSON = function () {
        if (this._ES5ProxyType === exports.ProxyTypeArray) {
            var unwrappedArray = [];
            var length = this.get('length');
            for (var i = 0; i < length; i++) {
                unwrappedArray[i] = this.get(i);
            }
            return unwrappedArray;
        }
        else {
            var toJSON = this.get('toJSON');
            if (toJSON !== undefined && typeof toJSON === 'function') {
                return toJSON.apply(this, arguments);
            }
            var keys = this.ownKeys();
            var unwrappedObject = {};
            // tslint:disable-next-line:prefer-for-of
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var enumerable = this.getOwnPropertyDescriptor(key).enumerable;
                if (enumerable) {
                    unwrappedObject[key] = this.get(key);
                }
            }
            return unwrappedObject;
        }
    };
    return XProxy;
}());
exports.XProxy = XProxy;
//# sourceMappingURL=module.js.map