var LWC = (function (exports) {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    function __extends(d, b) {
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /* proxy-compat-disable */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect() {
        // Don't apply polyfill when ProxyCompat is enabled.
        if ('getKey' in Proxy) {
            return false;
        }
        var proxy = new Proxy([3, 4], {});
        var res = [1, 2].concat(proxy);
        return res.length !== 4;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var isConcatSpreadable = Symbol.isConcatSpreadable;
    var isArray = Array.isArray;
    var _b = Array.prototype, ArraySlice = _b.slice, ArrayUnshift = _b.unshift, ArrayShift = _b.shift;
    function isObject(O) {
        return typeof O === 'object' ? O !== null : typeof O === 'function';
    } // https://www.ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable
    function isSpreadable(O) {
        if (!isObject(O)) {
            return false;
        }
        var spreadable = O[isConcatSpreadable];
        return spreadable !== undefined ? Boolean(spreadable) : isArray(O);
    } // https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat
    function ArrayConcatPolyfill() {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
        var O = Object(this);
        var A = [];
        var N = 0;
        var items = ArraySlice.call(arguments);
        ArrayUnshift.call(items, O);
        while (items.length) {
            var E = ArrayShift.call(items);
            if (isSpreadable(E)) {
                var k_1 = 0;
                var length = E.length;
                for (k_1; k_1 < length; k_1 += 1, N += 1) {
                    if (k_1 in E) {
                        var subElement = E[k_1];
                        A[N] = subElement;
                    }
                }
            }
            else {
                A[N] = E;
                N += 1;
            }
        }
        return A;
    }
    function apply() {
        // eslint-disable-next-line no-extend-native
        Array.prototype.concat = ArrayConcatPolyfill;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (detect()) {
        apply();
    }
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function invariant(value, msg) {
        if (!value) {
            throw new Error("Invariant Violation: " + msg);
        }
    }
    function isTrue(value, msg) {
        if (!value) {
            throw new Error("Assert Violation: " + msg);
        }
    }
    function isFalse(value, msg) {
        if (value) {
            throw new Error("Assert Violation: " + msg);
        }
    }
    function fail(msg) {
        throw new Error(msg);
    }
    var assert = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        invariant: invariant,
        isTrue: isTrue,
        isFalse: isFalse,
        fail: fail
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var assign = Object.assign, create = Object.create, defineProperty = Object.defineProperty, freeze = Object.freeze, hasOwnProperty = Object.hasOwnProperty, keys = Object.keys, seal = Object.seal;
    var isArray$1 = Array.isArray;
    var _c = Array.prototype, ArrayJoin = _c.join, ArrayMap = _c.map, forEach = _c.forEach;
    var _d = String.prototype, StringReplace = _d.replace, StringToLowerCase = _d.toLowerCase;
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isNull(obj) {
        return obj === null;
    }
    function isFalse$1(obj) {
        return obj === false;
    }
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    function isObject$1(obj) {
        return typeof obj === 'object';
    }
    var OtS = {}.toString;
    function toString(obj) {
        if (obj && obj.toString) {
            // Arrays might hold objects with "null" prototype So using
            // Array.prototype.toString directly will cause an error Iterate through
            // all the items and handle individually.
            if (isArray$1(obj)) {
                return ArrayJoin.call(ArrayMap.call(obj, toString), ',');
            }
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            return OtS.call(obj);
        }
        else {
            return obj + emptyString;
        }
    }
    var emptyString = '';
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
     * ariaGrabbed) are deprecated:
     * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
     *
     * The above list of 46 aria attributes is consistent with the following resources:
     * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
     * https://wicg.github.io/aom/spec/aria-reflection.html
     */
    var AriaPropertyNames = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
    var AttrNameToPropNameMap = create(null);
    var PropNameToAttrNameMap = create(null); // Synthetic creation of all AOM property descriptors for Custom Elements
    forEach.call(AriaPropertyNames, function (propName) {
        // Typescript infers the wrong function type for this particular overloaded method:
        // https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        var attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, 'aria-'));
        AttrNameToPropNameMap[attrName] = propName;
        PropNameToAttrNameMap[propName] = attrName;
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Inspired from: https://mathiasbynens.be/notes/globalthis
    var _globalThis = function () {
        // On recent browsers, `globalThis` is already defined. In this case return it directly.
        if (typeof globalThis === 'object') {
            return globalThis;
        }
        var _globalThis;
        try {
            // eslint-disable-next-line no-extend-native
            Object.defineProperty(Object.prototype, '__magic__', {
                get: function () {
                    return this;
                },
                configurable: true
            }); // __magic__ is undefined in Safari 10 and IE10 and older.
            // @ts-ignore
            // eslint-disable-next-line no-undef
            _globalThis = __magic__; // @ts-ignore
            delete Object.prototype.__magic__;
        }
        catch (ex) { // In IE8, Object.defineProperty only works on DOM objects.
        }
        finally {
            // If the magic above fails for some reason we assume that we are in a legacy browser.
            // Assume `window` exists in this case.
            if (typeof _globalThis === 'undefined') {
                // @ts-ignore
                _globalThis = window;
            }
        }
        return _globalThis;
    }();
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /*
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */
    var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
    function createHiddenField(key, namespace) {
        return hasNativeSymbolsSupport ? Symbol(key) : "$$lwc-" + namespace + "-" + key + "$$";
    }
    var hiddenFieldsMap = new WeakMap();
    function setHiddenField(o, field, value) {
        var valuesByField = hiddenFieldsMap.get(o);
        if (isUndefined(valuesByField)) {
            valuesByField = create(null);
            hiddenFieldsMap.set(o, valuesByField);
        }
        valuesByField[field] = value;
    }
    function getHiddenField(o, field) {
        var valuesByField = hiddenFieldsMap.get(o);
        if (!isUndefined(valuesByField)) {
            return valuesByField[field];
        }
    }
    var HTML_ATTRIBUTES_TO_PROPERTY = {
        accesskey: 'accessKey',
        readonly: 'readOnly',
        tabindex: 'tabIndex',
        bgcolor: 'bgColor',
        colspan: 'colSpan',
        rowspan: 'rowSpan',
        contenteditable: 'contentEditable',
        crossorigin: 'crossOrigin',
        datetime: 'dateTime',
        formaction: 'formAction',
        ismap: 'isMap',
        maxlength: 'maxLength',
        minlength: 'minLength',
        novalidate: 'noValidate',
        usemap: 'useMap',
        for: 'htmlFor'
    };
    keys(HTML_ATTRIBUTES_TO_PROPERTY).forEach(function (attrName) { });
    /** version: 1.7.7 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect$1(propName) {
        return Object.getOwnPropertyDescriptor(Element.prototype, propName) === undefined;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var nodeToAriaPropertyValuesMap = new WeakMap();
    function getAriaPropertyMap(elm) {
        var map = nodeToAriaPropertyValuesMap.get(elm);
        if (map === undefined) {
            map = {};
            nodeToAriaPropertyValuesMap.set(elm, map);
        }
        return map;
    }
    function getNormalizedAriaPropertyValue(value) {
        return value == null ? null : String(value);
    }
    function createAriaPropertyPropertyDescriptor(propName, attrName) {
        return {
            get: function () {
                var map = getAriaPropertyMap(this);
                if (hasOwnProperty.call(map, propName)) {
                    return map[propName];
                } // otherwise just reflect what's in the attribute
                return this.hasAttribute(attrName) ? this.getAttribute(attrName) : null;
            },
            set: function (newValue) {
                var normalizedValue = getNormalizedAriaPropertyValue(newValue);
                var map = getAriaPropertyMap(this);
                map[propName] = normalizedValue; // reflect into the corresponding attribute
                if (newValue === null) {
                    this.removeAttribute(attrName);
                }
                else {
                    this.setAttribute(attrName, newValue);
                }
            },
            configurable: true,
            enumerable: true
        };
    }
    function patch(propName) {
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        var attrName = PropNameToAttrNameMap[propName];
        var descriptor = createAriaPropertyPropertyDescriptor(propName, attrName);
        Object.defineProperty(Element.prototype, propName, descriptor);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ElementPrototypeAriaPropertyNames = keys(PropNameToAttrNameMap);
    for (var i_1 = 0, len = ElementPrototypeAriaPropertyNames.length; i_1 < len; i_1 += 1) {
        var propName = ElementPrototypeAriaPropertyNames[i_1];
        if (detect$1(propName)) {
            patch(propName);
        }
    }
    /* proxy-compat-disable */
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function invariant$1(value, msg) {
        if (!value) {
            throw new Error("Invariant Violation: " + msg);
        }
    }
    function isTrue$1(value, msg) {
        if (!value) {
            throw new Error("Assert Violation: " + msg);
        }
    }
    function isFalse$2(value, msg) {
        if (value) {
            throw new Error("Assert Violation: " + msg);
        }
    }
    function fail$1(msg) {
        throw new Error(msg);
    }
    var assert$1 = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        invariant: invariant$1,
        isTrue: isTrue$1,
        isFalse: isFalse$2,
        fail: fail$1
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var assign$1 = Object.assign, create$1 = Object.create, defineProperties$1 = Object.defineProperties, defineProperty$1 = Object.defineProperty, freeze$1 = Object.freeze, getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor, getOwnPropertyNames$1 = Object.getOwnPropertyNames, getPrototypeOf$1 = Object.getPrototypeOf, hasOwnProperty$1 = Object.hasOwnProperty, isFrozen$1 = Object.isFrozen, keys$1 = Object.keys, seal$1 = Object.seal, setPrototypeOf$1 = Object.setPrototypeOf;
    var isArray$2 = Array.isArray;
    var _e = Array.prototype, ArrayIndexOf$1 = _e.indexOf, ArrayJoin$1 = _e.join, ArrayMap$1 = _e.map, ArrayPush$1 = _e.push, ArraySlice$2 = _e.slice, ArrayUnshift$2 = _e.unshift, forEach$1 = _e.forEach;
    var _f = String.prototype, StringCharCodeAt$1 = _f.charCodeAt, StringReplace$1 = _f.replace, StringSlice$1 = _f.slice, StringToLowerCase$1 = _f.toLowerCase;
    function isUndefined$1(obj) {
        return obj === undefined;
    }
    function isNull$1(obj) {
        return obj === null;
    }
    function isTrue$1$1(obj) {
        return obj === true;
    }
    function isFalse$1$1(obj) {
        return obj === false;
    }
    function isFunction$1(obj) {
        return typeof obj === 'function';
    }
    function isObject$2(obj) {
        return typeof obj === 'object';
    }
    function isString(obj) {
        return typeof obj === 'string';
    }
    function isNumber(obj) {
        return typeof obj === 'number';
    }
    var OtS$1 = {}.toString;
    function toString$1(obj) {
        if (obj && obj.toString) {
            // Arrays might hold objects with "null" prototype So using
            // Array.prototype.toString directly will cause an error Iterate through
            // all the items and handle individually.
            if (isArray$2(obj)) {
                return ArrayJoin$1.call(ArrayMap$1.call(obj, toString$1), ',');
            }
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            return OtS$1.call(obj);
        }
        else {
            return obj + emptyString$1;
        }
    }
    function getPropertyDescriptor(o, p) {
        do {
            var d_1 = getOwnPropertyDescriptor$1(o, p);
            if (!isUndefined$1(d_1)) {
                return d_1;
            }
            o = getPrototypeOf$1(o);
        } while (o !== null);
    }
    var emptyString$1 = '';
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
     * ariaGrabbed) are deprecated:
     * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
     *
     * The above list of 46 aria attributes is consistent with the following resources:
     * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
     * https://wicg.github.io/aom/spec/aria-reflection.html
     */
    var AriaPropertyNames$1 = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
    var AttrNameToPropNameMap$1 = create$1(null);
    var PropNameToAttrNameMap$1 = create$1(null); // Synthetic creation of all AOM property descriptors for Custom Elements
    forEach$1.call(AriaPropertyNames$1, function (propName) {
        // Typescript infers the wrong function type for this particular overloaded method:
        // https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        var attrName = StringToLowerCase$1.call(StringReplace$1.call(propName, /^aria/, 'aria-'));
        AttrNameToPropNameMap$1[attrName] = propName;
        PropNameToAttrNameMap$1[propName] = attrName;
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Inspired from: https://mathiasbynens.be/notes/globalthis
    var _globalThis$1 = function () {
        // On recent browsers, `globalThis` is already defined. In this case return it directly.
        if (typeof globalThis === 'object') {
            return globalThis;
        }
        var _globalThis;
        try {
            // eslint-disable-next-line no-extend-native
            Object.defineProperty(Object.prototype, '__magic__', {
                get: function () {
                    return this;
                },
                configurable: true
            }); // __magic__ is undefined in Safari 10 and IE10 and older.
            // @ts-ignore
            // eslint-disable-next-line no-undef
            _globalThis = __magic__; // @ts-ignore
            delete Object.prototype.__magic__;
        }
        catch (ex) { // In IE8, Object.defineProperty only works on DOM objects.
        }
        finally {
            // If the magic above fails for some reason we assume that we are in a legacy browser.
            // Assume `window` exists in this case.
            if (typeof _globalThis === 'undefined') {
                // @ts-ignore
                _globalThis = window;
            }
        }
        return _globalThis;
    }();
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /*
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */
    var hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';
    function createHiddenField$1(key, namespace) {
        return hasNativeSymbolsSupport$1 ? Symbol(key) : "$$lwc-" + namespace + "-" + key + "$$";
    }
    var hiddenFieldsMap$1 = new WeakMap();
    function setHiddenField$1(o, field, value) {
        var valuesByField = hiddenFieldsMap$1.get(o);
        if (isUndefined$1(valuesByField)) {
            valuesByField = create$1(null);
            hiddenFieldsMap$1.set(o, valuesByField);
        }
        valuesByField[field] = value;
    }
    function getHiddenField$1(o, field) {
        var valuesByField = hiddenFieldsMap$1.get(o);
        if (!isUndefined$1(valuesByField)) {
            return valuesByField[field];
        }
    }
    var HTML_ATTRIBUTES_TO_PROPERTY$1 = {
        accesskey: 'accessKey',
        readonly: 'readOnly',
        tabindex: 'tabIndex',
        bgcolor: 'bgColor',
        colspan: 'colSpan',
        rowspan: 'rowSpan',
        contenteditable: 'contentEditable',
        crossorigin: 'crossOrigin',
        datetime: 'dateTime',
        formaction: 'formAction',
        ismap: 'isMap',
        maxlength: 'maxLength',
        minlength: 'minLength',
        novalidate: 'noValidate',
        usemap: 'useMap',
        for: 'htmlFor'
    };
    keys$1(HTML_ATTRIBUTES_TO_PROPERTY$1).forEach(function (attrName) { });
    /** version: 1.7.7 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var nextTickCallbackQueue = [];
    var SPACE_CHAR = 32;
    var EmptyObject = seal$1(create$1(null));
    var EmptyArray = seal$1([]);
    function flushCallbackQueue() {
        if (process.env.NODE_ENV !== 'production') {
            if (nextTickCallbackQueue.length === 0) {
                throw new Error("Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.");
            }
        }
        var callbacks = nextTickCallbackQueue;
        nextTickCallbackQueue = []; // reset to a new queue
        for (var i_2 = 0, len = callbacks.length; i_2 < len; i_2 += 1) {
            callbacks[i_2]();
        }
    }
    function addCallbackToNextTick(callback) {
        if (process.env.NODE_ENV !== 'production') {
            if (!isFunction$1(callback)) {
                throw new Error("Internal Error: addCallbackToNextTick() can only accept a function callback");
            }
        }
        if (nextTickCallbackQueue.length === 0) {
            Promise.resolve().then(flushCallbackQueue);
        }
        ArrayPush$1.call(nextTickCallbackQueue, callback);
    }
    function guid() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }
    /*
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var create$1$1 = Object.create;
    var _g = Array.prototype, ArraySplice$1$1 = _g.splice, ArrayIndexOf$1$1 = _g.indexOf, ArrayPush$1$1 = _g.push;
    var TargetToReactiveRecordMap = new WeakMap();
    function isUndefined$1$1(obj) {
        return obj === undefined;
    }
    function getReactiveRecord(target) {
        var reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (isUndefined$1$1(reactiveRecord)) {
            var newRecord = create$1$1(null);
            reactiveRecord = newRecord;
            TargetToReactiveRecordMap.set(target, newRecord);
        }
        return reactiveRecord;
    }
    var currentReactiveObserver = null;
    function valueMutated(target, key) {
        var reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (!isUndefined$1$1(reactiveRecord)) {
            var reactiveObservers = reactiveRecord[key];
            if (!isUndefined$1$1(reactiveObservers)) {
                for (var i_3 = 0, len = reactiveObservers.length; i_3 < len; i_3 += 1) {
                    var ro = reactiveObservers[i_3];
                    ro.notify();
                }
            }
        }
    }
    function valueObserved(target, key) {
        // We should determine if an active Observing Record is present to track mutations.
        if (currentReactiveObserver === null) {
            return;
        }
        var ro = currentReactiveObserver;
        var reactiveRecord = getReactiveRecord(target);
        var reactiveObservers = reactiveRecord[key];
        if (isUndefined$1$1(reactiveObservers)) {
            reactiveObservers = [];
            reactiveRecord[key] = reactiveObservers;
        }
        else if (reactiveObservers[0] === ro) {
            return; // perf optimization considering that most subscriptions will come from the same record
        }
        if (ArrayIndexOf$1$1.call(reactiveObservers, ro) === -1) {
            ro.link(reactiveObservers);
        }
    }
    var ReactiveObserver = /** @class */ (function () {
        function ReactiveObserver(callback) {
            this.listeners = [];
            this.callback = callback;
        }
        ReactiveObserver.prototype.observe = function (job) {
            var inceptionReactiveRecord = currentReactiveObserver;
            currentReactiveObserver = this;
            var error;
            try {
                job();
            }
            catch (e) {
                error = Object(e);
            }
            finally {
                currentReactiveObserver = inceptionReactiveRecord;
                if (error !== undefined) {
                    throw error; // eslint-disable-line no-unsafe-finally
                }
            }
        };
        /**
         * This method is responsible for disconnecting the Reactive Observer
         * from any Reactive Record that has a reference to it, to prevent future
         * notifications about previously recorded access.
         */
        ReactiveObserver.prototype.reset = function () {
            var listeners = this.listeners;
            var len = listeners.length;
            if (len > 0) {
                for (var i_4 = 0; i_4 < len; i_4 += 1) {
                    var set = listeners[i_4];
                    var pos = ArrayIndexOf$1$1.call(listeners[i_4], this);
                    ArraySplice$1$1.call(set, pos, 1);
                }
                listeners.length = 0;
            }
        }; // friend methods
        ReactiveObserver.prototype.notify = function () {
            this.callback.call(undefined, this);
        };
        ReactiveObserver.prototype.link = function (reactiveObservers) {
            ArrayPush$1$1.call(reactiveObservers, this); // we keep track of observing records where the observing record was added to so we can do some clean up later on
            ArrayPush$1$1.call(this.listeners, reactiveObservers);
        };
        return ReactiveObserver;
    }());
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function componentValueMutated(vm, key) {
        valueMutated(vm.component, key);
    }
    function componentValueObserved(vm, key) {
        valueObserved(vm.component, key);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getComponentTag(vm) {
        return "<" + StringToLowerCase$1.call(vm.tagName) + ">";
    } // TODO [#1695]: Unify getComponentStack and getErrorComponentStack
    function getComponentStack(vm) {
        var stack = [];
        var prefix = '';
        while (!isNull$1(vm.owner)) {
            ArrayPush$1.call(stack, prefix + getComponentTag(vm));
            vm = vm.owner;
            prefix += '\t';
        }
        return ArrayJoin$1.call(stack, '\n');
    }
    function getErrorComponentStack(vm) {
        var wcStack = [];
        var currentVm = vm;
        while (!isNull$1(currentVm)) {
            ArrayPush$1.call(wcStack, getComponentTag(currentVm));
            currentVm = currentVm.owner;
        }
        return wcStack.reverse().join('\n\t');
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function logError(message, vm) {
        var msg = "[LWC error]: " + message;
        if (!isUndefined$1(vm)) {
            msg = msg + "\n" + getComponentStack(vm);
        }
        if (process.env.NODE_ENV === 'test') {
            /* eslint-disable-next-line no-console */
            console.error(msg);
            return;
        }
        try {
            throw new Error(msg);
        }
        catch (e) {
            /* eslint-disable-next-line no-console */
            console.error(e);
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function handleEvent(event, vnode) {
        var type = event.type;
        var on = vnode.data.on;
        var handler = on && on[type]; // call event handler if exists
        if (handler) {
            handler.call(undefined, event);
        }
    }
    function createListener() {
        return function handler(event) {
            handleEvent(event, handler.vnode);
        };
    }
    function updateAllEventListeners(oldVnode, vnode) {
        if (isUndefined$1(oldVnode.listener)) {
            createAllEventListeners(vnode);
        }
        else {
            vnode.listener = oldVnode.listener;
            vnode.listener.vnode = vnode;
        }
    }
    function createAllEventListeners(vnode) {
        var elm = vnode.elm, on = vnode.data.on, renderer = vnode.owner.renderer;
        if (isUndefined$1(on)) {
            return;
        }
        var listener = vnode.listener = createListener();
        listener.vnode = vnode;
        var name;
        for (name in on) {
            renderer.addEventListener(elm, name, listener);
        }
    }
    var modEvents = {
        update: updateAllEventListeners,
        create: createAllEventListeners
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var defaultDefHTMLPropertyNames = ['accessKey', 'dir', 'draggable', 'hidden', 'id', 'lang', 'spellcheck', 'tabIndex', 'title']; // Few more exceptions that are using the attribute name to match the property in lowercase.
    // this list was compiled from https://msdn.microsoft.com/en-us/library/ms533062(v=vs.85).aspx
    // and https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
    // Note: this list most be in sync with the compiler as well.
    var HTMLPropertyNamesWithLowercasedReflectiveAttributes = ['accessKey', 'readOnly', 'tabIndex', 'bgColor', 'colSpan', 'rowSpan', 'contentEditable', 'dateTime', 'formAction', 'isMap', 'maxLength', 'useMap'];
    function offsetPropertyErrorMessage(name) {
        return "Using the `" + name + "` property is an anti-pattern because it rounds the value to an integer. Instead, use the `getBoundingClientRect` method to obtain fractional values for the size of an element and its position relative to the viewport.";
    } // Global HTML Attributes & Properties
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
    var globalHTMLProperties = assign$1(create$1(null), {
        accessKey: {
            attribute: 'accesskey'
        },
        accessKeyLabel: {
            readOnly: true
        },
        className: {
            attribute: 'class',
            error: 'Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead.'
        },
        contentEditable: {
            attribute: 'contenteditable'
        },
        dataset: {
            readOnly: true,
            error: "Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead."
        },
        dir: {
            attribute: 'dir'
        },
        draggable: {
            attribute: 'draggable'
        },
        dropzone: {
            attribute: 'dropzone',
            readOnly: true
        },
        hidden: {
            attribute: 'hidden'
        },
        id: {
            attribute: 'id'
        },
        inputMode: {
            attribute: 'inputmode'
        },
        lang: {
            attribute: 'lang'
        },
        slot: {
            attribute: 'slot',
            error: 'Using the `slot` property is an anti-pattern.'
        },
        spellcheck: {
            attribute: 'spellcheck'
        },
        style: {
            attribute: 'style'
        },
        tabIndex: {
            attribute: 'tabindex'
        },
        title: {
            attribute: 'title'
        },
        translate: {
            attribute: 'translate'
        },
        // additional "global attributes" that are not present in the link above.
        isContentEditable: {
            readOnly: true
        },
        offsetHeight: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetHeight')
        },
        offsetLeft: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetLeft')
        },
        offsetParent: {
            readOnly: true
        },
        offsetTop: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetTop')
        },
        offsetWidth: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetWidth')
        },
        role: {
            attribute: 'role'
        }
    });
    var AttrNameToPropNameMap$1$1 = assign$1(create$1(null), AttrNameToPropNameMap$1);
    var PropNameToAttrNameMap$1$1 = assign$1(create$1(null), PropNameToAttrNameMap$1);
    forEach$1.call(defaultDefHTMLPropertyNames, function (propName) {
        var attrName = StringToLowerCase$1.call(propName);
        AttrNameToPropNameMap$1$1[attrName] = propName;
        PropNameToAttrNameMap$1$1[propName] = attrName;
    });
    forEach$1.call(HTMLPropertyNamesWithLowercasedReflectiveAttributes, function (propName) {
        var attrName = StringToLowerCase$1.call(propName);
        AttrNameToPropNameMap$1$1[attrName] = propName;
        PropNameToAttrNameMap$1$1[propName] = attrName;
    });
    var CAPS_REGEX = /[A-Z]/g;
    /**
     * This method maps between property names
     * and the corresponding attribute name.
     */
    function getAttrNameFromPropName(propName) {
        if (isUndefined$1(PropNameToAttrNameMap$1$1[propName])) {
            PropNameToAttrNameMap$1$1[propName] = StringReplace$1.call(propName, CAPS_REGEX, function (match) { return '-' + match.toLowerCase(); });
        }
        return PropNameToAttrNameMap$1$1[propName];
    }
    var controlledElement = null;
    var controlledAttributeName;
    function isAttributeLocked(elm, attrName) {
        return elm !== controlledElement || attrName !== controlledAttributeName;
    }
    function lockAttribute(_elm, _key) {
        controlledElement = null;
        controlledAttributeName = undefined;
    }
    function unlockAttribute(elm, key) {
        controlledElement = elm;
        controlledAttributeName = key;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var xlinkNS = 'http://www.w3.org/1999/xlink';
    var xmlNS = 'http://www.w3.org/XML/1998/namespace';
    var ColonCharCode = 58;
    function updateAttrs(oldVnode, vnode) {
        var attrs = vnode.data.attrs, renderer = vnode.owner.renderer;
        if (isUndefined$1(attrs)) {
            return;
        }
        var oldAttrs = oldVnode.data.attrs;
        if (oldAttrs === attrs) {
            return;
        }
        if (process.env.NODE_ENV !== 'production') {
            assert$1.invariant(isUndefined$1(oldAttrs) || keys$1(oldAttrs).join(',') === keys$1(attrs).join(','), "vnode.data.attrs cannot change shape.");
        }
        var elm = vnode.elm;
        var setAttribute = renderer.setAttribute, removeAttribute = renderer.removeAttribute;
        var key;
        oldAttrs = isUndefined$1(oldAttrs) ? EmptyObject : oldAttrs; // update modified attributes, add new attributes
        // this routine is only useful for data-* attributes in all kind of elements
        // and aria-* in standard elements (custom elements will use props for these)
        for (key in attrs) {
            var cur = attrs[key];
            var old = oldAttrs[key];
            if (old !== cur) {
                unlockAttribute(elm, key);
                if (StringCharCodeAt$1.call(key, 3) === ColonCharCode) {
                    // Assume xml namespace
                    setAttribute(elm, key, cur, xmlNS);
                }
                else if (StringCharCodeAt$1.call(key, 5) === ColonCharCode) {
                    // Assume xlink namespace
                    setAttribute(elm, key, cur, xlinkNS);
                }
                else if (isNull$1(cur)) {
                    removeAttribute(elm, key);
                }
                else {
                    setAttribute(elm, key, cur);
                }
                lockAttribute();
            }
        }
    }
    var emptyVNode = {
        data: {}
    };
    var modAttrs = {
        create: function (vnode) { return updateAttrs(emptyVNode, vnode); },
        update: updateAttrs
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isLiveBindingProp(sel, key) {
        // For properties with live bindings, we read values from the DOM element
        // instead of relying on internally tracked values.
        return sel === 'input' && (key === 'value' || key === 'checked');
    }
    function update(oldVnode, vnode) {
        var props = vnode.data.props;
        if (isUndefined$1(props)) {
            return;
        }
        var oldProps = oldVnode.data.props;
        if (oldProps === props) {
            return;
        }
        if (process.env.NODE_ENV !== 'production') {
            assert$1.invariant(isUndefined$1(oldProps) || keys$1(oldProps).join(',') === keys$1(props).join(','), 'vnode.data.props cannot change shape.');
        }
        var isFirstPatch = isUndefined$1(oldProps);
        var elm = vnode.elm, sel = vnode.sel, renderer = vnode.owner.renderer;
        for (var key in props) {
            var cur = props[key]; // if it is the first time this element is patched, or the current value is different to the previous value...
            if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? renderer.getProperty(elm, key) : oldProps[key])) {
                renderer.setProperty(elm, key, cur);
            }
        }
    }
    var emptyVNode$1 = {
        data: {}
    };
    var modProps = {
        create: function (vnode) { return update(emptyVNode$1, vnode); },
        update: update
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var classNameToClassMap = create$1(null);
    function getMapFromClassName(className) {
        // Intentionally using == to match undefined and null values from computed style attribute
        if (className == null) {
            return EmptyObject;
        } // computed class names must be string
        className = isString(className) ? className : className + '';
        var map = classNameToClassMap[className];
        if (map) {
            return map;
        }
        map = create$1(null);
        var start = 0;
        var o;
        var len = className.length;
        for (o = 0; o < len; o++) {
            if (StringCharCodeAt$1.call(className, o) === SPACE_CHAR) {
                if (o > start) {
                    map[StringSlice$1.call(className, start, o)] = true;
                }
                start = o + 1;
            }
        }
        if (o > start) {
            map[StringSlice$1.call(className, start, o)] = true;
        }
        classNameToClassMap[className] = map;
        if (process.env.NODE_ENV !== 'production') {
            // just to make sure that this object never changes as part of the diffing algo
            freeze$1(map);
        }
        return map;
    }
    function updateClassAttribute(oldVnode, vnode) {
        var elm = vnode.elm, newClass = vnode.data.className, renderer = vnode.owner.renderer;
        var oldClass = oldVnode.data.className;
        if (oldClass === newClass) {
            return;
        }
        var classList = renderer.getClassList(elm);
        var newClassMap = getMapFromClassName(newClass);
        var oldClassMap = getMapFromClassName(oldClass);
        var name;
        for (name in oldClassMap) {
            // remove only if it is not in the new class collection and it is not set from within the instance
            if (isUndefined$1(newClassMap[name])) {
                classList.remove(name);
            }
        }
        for (name in newClassMap) {
            if (isUndefined$1(oldClassMap[name])) {
                classList.add(name);
            }
        }
    }
    var emptyVNode$2 = {
        data: {}
    };
    var modComputedClassName = {
        create: function (vnode) { return updateClassAttribute(emptyVNode$2, vnode); },
        update: updateClassAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function updateStyleAttribute(oldVnode, vnode) {
        var elm = vnode.elm, newStyle = vnode.data.style, renderer = vnode.owner.renderer;
        var getStyleDeclaration = renderer.getStyleDeclaration, removeAttribute = renderer.removeAttribute;
        if (oldVnode.data.style === newStyle) {
            return;
        }
        var style = getStyleDeclaration(elm);
        if (!isString(newStyle) || newStyle === '') {
            removeAttribute(elm, 'style');
        }
        else {
            style.cssText = newStyle;
        }
    }
    var emptyVNode$3 = {
        data: {}
    };
    var modComputedStyle = {
        create: function (vnode) { return updateStyleAttribute(emptyVNode$3, vnode); },
        update: updateStyleAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The compiler takes care of transforming the inline classnames into an object. It's faster to set the
    // different classnames properties individually instead of via a string.
    function createClassAttribute(vnode) {
        var elm = vnode.elm, classMap = vnode.data.classMap, renderer = vnode.owner.renderer;
        if (isUndefined$1(classMap)) {
            return;
        }
        var classList = renderer.getClassList(elm);
        for (var name in classMap) {
            classList.add(name);
        }
    }
    var modStaticClassName = {
        create: createClassAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The compiler takes care of transforming the inline style into an object. It's faster to set the
    // different style properties individually instead of via a string.
    function createStyleAttribute(vnode) {
        var elm = vnode.elm, styleMap = vnode.data.styleMap, renderer = vnode.owner.renderer;
        if (isUndefined$1(styleMap)) {
            return;
        }
        var style = renderer.getStyleDeclaration(elm);
        for (var name in styleMap) {
            style[name] = styleMap[name];
        }
    }
    var modStaticStyle = {
        create: createStyleAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
    @license
    Copyright (c) 2015 Simon Friis Vindum.
    This code may only be used under the MIT License found at
    https://github.com/snabbdom/snabbdom/blob/master/LICENSE
    Code distributed by Snabbdom as part of the Snabbdom project at
    https://github.com/snabbdom/snabbdom/
    */
    function isUndef(s) {
        return s === undefined;
    }
    function sameVnode(vnode1, vnode2) {
        return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
    }
    function isVNode(vnode) {
        return vnode != null;
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
        var map = {};
        var j, key, ch; // TODO [#1637]: simplify this by assuming that all vnodes has keys
        for (j = beginIdx; j <= endIdx; ++j) {
            ch = children[j];
            if (isVNode(ch)) {
                key = ch.key;
                if (key !== undefined) {
                    map[key] = j;
                }
            }
        }
        return map;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (isVNode(ch)) {
                ch.hook.create(ch);
                ch.hook.insert(ch, parentElm, before);
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx]; // text nodes do not have logic associated to them
            if (isVNode(ch)) {
                ch.hook.remove(ch, parentElm);
            }
        }
    }
    function updateDynamicChildren(parentElm, oldCh, newCh) {
        var oldStartIdx = 0;
        var newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newEndIdx = newCh.length - 1;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (!isVNode(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (!isVNode(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (!isVNode(newStartVnode)) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (!isVNode(newEndVnode)) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode);
                newEndVnode.hook.move(oldStartVnode, parentElm, oldEndVnode.owner.renderer.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode);
                newStartVnode.hook.move(oldEndVnode, parentElm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    // New element
                    newStartVnode.hook.create(newStartVnode);
                    newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (isVNode(elmToMove)) {
                        if (elmToMove.sel !== newStartVnode.sel) {
                            // New element
                            newStartVnode.hook.create(newStartVnode);
                            newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);
                        }
                        else {
                            patchVnode(elmToMove, newStartVnode);
                            oldCh[idxInOld] = undefined;
                            newStartVnode.hook.move(elmToMove, parentElm, oldStartVnode.elm);
                        }
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
            if (oldStartIdx > oldEndIdx) {
                var n = newCh[newEndIdx + 1];
                before = isVNode(n) ? n.elm : null;
                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
            }
            else {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }
    }
    function updateStaticChildren(parentElm, oldCh, newCh) {
        var length = newCh.length;
        if (oldCh.length === 0) {
            // the old list is empty, we can directly insert anything new
            addVnodes(parentElm, null, newCh, 0, length);
            return;
        } // if the old list is not empty, the new list MUST have the same
        // amount of nodes, that's why we call this static children
        var referenceElm = null;
        for (var i_5 = length - 1; i_5 >= 0; i_5 -= 1) {
            var vnode = newCh[i_5];
            var oldVNode = oldCh[i_5];
            if (vnode !== oldVNode) {
                if (isVNode(oldVNode)) {
                    if (isVNode(vnode)) {
                        // both vnodes must be equivalent, and se just need to patch them
                        patchVnode(oldVNode, vnode);
                        referenceElm = vnode.elm;
                    }
                    else {
                        // removing the old vnode since the new one is null
                        oldVNode.hook.remove(oldVNode, parentElm);
                    }
                }
                else if (isVNode(vnode)) {
                    // this condition is unnecessary
                    vnode.hook.create(vnode); // insert the new node one since the old one is null
                    vnode.hook.insert(vnode, parentElm, referenceElm);
                    referenceElm = vnode.elm;
                }
            }
        }
    }
    function patchVnode(oldVnode, vnode) {
        if (oldVnode !== vnode) {
            vnode.elm = oldVnode.elm;
            vnode.hook.update(oldVnode, vnode);
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function generateDataDescriptor(options) {
        return assign$1({
            configurable: true,
            enumerable: true,
            writable: true
        }, options);
    }
    function generateAccessorDescriptor(options) {
        return assign$1({
            configurable: true,
            enumerable: true
        }, options);
    }
    var isDomMutationAllowed = false;
    function unlockDomMutation() {
        if (process.env.NODE_ENV === 'production') {
            // this method should never leak to prod
            throw new ReferenceError();
        }
        isDomMutationAllowed = true;
    }
    function lockDomMutation() {
        if (process.env.NODE_ENV === 'production') {
            // this method should never leak to prod
            throw new ReferenceError();
        }
        isDomMutationAllowed = false;
    }
    function logMissingPortalError(name, type) {
        return logError("The `" + name + "` " + type + " is available only on elements that use the `lwc:dom=\"manual\"` directive.");
    }
    function patchElementWithRestrictions(elm, options) {
        if (process.env.NODE_ENV === 'production') {
            // this method should never leak to prod
            throw new ReferenceError();
        }
        var originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');
        var descriptors = {
            outerHTML: generateAccessorDescriptor({
                get: function () {
                    return originalOuterHTMLDescriptor.get.call(this);
                },
                set: function (_value) {
                    throw new TypeError("Invalid attempt to set outerHTML on Element.");
                }
            })
        }; // Apply extra restriction related to DOM manipulation if the element is not a portal.
        if (isFalse$1$1(options.isPortal)) {
            var appendChild_1 = elm.appendChild, insertBefore_1 = elm.insertBefore, removeChild_1 = elm.removeChild, replaceChild_1 = elm.replaceChild;
            var originalNodeValueDescriptor_1 = getPropertyDescriptor(elm, 'nodeValue');
            var originalInnerHTMLDescriptor_1 = getPropertyDescriptor(elm, 'innerHTML');
            var originalTextContentDescriptor_1 = getPropertyDescriptor(elm, 'textContent');
            assign$1(descriptors, {
                appendChild: generateDataDescriptor({
                    value: function (aChild) {
                        logMissingPortalError('appendChild', 'method');
                        return appendChild_1.call(this, aChild);
                    }
                }),
                insertBefore: generateDataDescriptor({
                    value: function (newNode, referenceNode) {
                        if (!isDomMutationAllowed) {
                            logMissingPortalError('insertBefore', 'method');
                        }
                        return insertBefore_1.call(this, newNode, referenceNode);
                    }
                }),
                removeChild: generateDataDescriptor({
                    value: function (aChild) {
                        if (!isDomMutationAllowed) {
                            logMissingPortalError('removeChild', 'method');
                        }
                        return removeChild_1.call(this, aChild);
                    }
                }),
                replaceChild: generateDataDescriptor({
                    value: function (newChild, oldChild) {
                        logMissingPortalError('replaceChild', 'method');
                        return replaceChild_1.call(this, newChild, oldChild);
                    }
                }),
                nodeValue: generateAccessorDescriptor({
                    get: function () {
                        return originalNodeValueDescriptor_1.get.call(this);
                    },
                    set: function (value) {
                        if (!isDomMutationAllowed) {
                            logMissingPortalError('nodeValue', 'property');
                        }
                        originalNodeValueDescriptor_1.set.call(this, value);
                    }
                }),
                textContent: generateAccessorDescriptor({
                    get: function () {
                        return originalTextContentDescriptor_1.get.call(this);
                    },
                    set: function (value) {
                        logMissingPortalError('textContent', 'property');
                        originalTextContentDescriptor_1.set.call(this, value);
                    }
                }),
                innerHTML: generateAccessorDescriptor({
                    get: function () {
                        return originalInnerHTMLDescriptor_1.get.call(this);
                    },
                    set: function (value) {
                        logMissingPortalError('innerHTML', 'property');
                        return originalInnerHTMLDescriptor_1.set.call(this, value);
                    }
                })
            });
        }
        defineProperties$1(elm, descriptors);
    }
    var BLOCKED_SHADOW_ROOT_METHODS = ['cloneNode', 'getElementById', 'getSelection', 'elementsFromPoint', 'dispatchEvent'];
    function getShadowRootRestrictionsDescriptors(sr) {
        if (process.env.NODE_ENV === 'production') {
            // this method should never leak to prod
            throw new ReferenceError();
        } // Disallowing properties in dev mode only to avoid people doing the wrong
        // thing when using the real shadow root, because if that's the case,
        // the component will not work when running with synthetic shadow.
        var originalAddEventListener = sr.addEventListener;
        var originalInnerHTMLDescriptor = getPropertyDescriptor(sr, 'innerHTML');
        var originalTextContentDescriptor = getPropertyDescriptor(sr, 'textContent');
        var descriptors = {
            innerHTML: generateAccessorDescriptor({
                get: function () {
                    return originalInnerHTMLDescriptor.get.call(this);
                },
                set: function (_value) {
                    throw new TypeError("Invalid attempt to set innerHTML on ShadowRoot.");
                }
            }),
            textContent: generateAccessorDescriptor({
                get: function () {
                    return originalTextContentDescriptor.get.call(this);
                },
                set: function (_value) {
                    throw new TypeError("Invalid attempt to set textContent on ShadowRoot.");
                }
            }),
            addEventListener: generateDataDescriptor({
                value: function (type, listener, options) {
                    // TODO [#420]: this is triggered when the component author attempts to add a listener
                    // programmatically into its Component's shadow root
                    if (!isUndefined$1(options)) {
                        logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));
                    } // Typescript does not like it when you treat the `arguments` object as an array
                    // @ts-ignore type-mismatch
                    return originalAddEventListener.apply(this, arguments);
                }
            })
        };
        forEach$1.call(BLOCKED_SHADOW_ROOT_METHODS, function (methodName) {
            descriptors[methodName] = generateAccessorDescriptor({
                get: function () {
                    throw new Error("Disallowed method \"" + methodName + "\" in ShadowRoot.");
                }
            });
        });
        return descriptors;
    } // Custom Elements Restrictions:
    // -----------------------------
    function getCustomElementRestrictionsDescriptors(elm) {
        if (process.env.NODE_ENV === 'production') {
            // this method should never leak to prod
            throw new ReferenceError();
        }
        var originalAddEventListener = elm.addEventListener;
        var originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');
        var originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');
        var originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');
        return {
            innerHTML: generateAccessorDescriptor({
                get: function () {
                    return originalInnerHTMLDescriptor.get.call(this);
                },
                set: function (_value) {
                    throw new TypeError("Invalid attempt to set innerHTML on HTMLElement.");
                }
            }),
            outerHTML: generateAccessorDescriptor({
                get: function () {
                    return originalOuterHTMLDescriptor.get.call(this);
                },
                set: function (_value) {
                    throw new TypeError("Invalid attempt to set outerHTML on HTMLElement.");
                }
            }),
            textContent: generateAccessorDescriptor({
                get: function () {
                    return originalTextContentDescriptor.get.call(this);
                },
                set: function (_value) {
                    throw new TypeError("Invalid attempt to set textContent on HTMLElement.");
                }
            }),
            addEventListener: generateDataDescriptor({
                value: function (type, listener, options) {
                    // TODO [#420]: this is triggered when the component author attempts to add a listener
                    // programmatically into a lighting element node
                    if (!isUndefined$1(options)) {
                        logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));
                    } // Typescript does not like it when you treat the `arguments` object as an array
                    // @ts-ignore type-mismatch
                    return originalAddEventListener.apply(this, arguments);
                }
            })
        };
    }
    function getComponentRestrictionsDescriptors() {
        if (process.env.NODE_ENV === 'production') {
            // this method should never leak to prod
            throw new ReferenceError();
        }
        return {
            tagName: generateAccessorDescriptor({
                get: function () {
                    throw new Error("Usage of property `tagName` is disallowed because the component itself does" + " not know which tagName will be used to create the element, therefore writing" + " code that check for that value is error prone.");
                },
                configurable: true,
                enumerable: false
            })
        };
    }
    function getLightningElementPrototypeRestrictionsDescriptors(proto) {
        if (process.env.NODE_ENV === 'production') {
            // this method should never leak to prod
            throw new ReferenceError();
        }
        var originalDispatchEvent = proto.dispatchEvent;
        var descriptors = {
            dispatchEvent: generateDataDescriptor({
                value: function (event) {
                    var vm = getAssociatedVM(this);
                    if (!isNull$1(event) && isObject$2(event)) {
                        var type = event.type;
                        if (!/^[a-z][a-z0-9_]*$/.test(type)) {
                            logError("Invalid event type \"" + type + "\" dispatched in element " + getComponentTag(vm) + "." + " Event name must start with a lowercase letter and followed only lowercase" + " letters, numbers, and underscores", vm);
                        }
                    } // Typescript does not like it when you treat the `arguments` object as an array
                    // @ts-ignore type-mismatch
                    return originalDispatchEvent.apply(this, arguments);
                }
            })
        };
        forEach$1.call(getOwnPropertyNames$1(globalHTMLProperties), function (propName) {
            if (propName in proto) {
                return; // no need to redefine something that we are already exposing
            }
            descriptors[propName] = generateAccessorDescriptor({
                get: function () {
                    var _b = globalHTMLProperties[propName], error = _b.error, attribute = _b.attribute;
                    var msg = [];
                    msg.push("Accessing the global HTML property \"" + propName + "\" is disabled.");
                    if (error) {
                        msg.push(error);
                    }
                    else if (attribute) {
                        msg.push("Instead access it via `this.getAttribute(\"" + attribute + "\")`.");
                    }
                    logError(msg.join('\n'), getAssociatedVM(this));
                },
                set: function () {
                    var readOnly = globalHTMLProperties[propName].readOnly;
                    if (readOnly) {
                        logError("The global HTML property `" + propName + "` is read-only.", getAssociatedVM(this));
                    }
                }
            });
        });
        return descriptors;
    } // This routine will prevent access to certain properties on a shadow root instance to guarantee
    // that all components will work fine in IE11 and other browsers without shadow dom support.
    function patchShadowRootWithRestrictions(sr) {
        defineProperties$1(sr, getShadowRootRestrictionsDescriptors(sr));
    }
    function patchCustomElementWithRestrictions(elm) {
        var restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm);
        var elmProto = getPrototypeOf$1(elm);
        setPrototypeOf$1(elm, create$1(elmProto, restrictionsDescriptors));
    }
    function patchComponentWithRestrictions(cmp) {
        defineProperties$1(cmp, getComponentRestrictionsDescriptors());
    }
    function patchLightningElementPrototypeWithRestrictions(proto) {
        defineProperties$1(proto, getLightningElementPrototypeRestrictionsDescriptors(proto));
    }
    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // This is a temporary workaround to get the @lwc/engine-server to evaluate in node without having
    // to inject at runtime.
    var HTMLElementConstructor = typeof HTMLElement !== 'undefined' ? HTMLElement : function () { };
    var HTMLElementPrototype = HTMLElementConstructor.prototype;
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This is a descriptor map that contains
     * all standard properties that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base HTML Element and
     * Base Lightning Element should support.
     */
    var HTMLElementOriginalDescriptors = create$1(null);
    forEach$1.call(keys$1(PropNameToAttrNameMap$1), function (propName) {
        // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
        // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.
        var descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);
        if (!isUndefined$1(descriptor)) {
            HTMLElementOriginalDescriptors[propName] = descriptor;
        }
    });
    forEach$1.call(defaultDefHTMLPropertyNames, function (propName) {
        // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
        // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into
        // this category, so, better to be sure.
        var descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);
        if (!isUndefined$1(descriptor)) {
            HTMLElementOriginalDescriptors[propName] = descriptor;
        }
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This operation is called with a descriptor of an standard html property
     * that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors
     * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.
     */
    function createBridgeToElementDescriptor(propName, descriptor) {
        var get = descriptor.get, set = descriptor.set, enumerable = descriptor.enumerable, configurable = descriptor.configurable;
        if (!isFunction$1(get)) {
            if (process.env.NODE_ENV !== 'production') {
                assert$1.fail("Detected invalid public property descriptor for HTMLElement.prototype." + propName + " definition. Missing the standard getter.");
            }
            throw new TypeError();
        }
        if (!isFunction$1(set)) {
            if (process.env.NODE_ENV !== 'production') {
                assert$1.fail("Detected invalid public property descriptor for HTMLElement.prototype." + propName + " definition. Missing the standard setter.");
            }
            throw new TypeError();
        }
        return {
            enumerable: enumerable,
            configurable: configurable,
            get: function () {
                var vm = getAssociatedVM(this);
                if (isBeingConstructed(vm)) {
                    if (process.env.NODE_ENV !== 'production') {
                        logError("The value of property `" + propName + "` can't be read from the constructor because the owner component hasn't set the value yet. Instead, use the constructor to set a default value for the property.", vm);
                    }
                    return;
                }
                componentValueObserved(vm, propName);
                return get.call(vm.elm);
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                if (process.env.NODE_ENV !== 'production') {
                    var vmBeingRendered_1 = getVMBeingRendered();
                    assert$1.invariant(!isInvokingRender, vmBeingRendered_1 + ".render() method has side effects on the state of " + vm + "." + propName);
                    assert$1.invariant(!isUpdatingTemplate, "When updating the template of " + vmBeingRendered_1 + ", one of the accessors used by the template has side effects on the state of " + vm + "." + propName);
                    assert$1.isFalse(isBeingConstructed(vm), "Failed to construct '" + getComponentTag(vm) + "': The result must not have attributes.");
                    assert$1.invariant(!isObject$2(newValue) || isNull$1(newValue), "Invalid value \"" + newValue + "\" for \"" + propName + "\" of " + vm + ". Value cannot be an object, must be a primitive value.");
                }
                if (newValue !== vm.cmpProps[propName]) {
                    vm.cmpProps[propName] = newValue;
                    componentValueMutated(vm, propName);
                }
                return set.call(vm.elm, newValue);
            }
        };
    }
    /**
     * This class is the base class for any LWC element.
     * Some elements directly extends this class, others implement it via inheritance.
     **/
    function BaseLightningElementConstructor() {
        var _a; // This should be as performant as possible, while any initialization should be done lazily
        if (isNull$1(vmBeingConstructed)) {
            throw new ReferenceError('Illegal constructor');
        }
        var vm = vmBeingConstructed;
        var elm = vm.elm, mode = vm.mode, renderer = vm.renderer, ctor = vm.def.ctor;
        if (process.env.NODE_ENV !== 'production') {
            (_a = renderer.assertInstanceOfHTMLElement) === null || _a === void 0 ? void 0 : _a.call(renderer, vm.elm, "Component creation requires a DOM element to be associated to " + vm + ".");
        }
        var component = this;
        var cmpRoot = renderer.attachShadow(elm, {
            mode: mode,
            delegatesFocus: !!ctor.delegatesFocus,
            '$$lwc-synthetic-mode$$': true
        });
        vm.component = this;
        vm.cmpRoot = cmpRoot; // Locker hooks assignment. When the LWC engine run with Locker, Locker intercepts all the new
        // component creation and passes hooks to instrument all the component interactions with the
        // engine. We are intentionally hiding this argument from the formal API of LightningElement
        // because we don't want folks to know about it just yet.
        if (arguments.length === 1) {
            var _b = arguments[0], callHook_1 = _b.callHook, setHook_1 = _b.setHook, getHook_1 = _b.getHook;
            vm.callHook = callHook_1;
            vm.setHook = setHook_1;
            vm.getHook = getHook_1;
        } // Linking elm, shadow root and component with the VM.
        associateVM(component, vm);
        associateVM(cmpRoot, vm);
        associateVM(elm, vm); // Adding extra guard rails in DEV mode.
        if (process.env.NODE_ENV !== 'production') {
            patchCustomElementWithRestrictions(elm);
            patchComponentWithRestrictions(component);
            patchShadowRootWithRestrictions(cmpRoot);
        }
        return this;
    }
    BaseLightningElementConstructor.prototype = {
        constructor: BaseLightningElementConstructor,
        dispatchEvent: function (event) {
            var _b = getAssociatedVM(this), elm = _b.elm, dispatchEvent = _b.renderer.dispatchEvent;
            return dispatchEvent(elm, event);
        },
        addEventListener: function (type, listener, options) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, addEventListener = vm.renderer.addEventListener;
            if (process.env.NODE_ENV !== 'production') {
                var vmBeingRendered_2 = getVMBeingRendered();
                assert$1.invariant(!isInvokingRender, vmBeingRendered_2 + ".render() method has side effects on the state of " + vm + " by adding an event listener for \"" + type + "\".");
                assert$1.invariant(!isUpdatingTemplate, "Updating the template of " + vmBeingRendered_2 + " has side effects on the state of " + vm + " by adding an event listener for \"" + type + "\".");
                assert$1.invariant(isFunction$1(listener), "Invalid second argument for this.addEventListener() in " + vm + " for event \"" + type + "\". Expected an EventListener but received " + listener + ".");
            }
            var wrappedListener = getWrappedComponentsListener(vm, listener);
            addEventListener(elm, type, wrappedListener, options);
        },
        removeEventListener: function (type, listener, options) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, removeEventListener = vm.renderer.removeEventListener;
            var wrappedListener = getWrappedComponentsListener(vm, listener);
            removeEventListener(elm, type, wrappedListener, options);
        },
        hasAttribute: function (name) {
            var _b = getAssociatedVM(this), elm = _b.elm, getAttribute = _b.renderer.getAttribute;
            return !isNull$1(getAttribute(elm, name));
        },
        hasAttributeNS: function (namespace, name) {
            var _b = getAssociatedVM(this), elm = _b.elm, getAttribute = _b.renderer.getAttribute;
            return !isNull$1(getAttribute(elm, name, namespace));
        },
        removeAttribute: function (name) {
            var _b = getAssociatedVM(this), elm = _b.elm, removeAttribute = _b.renderer.removeAttribute;
            unlockAttribute(elm, name);
            removeAttribute(elm, name);
            lockAttribute();
        },
        removeAttributeNS: function (namespace, name) {
            var _b = getAssociatedVM(this), elm = _b.elm, removeAttribute = _b.renderer.removeAttribute;
            unlockAttribute(elm, name);
            removeAttribute(elm, name, namespace);
            lockAttribute();
        },
        getAttribute: function (name) {
            var _b = getAssociatedVM(this), elm = _b.elm, getAttribute = _b.renderer.getAttribute;
            return getAttribute(elm, name);
        },
        getAttributeNS: function (namespace, name) {
            var _b = getAssociatedVM(this), elm = _b.elm, getAttribute = _b.renderer.getAttribute;
            return getAttribute(elm, name, namespace);
        },
        setAttribute: function (name, value) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, setAttribute = vm.renderer.setAttribute;
            if (process.env.NODE_ENV !== 'production') {
                assert$1.isFalse(isBeingConstructed(vm), "Failed to construct '" + getComponentTag(vm) + "': The result must not have attributes.");
            }
            unlockAttribute(elm, name);
            setAttribute(elm, name, value);
            lockAttribute();
        },
        setAttributeNS: function (namespace, name, value) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, setAttribute = vm.renderer.setAttribute;
            if (process.env.NODE_ENV !== 'production') {
                assert$1.isFalse(isBeingConstructed(vm), "Failed to construct '" + getComponentTag(vm) + "': The result must not have attributes.");
            }
            unlockAttribute(elm, name);
            setAttribute(elm, name, value, namespace);
            lockAttribute();
        },
        getBoundingClientRect: function () {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, getBoundingClientRect = vm.renderer.getBoundingClientRect;
            if (process.env.NODE_ENV !== 'production') {
                assert$1.isFalse(isBeingConstructed(vm), "this.getBoundingClientRect() should not be called during the construction of the custom element for " + getComponentTag(vm) + " because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.");
            }
            return getBoundingClientRect(elm);
        },
        querySelector: function (selectors) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, querySelector = vm.renderer.querySelector;
            if (process.env.NODE_ENV !== 'production') {
                assert$1.isFalse(isBeingConstructed(vm), "this.querySelector() cannot be called during the construction of the custom element for " + getComponentTag(vm) + " because no children has been added to this element yet.");
            }
            return querySelector(elm, selectors);
        },
        querySelectorAll: function (selectors) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, querySelectorAll = vm.renderer.querySelectorAll;
            if (process.env.NODE_ENV !== 'production') {
                assert$1.isFalse(isBeingConstructed(vm), "this.querySelectorAll() cannot be called during the construction of the custom element for " + getComponentTag(vm) + " because no children has been added to this element yet.");
            }
            return querySelectorAll(elm, selectors);
        },
        getElementsByTagName: function (tagNameOrWildCard) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, getElementsByTagName = vm.renderer.getElementsByTagName;
            if (process.env.NODE_ENV !== 'production') {
                assert$1.isFalse(isBeingConstructed(vm), "this.getElementsByTagName() cannot be called during the construction of the custom element for " + getComponentTag(vm) + " because no children has been added to this element yet.");
            }
            return getElementsByTagName(elm, tagNameOrWildCard);
        },
        getElementsByClassName: function (names) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, getElementsByClassName = vm.renderer.getElementsByClassName;
            if (process.env.NODE_ENV !== 'production') {
                assert$1.isFalse(isBeingConstructed(vm), "this.getElementsByClassName() cannot be called during the construction of the custom element for " + getComponentTag(vm) + " because no children has been added to this element yet.");
            }
            return getElementsByClassName(elm, names);
        },
        get isConnected() {
            var _b = getAssociatedVM(this), elm = _b.elm, isConnected = _b.renderer.isConnected;
            return isConnected(elm);
        },
        get classList() {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, getClassList = vm.renderer.getClassList;
            if (process.env.NODE_ENV !== 'production') {
                // TODO [#1290]: this still fails in dev but works in production, eventually, we should
                // just throw in all modes
                assert$1.isFalse(isBeingConstructed(vm), "Failed to construct " + vm + ": The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.");
            }
            return getClassList(elm);
        },
        get template() {
            var vm = getAssociatedVM(this);
            return vm.cmpRoot;
        },
        get shadowRoot() {
            // From within the component instance, the shadowRoot is always reported as "closed".
            // Authors should rely on this.template instead.
            return null;
        },
        render: function () {
            var vm = getAssociatedVM(this);
            return vm.def.template;
        },
        toString: function () {
            var vm = getAssociatedVM(this);
            return "[object " + vm.def.name + "]";
        }
    };
    var lightningBasedDescriptors = create$1(null);
    for (var propName in HTMLElementOriginalDescriptors) {
        lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);
    }
    defineProperties$1(BaseLightningElementConstructor.prototype, lightningBasedDescriptors);
    defineProperty$1(BaseLightningElementConstructor, 'CustomElementConstructor', {
        get: function () {
            // If required, a runtime-specific implementation must be defined.
            throw new ReferenceError('The current runtime does not support CustomElementConstructor.');
        },
        configurable: true
    });
    if (process.env.NODE_ENV !== 'production') {
        patchLightningElementPrototypeWithRestrictions(BaseLightningElementConstructor.prototype);
    } // @ts-ignore
    var BaseLightningElement = BaseLightningElementConstructor;
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * @wire decorator to wire fields and methods to a wire adapter in
     * LWC Components. This function implements the internals of this
     * decorator.
     */
    function wire(_adapter, _config) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.fail('@wire(adapter, config?) may only be used as a decorator.');
        }
        throw new Error();
    }
    function internalWireFieldDecorator(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                componentValueObserved(vm, key);
                return vm.cmpFields[key];
            },
            set: function (value) {
                var vm = getAssociatedVM(this);
                /**
                 * Reactivity for wired fields is provided in wiring.
                 * We intentionally add reactivity here since this is just
                 * letting the author to do the wrong thing, but it will keep our
                 * system to be backward compatible.
                 */
                if (value !== vm.cmpFields[key]) {
                    vm.cmpFields[key] = value;
                    componentValueMutated(vm, key);
                }
            },
            enumerable: true,
            configurable: true
        };
    }
    /**
     * Copyright (C) 2017 salesforce.com, inc.
     */
    var isArray$1$1 = Array.isArray;
    var getPrototypeOf$1$1 = Object.getPrototypeOf, ObjectCreate = Object.create, ObjectDefineProperty = Object.defineProperty, isExtensible = Object.isExtensible, getOwnPropertyDescriptor$1$1 = Object.getOwnPropertyDescriptor, getOwnPropertyNames$1$1 = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, preventExtensions = Object.preventExtensions, hasOwnProperty$1$1 = Object.hasOwnProperty;
    var _h = Array.prototype, ArrayPush$2 = _h.push, ArrayConcat = _h.concat;
    var OtS$1$1 = {}.toString;
    function toString$1$1(obj) {
        if (obj && obj.toString) {
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            return OtS$1$1.call(obj);
        }
        else {
            return obj + '';
        }
    }
    function isUndefined$2(obj) {
        return obj === undefined;
    }
    function isFunction$1$1(obj) {
        return typeof obj === 'function';
    }
    function isObject$1$1(obj) {
        return typeof obj === 'object';
    }
    var proxyToValueMap = new WeakMap();
    function registerProxy(proxy, value) {
        proxyToValueMap.set(proxy, value);
    }
    var unwrap = function (replicaOrAny) { return proxyToValueMap.get(replicaOrAny) || replicaOrAny; };
    function wrapValue(membrane, value) {
        return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;
    }
    /**
     * Unwrap property descriptors will set value on original descriptor
     * We only need to unwrap if value is specified
     * @param descriptor external descrpitor provided to define new property on original value
     */
    function unwrapDescriptor(descriptor) {
        if (hasOwnProperty$1$1.call(descriptor, 'value')) {
            descriptor.value = unwrap(descriptor.value);
        }
        return descriptor;
    }
    function lockShadowTarget(membrane, shadowTarget, originalTarget) {
        var targetKeys = ArrayConcat.call(getOwnPropertyNames$1$1(originalTarget), getOwnPropertySymbols(originalTarget));
        targetKeys.forEach(function (key) {
            var descriptor = getOwnPropertyDescriptor$1$1(originalTarget, key); // We do not need to wrap the descriptor if configurable
            // Because we can deal with wrapping it when user goes through
            // Get own property descriptor. There is also a chance that this descriptor
            // could change sometime in the future, so we can defer wrapping
            // until we need to
            if (!descriptor.configurable) {
                descriptor = wrapDescriptor(membrane, descriptor, wrapValue);
            }
            ObjectDefineProperty(shadowTarget, key, descriptor);
        });
        preventExtensions(shadowTarget);
    }
    var ReactiveProxyHandler = /** @class */ (function () {
        function ReactiveProxyHandler(membrane, value) {
            this.originalTarget = value;
            this.membrane = membrane;
        }
        ReactiveProxyHandler.prototype.get = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            var value = originalTarget[key];
            var valueObserved = membrane.valueObserved;
            valueObserved(originalTarget, key);
            return membrane.getProxy(value);
        };
        ReactiveProxyHandler.prototype.set = function (shadowTarget, key, value) {
            var _b = this, originalTarget = _b.originalTarget, valueMutated = _b.membrane.valueMutated;
            var oldValue = originalTarget[key];
            if (oldValue !== value) {
                originalTarget[key] = value;
                valueMutated(originalTarget, key);
            }
            else if (key === 'length' && isArray$1$1(originalTarget)) {
                // fix for issue #236: push will add the new index, and by the time length
                // is updated, the internal length is already equal to the new length value
                // therefore, the oldValue is equal to the value. This is the forking logic
                // to support this use case.
                valueMutated(originalTarget, key);
            }
            return true;
        };
        ReactiveProxyHandler.prototype.deleteProperty = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, valueMutated = _b.membrane.valueMutated;
            delete originalTarget[key];
            valueMutated(originalTarget, key);
            return true;
        };
        ReactiveProxyHandler.prototype.apply = function (shadowTarget, thisArg, argArray) {
            /* No op */
        };
        ReactiveProxyHandler.prototype.construct = function (target, argArray, newTarget) {
            /* No op */
        };
        ReactiveProxyHandler.prototype.has = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, valueObserved = _b.membrane.valueObserved;
            valueObserved(originalTarget, key);
            return key in originalTarget;
        };
        ReactiveProxyHandler.prototype.ownKeys = function (shadowTarget) {
            var originalTarget = this.originalTarget;
            return ArrayConcat.call(getOwnPropertyNames$1$1(originalTarget), getOwnPropertySymbols(originalTarget));
        };
        ReactiveProxyHandler.prototype.isExtensible = function (shadowTarget) {
            var shadowIsExtensible = isExtensible(shadowTarget);
            if (!shadowIsExtensible) {
                return shadowIsExtensible;
            }
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            var targetIsExtensible = isExtensible(originalTarget);
            if (!targetIsExtensible) {
                lockShadowTarget(membrane, shadowTarget, originalTarget);
            }
            return targetIsExtensible;
        };
        ReactiveProxyHandler.prototype.setPrototypeOf = function (shadowTarget, prototype) {
            if (process.env.NODE_ENV !== 'production') {
                throw new Error("Invalid setPrototypeOf invocation for reactive proxy " + toString$1$1(this.originalTarget) + ". Prototype of reactive objects cannot be changed.");
            }
        };
        ReactiveProxyHandler.prototype.getPrototypeOf = function (shadowTarget) {
            var originalTarget = this.originalTarget;
            return getPrototypeOf$1$1(originalTarget);
        };
        ReactiveProxyHandler.prototype.getOwnPropertyDescriptor = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            var valueObserved = this.membrane.valueObserved; // keys looked up via hasOwnProperty need to be reactive
            valueObserved(originalTarget, key);
            var desc = getOwnPropertyDescriptor$1$1(originalTarget, key);
            if (isUndefined$2(desc)) {
                return desc;
            }
            var shadowDescriptor = getOwnPropertyDescriptor$1$1(shadowTarget, key);
            if (!isUndefined$2(shadowDescriptor)) {
                return shadowDescriptor;
            } // Note: by accessing the descriptor, the key is marked as observed
            // but access to the value, setter or getter (if available) cannot observe
            // mutations, just like regular methods, in which case we just do nothing.
            desc = wrapDescriptor(membrane, desc, wrapValue);
            if (!desc.configurable) {
                // If descriptor from original target is not configurable,
                // We must copy the wrapped descriptor over to the shadow target.
                // Otherwise, proxy will throw an invariant error.
                // This is our last chance to lock the value.
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
                ObjectDefineProperty(shadowTarget, key, desc);
            }
            return desc;
        };
        ReactiveProxyHandler.prototype.preventExtensions = function (shadowTarget) {
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            lockShadowTarget(membrane, shadowTarget, originalTarget);
            preventExtensions(originalTarget);
            return true;
        };
        ReactiveProxyHandler.prototype.defineProperty = function (shadowTarget, key, descriptor) {
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            var valueMutated = membrane.valueMutated;
            var configurable = descriptor.configurable; // We have to check for value in descriptor
            // because Object.freeze(proxy) calls this method
            // with only { configurable: false, writeable: false }
            // Additionally, method will only be called with writeable:false
            // if the descriptor has a value, as opposed to getter/setter
            // So we can just check if writable is present and then see if
            // value is present. This eliminates getter and setter descriptors
            if (hasOwnProperty$1$1.call(descriptor, 'writable') && !hasOwnProperty$1$1.call(descriptor, 'value')) {
                var originalDescriptor = getOwnPropertyDescriptor$1$1(originalTarget, key);
                descriptor.value = originalDescriptor.value;
            }
            ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));
            if (configurable === false) {
                ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));
            }
            valueMutated(originalTarget, key);
            return true;
        };
        return ReactiveProxyHandler;
    }());
    function wrapReadOnlyValue(membrane, value) {
        return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;
    }
    var ReadOnlyHandler = /** @class */ (function () {
        function ReadOnlyHandler(membrane, value) {
            this.originalTarget = value;
            this.membrane = membrane;
        }
        ReadOnlyHandler.prototype.get = function (shadowTarget, key) {
            var _b = this, membrane = _b.membrane, originalTarget = _b.originalTarget;
            var value = originalTarget[key];
            var valueObserved = membrane.valueObserved;
            valueObserved(originalTarget, key);
            return membrane.getReadOnlyProxy(value);
        };
        ReadOnlyHandler.prototype.set = function (shadowTarget, key, value) {
            if (process.env.NODE_ENV !== 'production') {
                var originalTarget = this.originalTarget;
                throw new Error("Invalid mutation: Cannot set \"" + key.toString() + "\" on \"" + originalTarget + "\". \"" + originalTarget + "\" is read-only.");
            }
            return false;
        };
        ReadOnlyHandler.prototype.deleteProperty = function (shadowTarget, key) {
            if (process.env.NODE_ENV !== 'production') {
                var originalTarget = this.originalTarget;
                throw new Error("Invalid mutation: Cannot delete \"" + key.toString() + "\" on \"" + originalTarget + "\". \"" + originalTarget + "\" is read-only.");
            }
            return false;
        };
        ReadOnlyHandler.prototype.apply = function (shadowTarget, thisArg, argArray) {
            /* No op */
        };
        ReadOnlyHandler.prototype.construct = function (target, argArray, newTarget) {
            /* No op */
        };
        ReadOnlyHandler.prototype.has = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, valueObserved = _b.membrane.valueObserved;
            valueObserved(originalTarget, key);
            return key in originalTarget;
        };
        ReadOnlyHandler.prototype.ownKeys = function (shadowTarget) {
            var originalTarget = this.originalTarget;
            return ArrayConcat.call(getOwnPropertyNames$1$1(originalTarget), getOwnPropertySymbols(originalTarget));
        };
        ReadOnlyHandler.prototype.setPrototypeOf = function (shadowTarget, prototype) {
            if (process.env.NODE_ENV !== 'production') {
                var originalTarget = this.originalTarget;
                throw new Error("Invalid prototype mutation: Cannot set prototype on \"" + originalTarget + "\". \"" + originalTarget + "\" prototype is read-only.");
            }
        };
        ReadOnlyHandler.prototype.getOwnPropertyDescriptor = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, membrane = _b.membrane;
            var valueObserved = membrane.valueObserved; // keys looked up via hasOwnProperty need to be reactive
            valueObserved(originalTarget, key);
            var desc = getOwnPropertyDescriptor$1$1(originalTarget, key);
            if (isUndefined$2(desc)) {
                return desc;
            }
            var shadowDescriptor = getOwnPropertyDescriptor$1$1(shadowTarget, key);
            if (!isUndefined$2(shadowDescriptor)) {
                return shadowDescriptor;
            } // Note: by accessing the descriptor, the key is marked as observed
            // but access to the value or getter (if available) cannot be observed,
            // just like regular methods, in which case we just do nothing.
            desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);
            if (hasOwnProperty$1$1.call(desc, 'set')) {
                desc.set = undefined; // readOnly membrane does not allow setters
            }
            if (!desc.configurable) {
                // If descriptor from original target is not configurable,
                // We must copy the wrapped descriptor over to the shadow target.
                // Otherwise, proxy will throw an invariant error.
                // This is our last chance to lock the value.
                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants
                ObjectDefineProperty(shadowTarget, key, desc);
            }
            return desc;
        };
        ReadOnlyHandler.prototype.preventExtensions = function (shadowTarget) {
            if (process.env.NODE_ENV !== 'production') {
                var originalTarget = this.originalTarget;
                throw new Error("Invalid mutation: Cannot preventExtensions on " + originalTarget + "\". \"" + originalTarget + " is read-only.");
            }
            return false;
        };
        ReadOnlyHandler.prototype.defineProperty = function (shadowTarget, key, descriptor) {
            if (process.env.NODE_ENV !== 'production') {
                var originalTarget = this.originalTarget;
                throw new Error("Invalid mutation: Cannot defineProperty \"" + key.toString() + "\" on \"" + originalTarget + "\". \"" + originalTarget + "\" is read-only.");
            }
            return false;
        };
        return ReadOnlyHandler;
    }());
    function extract(objectOrArray) {
        if (isArray$1$1(objectOrArray)) {
            return objectOrArray.map(function (item) {
                var original = unwrap(item);
                if (original !== item) {
                    return extract(original);
                }
                return item;
            });
        }
        var obj = ObjectCreate(getPrototypeOf$1$1(objectOrArray));
        var names = getOwnPropertyNames$1$1(objectOrArray);
        return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce(function (seed, key) {
            var item = objectOrArray[key];
            var original = unwrap(item);
            if (original !== item) {
                seed[key] = extract(original);
            }
            else {
                seed[key] = item;
            }
            return seed;
        }, obj);
    }
    var formatter = {
        header: function (plainOrProxy) {
            var originalTarget = unwrap(plainOrProxy); // if originalTarget is falsy or not unwrappable, exit
            if (!originalTarget || originalTarget === plainOrProxy) {
                return null;
            }
            var obj = extract(plainOrProxy);
            return ['object', {
                    object: obj
                }];
        },
        hasBody: function () {
            return false;
        },
        body: function () {
            return null;
        }
    }; // Inspired from paulmillr/es6-shim
    // https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185
    function getGlobal() {
        // the only reliable means to get the global object is `Function('return this')()`
        // However, this causes CSP violations in Chrome apps.
        if (typeof globalThis !== 'undefined') {
            return globalThis;
        }
        if (typeof self !== 'undefined') {
            return self;
        }
        if (typeof window !== 'undefined') {
            return window;
        }
        if (typeof global !== 'undefined') {
            return global;
        } // Gracefully degrade if not able to locate the global object
        return {};
    }
    function init() {
        if (process.env.NODE_ENV === 'production') {
            // this method should never leak to prod
            throw new ReferenceError();
        }
        var global = getGlobal(); // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools
        //  - Go to Settings,
        //  - Under console, select "Enable custom formatters"
        // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview
        var devtoolsFormatters = global.devtoolsFormatters || [];
        ArrayPush$2.call(devtoolsFormatters, formatter);
        global.devtoolsFormatters = devtoolsFormatters;
    }
    if (process.env.NODE_ENV !== 'production') {
        init();
    }
    function createShadowTarget(value) {
        var shadowTarget = undefined;
        if (isArray$1$1(value)) {
            shadowTarget = [];
        }
        else if (isObject$1$1(value)) {
            shadowTarget = {};
        }
        return shadowTarget;
    }
    var ObjectDotPrototype = Object.prototype;
    function defaultValueIsObservable(value) {
        // intentionally checking for null
        if (value === null) {
            return false;
        } // treat all non-object types, including undefined, as non-observable values
        if (typeof value !== 'object') {
            return false;
        }
        if (isArray$1$1(value)) {
            return true;
        }
        var proto = getPrototypeOf$1$1(value);
        return proto === ObjectDotPrototype || proto === null || getPrototypeOf$1$1(proto) === null;
    }
    var defaultValueObserved = function (obj, key) {
        /* do nothing */
    };
    var defaultValueMutated = function (obj, key) {
        /* do nothing */
    };
    var defaultValueDistortion = function (value) { return value; };
    function wrapDescriptor(membrane, descriptor, getValue) {
        var set = descriptor.set, get = descriptor.get;
        if (hasOwnProperty$1$1.call(descriptor, 'value')) {
            descriptor.value = getValue(membrane, descriptor.value);
        }
        else {
            if (!isUndefined$2(get)) {
                descriptor.get = function () {
                    // invoking the original getter with the original target
                    return getValue(membrane, get.call(unwrap(this)));
                };
            }
            if (!isUndefined$2(set)) {
                descriptor.set = function (value) {
                    // At this point we don't have a clear indication of whether
                    // or not a valid mutation will occur, we don't have the key,
                    // and we are not sure why and how they are invoking this setter.
                    // Nevertheless we preserve the original semantics by invoking the
                    // original setter with the original target and the unwrapped value
                    set.call(unwrap(this), membrane.unwrapProxy(value));
                };
            }
        }
        return descriptor;
    }
    var ReactiveMembrane = /** @class */ (function () {
        function ReactiveMembrane(options) {
            this.valueDistortion = defaultValueDistortion;
            this.valueMutated = defaultValueMutated;
            this.valueObserved = defaultValueObserved;
            this.valueIsObservable = defaultValueIsObservable;
            this.objectGraph = new WeakMap();
            if (!isUndefined$2(options)) {
                var valueDistortion_1 = options.valueDistortion, valueMutated_1 = options.valueMutated, valueObserved_1 = options.valueObserved, valueIsObservable = options.valueIsObservable;
                this.valueDistortion = isFunction$1$1(valueDistortion_1) ? valueDistortion_1 : defaultValueDistortion;
                this.valueMutated = isFunction$1$1(valueMutated_1) ? valueMutated_1 : defaultValueMutated;
                this.valueObserved = isFunction$1$1(valueObserved_1) ? valueObserved_1 : defaultValueObserved;
                this.valueIsObservable = isFunction$1$1(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
            }
        }
        ReactiveMembrane.prototype.getProxy = function (value) {
            var unwrappedValue = unwrap(value);
            var distorted = this.valueDistortion(unwrappedValue);
            if (this.valueIsObservable(distorted)) {
                var o = this.getReactiveState(unwrappedValue, distorted); // when trying to extract the writable version of a readonly
                // we return the readonly.
                return o.readOnly === value ? value : o.reactive;
            }
            return distorted;
        };
        ReactiveMembrane.prototype.getReadOnlyProxy = function (value) {
            value = unwrap(value);
            var distorted = this.valueDistortion(value);
            if (this.valueIsObservable(distorted)) {
                return this.getReactiveState(value, distorted).readOnly;
            }
            return distorted;
        };
        ReactiveMembrane.prototype.unwrapProxy = function (p) {
            return unwrap(p);
        };
        ReactiveMembrane.prototype.getReactiveState = function (value, distortedValue) {
            var objectGraph = this.objectGraph;
            var reactiveState = objectGraph.get(distortedValue);
            if (reactiveState) {
                return reactiveState;
            }
            var membrane = this;
            reactiveState = {
                get reactive() {
                    var reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue); // caching the reactive proxy after the first time it is accessed
                    var proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);
                    registerProxy(proxy, value);
                    ObjectDefineProperty(this, 'reactive', {
                        value: proxy
                    });
                    return proxy;
                },
                get readOnly() {
                    var readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue); // caching the readOnly proxy after the first time it is accessed
                    var proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);
                    registerProxy(proxy, value);
                    ObjectDefineProperty(this, 'readOnly', {
                        value: proxy
                    });
                    return proxy;
                }
            };
            objectGraph.set(distortedValue, reactiveState);
            return reactiveState;
        };
        return ReactiveMembrane;
    }());
    /** version: 0.26.0 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function valueDistortion(value) {
        return value;
    }
    var reactiveMembrane = new ReactiveMembrane({
        valueObserved: valueObserved,
        valueMutated: valueMutated,
        valueDistortion: valueDistortion
    });
    /**
     * EXPERIMENTAL: This function implements an unwrap mechanism that
     * works for observable membrane objects. This API is subject to
     * change or being removed.
     */
    var unwrap$1 = function (value) {
        var unwrapped = reactiveMembrane.unwrapProxy(value);
        if (unwrapped !== value) {
            // if value is a proxy, unwrap to access original value and apply distortion
            return valueDistortion(unwrapped);
        }
        return value;
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function track(target) {
        if (arguments.length === 1) {
            return reactiveMembrane.getProxy(target);
        }
        if (process.env.NODE_ENV !== 'production') {
            assert$1.fail("@track decorator can only be used with one argument to return a trackable object, or as a decorator function.");
        }
        throw new Error();
    }
    function internalTrackDecorator(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                componentValueObserved(vm, key);
                return vm.cmpFields[key];
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                if (process.env.NODE_ENV !== 'production') {
                    var vmBeingRendered_3 = getVMBeingRendered();
                    assert$1.invariant(!isInvokingRender, vmBeingRendered_3 + ".render() method has side effects on the state of " + vm + "." + toString$1(key));
                    assert$1.invariant(!isUpdatingTemplate, "Updating the template of " + vmBeingRendered_3 + " has side effects on the state of " + vm + "." + toString$1(key));
                }
                var reactiveOrAnyValue = reactiveMembrane.getProxy(newValue);
                if (reactiveOrAnyValue !== vm.cmpFields[key]) {
                    vm.cmpFields[key] = reactiveOrAnyValue;
                    componentValueMutated(vm, key);
                }
            },
            enumerable: true,
            configurable: true
        };
    }
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var create$2 = Object.create, keys$1$1 = Object.keys;
    var _j = Array.prototype, forEach$1$1 = _j.forEach;
    var _k = String.prototype, StringReplace$1$1 = _k.replace, StringToLowerCase$1$1 = _k.toLowerCase;
    function isUndefined$3(obj) {
        return obj === undefined;
    }
    function isTrue$1$1$1(obj) {
        return obj === true;
    }
    function isFalse$1$1$1(obj) {
        return obj === false;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
     * ariaGrabbed) are deprecated:
     * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
     *
     * The above list of 46 aria attributes is consistent with the following resources:
     * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
     * https://wicg.github.io/aom/spec/aria-reflection.html
     */
    var AriaPropertyNames$1$1 = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
    var AttrNameToPropNameMap$2 = create$2(null);
    var PropNameToAttrNameMap$2 = create$2(null); // Synthetic creation of all AOM property descriptors for Custom Elements
    forEach$1$1.call(AriaPropertyNames$1$1, function (propName) {
        // Typescript infers the wrong function type for this particular overloaded method:
        // https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        var attrName = StringToLowerCase$1$1.call(StringReplace$1$1.call(propName, /^aria/, 'aria-'));
        AttrNameToPropNameMap$2[attrName] = propName;
        PropNameToAttrNameMap$2[propName] = attrName;
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Inspired from: https://mathiasbynens.be/notes/globalthis
    var _globalThis$1$1 = function () {
        // On recent browsers, `globalThis` is already defined. In this case return it directly.
        if (typeof globalThis === 'object') {
            return globalThis;
        }
        var _globalThis;
        try {
            // eslint-disable-next-line no-extend-native
            Object.defineProperty(Object.prototype, '__magic__', {
                get: function () {
                    return this;
                },
                configurable: true
            }); // __magic__ is undefined in Safari 10 and IE10 and older.
            // @ts-ignore
            // eslint-disable-next-line no-undef
            _globalThis = __magic__; // @ts-ignore
            delete Object.prototype.__magic__;
        }
        catch (ex) { // In IE8, Object.defineProperty only works on DOM objects.
        }
        finally {
            // If the magic above fails for some reason we assume that we are in a legacy browser.
            // Assume `window` exists in this case.
            if (typeof _globalThis === 'undefined') {
                // @ts-ignore
                _globalThis = window;
            }
        }
        return _globalThis;
    }();
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /*
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */
    var hasNativeSymbolsSupport$1$1 = Symbol('x').toString() === 'Symbol(x)';
    var HTML_ATTRIBUTES_TO_PROPERTY$1$1 = {
        accesskey: 'accessKey',
        readonly: 'readOnly',
        tabindex: 'tabIndex',
        bgcolor: 'bgColor',
        colspan: 'colSpan',
        rowspan: 'rowSpan',
        contenteditable: 'contentEditable',
        crossorigin: 'crossOrigin',
        datetime: 'dateTime',
        formaction: 'formAction',
        ismap: 'isMap',
        maxlength: 'maxLength',
        minlength: 'minLength',
        novalidate: 'noValidate',
        usemap: 'useMap',
        for: 'htmlFor'
    };
    keys$1$1(HTML_ATTRIBUTES_TO_PROPERTY$1$1).forEach(function (attrName) { });
    /** version: 1.7.7 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (!_globalThis$1$1.lwcRuntimeFlags) {
        Object.defineProperty(_globalThis$1$1, 'lwcRuntimeFlags', {
            value: create$2(null)
        });
    }
    var runtimeFlags = _globalThis$1$1.lwcRuntimeFlags; // This function is not supported for use within components and is meant for
    // configuring runtime feature flags during app initialization.
    function setFeatureFlag(name, value) {
        var isBoolean = isTrue$1$1$1(value) || isFalse$1$1$1(value);
        if (!isBoolean) {
            var message = "Failed to set the value \"" + value + "\" for the runtime feature flag \"" + name + "\". Runtime feature flags can only be set to a boolean value.";
            if (process.env.NODE_ENV !== 'production') {
                throw new TypeError(message);
            }
            else {
                // eslint-disable-next-line no-console
                console.error(message);
                return;
            }
        }
        if (isUndefined$3(featureFlagLookup[name])) {
            // eslint-disable-next-line no-console
            console.warn("Failed to set the value \"" + value + "\" for the runtime feature flag \"" + name + "\" because it is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.");
            return;
        }
        if (process.env.NODE_ENV !== 'production') {
            // Allow the same flag to be set more than once outside of production to enable testing
            runtimeFlags[name] = value;
        }
        else {
            // Disallow the same flag to be set more than once in production
            var runtimeValue = runtimeFlags[name];
            if (!isUndefined$3(runtimeValue)) {
                // eslint-disable-next-line no-console
                console.error("Failed to set the value \"" + value + "\" for the runtime feature flag \"" + name + "\". \"" + name + "\" has already been set with the value \"" + runtimeValue + "\".");
                return;
            }
            Object.defineProperty(runtimeFlags, name, {
                value: value
            });
        }
    } // This function is exposed to components to facilitate testing so we add a
    // check to make sure it is not invoked in production.
    function setFeatureFlagForTest(name, value) {
        if (process.env.NODE_ENV !== 'production') {
            return setFeatureFlag(name, value);
        }
    }
    var featureFlagLookup = {
        ENABLE_REACTIVE_SETTER: null,
        // Flags to toggle on/off the enforcement of shadow dom semantic in element/node outside lwc boundary when using synthetic shadow.
        ENABLE_ELEMENT_PATCH: null,
        ENABLE_NODE_LIST_PATCH: null,
        ENABLE_HTML_COLLECTIONS_PATCH: null,
        ENABLE_NODE_PATCH: null
    };
    /** version: 1.7.7 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function api() {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.fail("@api decorator can only be used as a decorator function.");
        }
        throw new Error();
    }
    function createPublicPropertyDescriptor(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                if (isBeingConstructed(vm)) {
                    if (process.env.NODE_ENV !== 'production') {
                        logError("Can\u2019t read the value of property `" + toString$1(key) + "` from the constructor because the owner component hasn\u2019t set the value yet. Instead, use the constructor to set a default value for the property.", vm);
                    }
                    return;
                }
                componentValueObserved(vm, key);
                return vm.cmpProps[key];
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                if (process.env.NODE_ENV !== 'production') {
                    var vmBeingRendered_4 = getVMBeingRendered();
                    assert$1.invariant(!isInvokingRender, vmBeingRendered_4 + ".render() method has side effects on the state of " + vm + "." + toString$1(key));
                    assert$1.invariant(!isUpdatingTemplate, "Updating the template of " + vmBeingRendered_4 + " has side effects on the state of " + vm + "." + toString$1(key));
                }
                vm.cmpProps[key] = newValue;
                componentValueMutated(vm, key);
            },
            enumerable: true,
            configurable: true
        };
    }
    var AccessorReactiveObserver = /** @class */ (function (_super) {
        __extends(AccessorReactiveObserver, _super);
        function AccessorReactiveObserver(vm, set) {
            var _this = _super.call(this, function () {
                if (isFalse$1$1(_this.debouncing)) {
                    _this.debouncing = true;
                    addCallbackToNextTick(function () {
                        if (isTrue$1$1(_this.debouncing)) {
                            var value = _this.value;
                            var dirtyStateBeforeSetterCall = vm.isDirty, component = vm.component, idx_1 = vm.idx;
                            set.call(component, value); // de-bouncing after the call to the original setter to prevent
                            // infinity loop if the setter itself is mutating things that
                            // were accessed during the previous invocation.
                            _this.debouncing = false;
                            if (isTrue$1$1(vm.isDirty) && isFalse$1$1(dirtyStateBeforeSetterCall) && idx_1 > 0) {
                                // immediate rehydration due to a setter driven mutation, otherwise
                                // the component will get rendered on the second tick, which it is not
                                // desirable.
                                rerenderVM(vm);
                            }
                        }
                    });
                }
            }) || this;
            _this.debouncing = false;
            return _this;
        }
        AccessorReactiveObserver.prototype.reset = function (value) {
            _super.prototype.reset.call(this);
            this.debouncing = false;
            if (arguments.length > 0) {
                this.value = value;
            }
        };
        return AccessorReactiveObserver;
    }(ReactiveObserver));
    function createPublicAccessorDescriptor(key, descriptor) {
        var get = descriptor.get, set = descriptor.set, enumerable = descriptor.enumerable, configurable = descriptor.configurable;
        if (!isFunction$1(get)) {
            if (process.env.NODE_ENV !== 'production') {
                assert$1.invariant(isFunction$1(get), "Invalid compiler output for public accessor " + toString$1(key) + " decorated with @api");
            }
            throw new Error();
        }
        return {
            get: function () {
                if (process.env.NODE_ENV !== 'production') {
                    // Assert that the this value is an actual Component with an associated VM.
                    getAssociatedVM(this);
                }
                return get.call(this);
            },
            set: function (newValue) {
                var _this = this;
                var vm = getAssociatedVM(this);
                if (process.env.NODE_ENV !== 'production') {
                    var vmBeingRendered_5 = getVMBeingRendered();
                    assert$1.invariant(!isInvokingRender, vmBeingRendered_5 + ".render() method has side effects on the state of " + vm + "." + toString$1(key));
                    assert$1.invariant(!isUpdatingTemplate, "Updating the template of " + vmBeingRendered_5 + " has side effects on the state of " + vm + "." + toString$1(key));
                }
                if (set) {
                    if (runtimeFlags.ENABLE_REACTIVE_SETTER) {
                        var ro = vm.oar[key];
                        if (isUndefined$1(ro)) {
                            ro = vm.oar[key] = new AccessorReactiveObserver(vm, set);
                        } // every time we invoke this setter from outside (through this wrapper setter)
                        // we should reset the value and then debounce just in case there is a pending
                        // invocation the next tick that is not longer relevant since the value is changing
                        // from outside.
                        ro.reset(newValue);
                        ro.observe(function () {
                            set.call(_this, newValue);
                        });
                    }
                    else {
                        set.call(this, newValue);
                    }
                }
                else if (process.env.NODE_ENV !== 'production') {
                    assert$1.fail("Invalid attempt to set a new value for property " + toString$1(key) + " of " + vm + " that does not has a setter decorated with @api.");
                }
            },
            enumerable: enumerable,
            configurable: configurable
        };
    }
    function createObservedFieldPropertyDescriptor(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                componentValueObserved(vm, key);
                return vm.cmpFields[key];
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                if (newValue !== vm.cmpFields[key]) {
                    vm.cmpFields[key] = newValue;
                    componentValueMutated(vm, key);
                }
            },
            enumerable: true,
            configurable: true
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var PropType;
    (function (PropType) {
        PropType[PropType["Field"] = 0] = "Field";
        PropType[PropType["Set"] = 1] = "Set";
        PropType[PropType["Get"] = 2] = "Get";
        PropType[PropType["GetSet"] = 3] = "GetSet";
    })(PropType || (PropType = {}));
    function validateObservedField(Ctor, fieldName, descriptor) {
        if (process.env.NODE_ENV !== 'production') {
            if (!isUndefined$1(descriptor)) {
                assert$1.fail("Compiler Error: Invalid field " + fieldName + " declaration.");
            }
        }
    }
    function validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor) {
        if (process.env.NODE_ENV !== 'production') {
            if (!isUndefined$1(descriptor)) {
                assert$1.fail("Compiler Error: Invalid @track " + fieldName + " declaration.");
            }
        }
    }
    function validateFieldDecoratedWithWire(Ctor, fieldName, descriptor) {
        if (process.env.NODE_ENV !== 'production') {
            if (!isUndefined$1(descriptor)) {
                assert$1.fail("Compiler Error: Invalid @wire(...) " + fieldName + " field declaration.");
            }
        }
    }
    function validateMethodDecoratedWithWire(Ctor, methodName, descriptor) {
        if (process.env.NODE_ENV !== 'production') {
            if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse$1$1(descriptor.writable)) {
                assert$1.fail("Compiler Error: Invalid @wire(...) " + methodName + " method declaration.");
            }
        }
    }
    function validateFieldDecoratedWithApi(Ctor, fieldName, descriptor) {
        if (process.env.NODE_ENV !== 'production') {
            if (!isUndefined$1(descriptor)) {
                assert$1.fail("Compiler Error: Invalid @api " + fieldName + " field declaration.");
            }
        }
    }
    function validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor) {
        if (process.env.NODE_ENV !== 'production') {
            if (isUndefined$1(descriptor)) {
                assert$1.fail("Compiler Error: Invalid @api get " + fieldName + " accessor declaration.");
            }
            else if (isFunction$1(descriptor.set)) {
                assert$1.isTrue(isFunction$1(descriptor.get), "Compiler Error: Missing getter for property " + toString$1(fieldName) + " decorated with @api in " + Ctor + ". You cannot have a setter without the corresponding getter.");
            }
            else if (!isFunction$1(descriptor.get)) {
                assert$1.fail("Compiler Error: Missing @api get " + fieldName + " accessor declaration.");
            }
        }
    }
    function validateMethodDecoratedWithApi(Ctor, methodName, descriptor) {
        if (process.env.NODE_ENV !== 'production') {
            if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse$1$1(descriptor.writable)) {
                assert$1.fail("Compiler Error: Invalid @api " + methodName + " method declaration.");
            }
        }
    }
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by user-land code.
     */
    function registerDecorators(Ctor, meta) {
        var proto = Ctor.prototype;
        var publicProps = meta.publicProps, publicMethods = meta.publicMethods, wire = meta.wire, track = meta.track, fields = meta.fields;
        var apiMethods = create$1(null);
        var apiFields = create$1(null);
        var wiredMethods = create$1(null);
        var wiredFields = create$1(null);
        var observedFields = create$1(null);
        var apiFieldsConfig = create$1(null);
        var descriptor;
        if (!isUndefined$1(publicProps)) {
            for (var fieldName in publicProps) {
                var propConfig = publicProps[fieldName];
                apiFieldsConfig[fieldName] = propConfig.config;
                descriptor = getOwnPropertyDescriptor$1(proto, fieldName);
                if (propConfig.config > 0) {
                    // accessor declaration
                    if (process.env.NODE_ENV !== 'production') {
                        validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor);
                    }
                    if (isUndefined$1(descriptor)) {
                        throw new Error();
                    }
                    descriptor = createPublicAccessorDescriptor(fieldName, descriptor);
                }
                else {
                    // field declaration
                    if (process.env.NODE_ENV !== 'production') {
                        validateFieldDecoratedWithApi(Ctor, fieldName, descriptor);
                    }
                    descriptor = createPublicPropertyDescriptor(fieldName);
                }
                apiFields[fieldName] = descriptor;
                defineProperty$1(proto, fieldName, descriptor);
            }
        }
        if (!isUndefined$1(publicMethods)) {
            forEach$1.call(publicMethods, function (methodName) {
                descriptor = getOwnPropertyDescriptor$1(proto, methodName);
                if (process.env.NODE_ENV !== 'production') {
                    validateMethodDecoratedWithApi(Ctor, methodName, descriptor);
                }
                if (isUndefined$1(descriptor)) {
                    throw new Error();
                }
                apiMethods[methodName] = descriptor;
            });
        }
        if (!isUndefined$1(wire)) {
            for (var fieldOrMethodName in wire) {
                var _b = wire[fieldOrMethodName], adapter = _b.adapter, method = _b.method, configCallback = _b.config, _c = _b.dynamic, dynamic = _c === void 0 ? [] : _c;
                descriptor = getOwnPropertyDescriptor$1(proto, fieldOrMethodName);
                if (method === 1) {
                    if (process.env.NODE_ENV !== 'production') {
                        assert$1.isTrue(adapter, "@wire on method \"" + fieldOrMethodName + "\": adapter id must be truthy.");
                        validateMethodDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);
                    }
                    if (isUndefined$1(descriptor)) {
                        throw new Error();
                    }
                    wiredMethods[fieldOrMethodName] = descriptor;
                    storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic);
                }
                else {
                    if (process.env.NODE_ENV !== 'production') {
                        assert$1.isTrue(adapter, "@wire on field \"" + fieldOrMethodName + "\": adapter id must be truthy.");
                        validateFieldDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);
                    }
                    descriptor = internalWireFieldDecorator(fieldOrMethodName);
                    wiredFields[fieldOrMethodName] = descriptor;
                    storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic);
                    defineProperty$1(proto, fieldOrMethodName, descriptor);
                }
            }
        }
        if (!isUndefined$1(track)) {
            for (var fieldName in track) {
                descriptor = getOwnPropertyDescriptor$1(proto, fieldName);
                if (process.env.NODE_ENV !== 'production') {
                    validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor);
                }
                descriptor = internalTrackDecorator(fieldName);
                defineProperty$1(proto, fieldName, descriptor);
            }
        }
        if (!isUndefined$1(fields)) {
            for (var i_6 = 0, n = fields.length; i_6 < n; i_6++) {
                var fieldName = fields[i_6];
                descriptor = getOwnPropertyDescriptor$1(proto, fieldName);
                if (process.env.NODE_ENV !== 'production') {
                    validateObservedField(Ctor, fieldName, descriptor);
                }
                observedFields[fieldName] = createObservedFieldPropertyDescriptor(fieldName);
            }
        }
        setDecoratorsMeta(Ctor, {
            apiMethods: apiMethods,
            apiFields: apiFields,
            apiFieldsConfig: apiFieldsConfig,
            wiredMethods: wiredMethods,
            wiredFields: wiredFields,
            observedFields: observedFields
        });
        return Ctor;
    }
    var signedDecoratorToMetaMap = new Map();
    function setDecoratorsMeta(Ctor, meta) {
        signedDecoratorToMetaMap.set(Ctor, meta);
    }
    var defaultMeta = {
        apiMethods: EmptyObject,
        apiFields: EmptyObject,
        apiFieldsConfig: EmptyObject,
        wiredMethods: EmptyObject,
        wiredFields: EmptyObject,
        observedFields: EmptyObject
    };
    function getDecoratorsMeta(Ctor) {
        var meta = signedDecoratorToMetaMap.get(Ctor);
        return isUndefined$1(meta) ? defaultMeta : meta;
    }
    var signedTemplateSet = new Set();
    function defaultEmptyTemplate() {
        return [];
    }
    signedTemplateSet.add(defaultEmptyTemplate);
    function isTemplateRegistered(tpl) {
        return signedTemplateSet.has(tpl);
    }
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerTemplate(tpl) {
        signedTemplateSet.add(tpl); // chaining this method as a way to wrap existing
        // assignment of templates easily, without too much transformation
        return tpl;
    }
    /**
     * EXPERIMENTAL: This function acts like a hook for Lightning Locker
     * Service and other similar libraries to sanitize vulnerable attributes.
     * This API is subject to change or being removed.
     */
    function sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {
        // locker-service patches this function during runtime to sanitize vulnerable attributes.
        // when ran off-core this function becomes a noop and returns the user authored value.
        return attrValue;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // from the element instance, and get the value or set a new value on the component.
    // This means that across different elements, similar names can get the exact same
    // descriptor, so we can cache them:
    var cachedGetterByKey = create$1(null);
    var cachedSetterByKey = create$1(null);
    function createGetter(key) {
        var fn = cachedGetterByKey[key];
        if (isUndefined$1(fn)) {
            fn = cachedGetterByKey[key] = function () {
                var vm = getAssociatedVM(this);
                var getHook = vm.getHook;
                return getHook(vm.component, key);
            };
        }
        return fn;
    }
    function createSetter(key) {
        var fn = cachedSetterByKey[key];
        if (isUndefined$1(fn)) {
            fn = cachedSetterByKey[key] = function (newValue) {
                var vm = getAssociatedVM(this);
                var setHook = vm.setHook;
                newValue = reactiveMembrane.getReadOnlyProxy(newValue);
                setHook(vm.component, key, newValue);
            };
        }
        return fn;
    }
    function createMethodCaller(methodName) {
        return function () {
            var vm = getAssociatedVM(this);
            var callHook = vm.callHook, component = vm.component;
            var fn = component[methodName];
            return callHook(vm.component, fn, ArraySlice$2.call(arguments));
        };
    }
    function HTMLBridgeElementFactory(SuperClass, props, methods) {
        var HTMLBridgeElement;
        /**
         * Modern browsers will have all Native Constructors as regular Classes
         * and must be instantiated with the new keyword. In older browsers,
         * specifically IE11, those are objects with a prototype property defined,
         * since they are not supposed to be extended or instantiated with the
         * new keyword. This forking logic supports both cases, specifically because
         * wc.ts relies on the construction path of the bridges to create new
         * fully qualifying web components.
         */
        if (isFunction$1(SuperClass)) {
            HTMLBridgeElement = /** @class */ (function (_super) {
                __extends(HTMLBridgeElement, _super);
                function HTMLBridgeElement() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return HTMLBridgeElement;
            }(SuperClass));
        }
        else {
            HTMLBridgeElement = function () {
                // Bridge classes are not supposed to be instantiated directly in
                // browsers that do not support web components.
                throw new TypeError('Illegal constructor');
            }; // prototype inheritance dance
            setPrototypeOf$1(HTMLBridgeElement, SuperClass);
            setPrototypeOf$1(HTMLBridgeElement.prototype, SuperClass.prototype);
            defineProperty$1(HTMLBridgeElement.prototype, 'constructor', {
                writable: true,
                configurable: true,
                value: HTMLBridgeElement
            });
        }
        var descriptors = create$1(null); // expose getters and setters for each public props on the new Element Bridge
        for (var i_7 = 0, len = props.length; i_7 < len; i_7 += 1) {
            var propName = props[i_7];
            descriptors[propName] = {
                get: createGetter(propName),
                set: createSetter(propName),
                enumerable: true,
                configurable: true
            };
        } // expose public methods as props on the new Element Bridge
        for (var i_8 = 0, len = methods.length; i_8 < len; i_8 += 1) {
            var methodName = methods[i_8];
            descriptors[methodName] = {
                value: createMethodCaller(methodName),
                writable: true,
                configurable: true
            };
        }
        defineProperties$1(HTMLBridgeElement.prototype, descriptors);
        return HTMLBridgeElement;
    }
    var BaseBridgeElement = HTMLBridgeElementFactory(HTMLElementConstructor, getOwnPropertyNames$1(HTMLElementOriginalDescriptors), []);
    freeze$1(BaseBridgeElement);
    seal$1(BaseBridgeElement.prototype);
    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function resolveCircularModuleDependency(fn) {
        return fn();
    }
    function isCircularModuleDependency(obj) {
        return isFunction$1(obj) && hasOwnProperty$1.call(obj, '__circular__');
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var CtorToDefMap = new WeakMap();
    function getCtorProto(Ctor) {
        var proto = getPrototypeOf$1(Ctor);
        if (isNull$1(proto)) {
            throw new ReferenceError("Invalid prototype chain for " + Ctor.name + ", you must extend LightningElement.");
        } // covering the cases where the ref is circular in AMD
        if (isCircularModuleDependency(proto)) {
            var p = resolveCircularModuleDependency(proto);
            if (process.env.NODE_ENV !== 'production') {
                if (isNull$1(p)) {
                    throw new ReferenceError("Circular module dependency for " + Ctor.name + ", must resolve to a constructor that extends LightningElement.");
                }
            } // escape hatch for Locker and other abstractions to provide their own base class instead
            // of our Base class without having to leak it to user-land. If the circular function returns
            // itself, that's the signal that we have hit the end of the proto chain, which must always
            // be base.
            proto = p === proto ? BaseLightningElement : p;
        }
        return proto;
    }
    function createComponentDef(Ctor) {
        if (process.env.NODE_ENV !== 'production') {
            var ctorName = Ctor.name; // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.
            // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a "name" property with string value, but found ${ctorName}.`);
            assert$1.isTrue(Ctor.constructor, "Missing " + ctorName + ".constructor, " + ctorName + " should have a \"constructor\" property.");
        }
        var decoratorsMeta = getDecoratorsMeta(Ctor);
        var apiFields = decoratorsMeta.apiFields, apiFieldsConfig = decoratorsMeta.apiFieldsConfig, apiMethods = decoratorsMeta.apiMethods, wiredFields = decoratorsMeta.wiredFields, wiredMethods = decoratorsMeta.wiredMethods, observedFields = decoratorsMeta.observedFields;
        var proto = Ctor.prototype;
        var connectedCallback = proto.connectedCallback, disconnectedCallback = proto.disconnectedCallback, renderedCallback = proto.renderedCallback, errorCallback = proto.errorCallback, render = proto.render;
        var superProto = getCtorProto(Ctor);
        var superDef = superProto !== BaseLightningElement ? getComponentInternalDef(superProto) : lightingElementDef;
        var bridge = HTMLBridgeElementFactory(superDef.bridge, keys$1(apiFields), keys$1(apiMethods));
        var props = assign$1(create$1(null), superDef.props, apiFields);
        var propsConfig = assign$1(create$1(null), superDef.propsConfig, apiFieldsConfig);
        var methods = assign$1(create$1(null), superDef.methods, apiMethods);
        var wire = assign$1(create$1(null), superDef.wire, wiredFields, wiredMethods);
        connectedCallback = connectedCallback || superDef.connectedCallback;
        disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;
        renderedCallback = renderedCallback || superDef.renderedCallback;
        errorCallback = errorCallback || superDef.errorCallback;
        render = render || superDef.render;
        var template = getComponentRegisteredTemplate(Ctor) || superDef.template;
        var name = Ctor.name || superDef.name; // installing observed fields into the prototype.
        defineProperties$1(proto, observedFields);
        var def = {
            ctor: Ctor,
            name: name,
            wire: wire,
            props: props,
            propsConfig: propsConfig,
            methods: methods,
            bridge: bridge,
            template: template,
            connectedCallback: connectedCallback,
            disconnectedCallback: disconnectedCallback,
            renderedCallback: renderedCallback,
            errorCallback: errorCallback,
            render: render
        };
        if (process.env.NODE_ENV !== 'production') {
            freeze$1(Ctor.prototype);
        }
        return def;
    }
    /**
     * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is
     * subject to change or being removed.
     */
    function isComponentConstructor(ctor) {
        if (!isFunction$1(ctor)) {
            return false;
        } // Fast path: LightningElement is part of the prototype chain of the constructor.
        if (ctor.prototype instanceof BaseLightningElement) {
            return true;
        } // Slow path: LightningElement is not part of the prototype chain of the constructor, we need
        // climb up the constructor prototype chain to check in case there are circular dependencies
        // to resolve.
        var current = ctor;
        do {
            if (isCircularModuleDependency(current)) {
                var circularResolved = resolveCircularModuleDependency(current); // If the circular function returns itself, that's the signal that we have hit the end
                // of the proto chain, which must always be a valid base constructor.
                if (circularResolved === current) {
                    return true;
                }
                current = circularResolved;
            }
            if (current === BaseLightningElement) {
                return true;
            }
        } while (!isNull$1(current) && (current = getPrototypeOf$1(current))); // Finally return false if the LightningElement is not part of the prototype chain.
        return false;
    }
    function getComponentInternalDef(Ctor) {
        var def = CtorToDefMap.get(Ctor);
        if (isUndefined$1(def)) {
            if (isCircularModuleDependency(Ctor)) {
                var resolvedCtor = resolveCircularModuleDependency(Ctor);
                def = getComponentInternalDef(resolvedCtor); // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,
                // look up the definition in cache instead of re-resolving and recreating the def.
                CtorToDefMap.set(Ctor, def);
                return def;
            }
            if (!isComponentConstructor(Ctor)) {
                throw new TypeError(Ctor + " is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.");
            }
            def = createComponentDef(Ctor);
            CtorToDefMap.set(Ctor, def);
        }
        return def;
    }
    /** Set prototype for public methods and properties on the element. No DOM Patching occurs here. */
    function setElementProto(elm, def) {
        setPrototypeOf$1(elm, def.bridge.prototype);
    }
    var lightingElementDef = {
        ctor: BaseLightningElement,
        name: BaseLightningElement.name,
        props: lightningBasedDescriptors,
        propsConfig: EmptyObject,
        methods: EmptyObject,
        wire: EmptyObject,
        bridge: BaseBridgeElement,
        template: defaultEmptyTemplate,
        render: BaseLightningElement.prototype.render
    };
    var PropDefType;
    (function (PropDefType) {
        PropDefType["any"] = "any";
    })(PropDefType || (PropDefType = {}));
    /**
     * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is
     * subject to change or being removed.
     */
    function getComponentDef(Ctor) {
        var def = getComponentInternalDef(Ctor); // From the internal def object, we need to extract the info that is useful
        // for some external services, e.g.: Locker Service, usually, all they care
        // is about the shape of the constructor, the internals of it are not relevant
        // because they don't have a way to mess with that.
        var ctor = def.ctor, name = def.name, props = def.props, propsConfig = def.propsConfig, methods = def.methods;
        var publicProps = {};
        for (var key in props) {
            // avoid leaking the reference to the public props descriptors
            publicProps[key] = {
                config: propsConfig[key] || 0,
                type: PropDefType.any,
                attr: getAttrNameFromPropName(key)
            };
        }
        var publicMethods = {};
        for (var key in methods) {
            // avoid leaking the reference to the public method descriptors
            publicMethods[key] = methods[key].value;
        }
        return {
            ctor: ctor,
            name: name,
            props: publicProps,
            methods: publicMethods
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var noop = function () { return void 0; };
    function observeElementChildNodes(elm) {
        elm.$domManual$ = true;
    }
    function setElementShadowToken(elm, token) {
        elm.$shadowToken$ = token;
    }
    function updateNodeHook(oldVnode, vnode) {
        var elm = vnode.elm, text = vnode.text, renderer = vnode.owner.renderer;
        if (oldVnode.text !== text) {
            if (process.env.NODE_ENV !== 'production') {
                unlockDomMutation();
            }
            renderer.setText(elm, text);
            if (process.env.NODE_ENV !== 'production') {
                lockDomMutation();
            }
        }
    }
    function insertNodeHook(vnode, parentNode, referenceNode) {
        var renderer = vnode.owner.renderer;
        if (process.env.NODE_ENV !== 'production') {
            unlockDomMutation();
        }
        renderer.insert(vnode.elm, parentNode, referenceNode);
        if (process.env.NODE_ENV !== 'production') {
            lockDomMutation();
        }
    }
    function removeNodeHook(vnode, parentNode) {
        var renderer = vnode.owner.renderer;
        if (process.env.NODE_ENV !== 'production') {
            unlockDomMutation();
        }
        renderer.remove(vnode.elm, parentNode);
        if (process.env.NODE_ENV !== 'production') {
            lockDomMutation();
        }
    }
    function createElmHook(vnode) {
        modEvents.create(vnode); // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.create(vnode);
        modProps.create(vnode);
        modStaticClassName.create(vnode);
        modStaticStyle.create(vnode);
        modComputedClassName.create(vnode);
        modComputedStyle.create(vnode);
    }
    var LWCDOMMode;
    (function (LWCDOMMode) {
        LWCDOMMode["manual"] = "manual";
    })(LWCDOMMode || (LWCDOMMode = {}));
    function fallbackElmHook(elm, vnode) {
        var owner = vnode.owner;
        if (isTrue$1$1(owner.renderer.syntheticShadow)) {
            var context = vnode.data.context;
            var shadowAttribute = owner.context.shadowAttribute;
            if (!isUndefined$1(context) && !isUndefined$1(context.lwc) && context.lwc.dom === LWCDOMMode.manual) {
                // this element will now accept any manual content inserted into it
                observeElementChildNodes(elm);
            } // when running in synthetic shadow mode, we need to set the shadowToken value
            // into each element from the template, so they can be styled accordingly.
            setElementShadowToken(elm, shadowAttribute);
        }
        if (process.env.NODE_ENV !== 'production') {
            var context = vnode.data.context;
            var isPortal = !isUndefined$1(context) && !isUndefined$1(context.lwc) && context.lwc.dom === LWCDOMMode.manual;
            patchElementWithRestrictions(elm, {
                isPortal: isPortal
            });
        }
    }
    function updateElmHook(oldVnode, vnode) {
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.update(oldVnode, vnode);
        modProps.update(oldVnode, vnode);
        modComputedClassName.update(oldVnode, vnode);
        modComputedStyle.update(oldVnode, vnode);
    }
    function insertCustomElmHook(vnode) {
        var vm = getAssociatedVM(vnode.elm);
        appendVM(vm);
    }
    function updateChildrenHook(oldVnode, vnode) {
        var children = vnode.children, owner = vnode.owner;
        var fn = hasDynamicChildren(children) ? updateDynamicChildren : updateStaticChildren;
        runWithBoundaryProtection(owner, owner.owner, noop, function () {
            fn(vnode.elm, oldVnode.children, children);
        }, noop);
    }
    function allocateChildrenHook(vnode) {
        var vm = getAssociatedVM(vnode.elm); // A component with slots will re-render because:
        // 1- There is a change of the internal state.
        // 2- There is a change on the external api (ex: slots)
        //
        // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the
        // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children
        // in a reused VCustomElement, there won't be any slotted children.
        // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.
        //
        // In case #2, we will always get a fresh VCustomElement.
        var children = vnode.aChildren || vnode.children;
        vm.aChildren = children;
        if (isTrue$1$1(vm.renderer.syntheticShadow)) {
            // slow path
            allocateInSlot(vm, children); // save the allocated children in case this vnode is reused.
            vnode.aChildren = children; // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!
            vnode.children = EmptyArray;
        }
    }
    function createViewModelHook(elm, vnode) {
        if (!isUndefined$1(getAssociatedVMIfPresent(elm))) {
            // There is a possibility that a custom element is registered under tagName,
            // in which case, the initialization is already carry on, and there is nothing else
            // to do here since this hook is called right after invoking `document.createElement`.
            return;
        }
        var sel = vnode.sel, mode = vnode.mode, ctor = vnode.ctor, owner = vnode.owner;
        var def = getComponentInternalDef(ctor);
        setElementProto(elm, def);
        if (isTrue$1$1(owner.renderer.syntheticShadow)) {
            var shadowAttribute = owner.context.shadowAttribute; // when running in synthetic shadow mode, we need to set the shadowToken value
            // into each element from the template, so they can be styled accordingly.
            setElementShadowToken(elm, shadowAttribute);
        }
        createVM(elm, def, {
            mode: mode,
            owner: owner,
            tagName: sel,
            renderer: owner.renderer
        });
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isArray$2(vnode.children), "Invalid vnode for a custom element, it must have children defined.");
        }
    }
    function createCustomElmHook(vnode) {
        modEvents.create(vnode); // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.create(vnode);
        modProps.create(vnode);
        modStaticClassName.create(vnode);
        modStaticStyle.create(vnode);
        modComputedClassName.create(vnode);
        modComputedStyle.create(vnode);
    }
    function createChildrenHook(vnode) {
        var elm = vnode.elm, children = vnode.children;
        for (var j = 0; j < children.length; ++j) {
            var ch = children[j];
            if (ch != null) {
                ch.hook.create(ch);
                ch.hook.insert(ch, elm, null);
            }
        }
    }
    function rerenderCustomElmHook(vnode) {
        var vm = getAssociatedVM(vnode.elm);
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isArray$2(vnode.children), "Invalid vnode for a custom element, it must have children defined.");
        }
        rerenderVM(vm);
    }
    function updateCustomElmHook(oldVnode, vnode) {
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.update(oldVnode, vnode);
        modProps.update(oldVnode, vnode);
        modComputedClassName.update(oldVnode, vnode);
        modComputedStyle.update(oldVnode, vnode);
    }
    function removeElmHook(vnode) {
        // this method only needs to search on child vnodes from template
        // to trigger the remove hook just in case some of those children
        // are custom elements.
        var children = vnode.children, elm = vnode.elm;
        for (var j = 0, len = children.length; j < len; ++j) {
            var ch = children[j];
            if (!isNull$1(ch)) {
                ch.hook.remove(ch, elm);
            }
        }
    }
    function removeCustomElmHook(vnode) {
        // for custom elements we don't have to go recursively because the removeVM routine
        // will take care of disconnecting any child VM attached to its shadow as well.
        removeVM(getAssociatedVM(vnode.elm));
    } // Using a WeakMap instead of a WeakSet because this one works in IE11 :(
    var FromIteration = new WeakMap(); // dynamic children means it was generated by an iteration
    // in a template, and will require a more complex diffing algo.
    function markAsDynamicChildren(children) {
        FromIteration.set(children, 1);
    }
    function hasDynamicChildren(children) {
        return FromIteration.has(children);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var CHAR_S = 115;
    var CHAR_V = 118;
    var CHAR_G = 103;
    var NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';
    var SymbolIterator = Symbol.iterator;
    var TextHook = {
        create: function (vnode) {
            var renderer = vnode.owner.renderer;
            var elm = renderer.createText(vnode.text);
            linkNodeToShadow(elm, vnode);
            vnode.elm = elm;
        },
        update: updateNodeHook,
        insert: insertNodeHook,
        move: insertNodeHook,
        remove: removeNodeHook
    }; // insert is called after update, which is used somewhere else (via a module)
    // to mark the vm as inserted, that means we cannot use update as the main channel
    // to rehydrate when dirty, because sometimes the element is not inserted just yet,
    // which breaks some invariants. For that reason, we have the following for any
    // Custom Element that is inserted via a template.
    var ElementHook = {
        create: function (vnode) {
            var sel = vnode.sel, ns = vnode.data.ns, renderer = vnode.owner.renderer;
            var elm = renderer.createElement(sel, ns);
            linkNodeToShadow(elm, vnode);
            fallbackElmHook(elm, vnode);
            vnode.elm = elm;
            createElmHook(vnode);
        },
        update: function (oldVnode, vnode) {
            updateElmHook(oldVnode, vnode);
            updateChildrenHook(oldVnode, vnode);
        },
        insert: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
            createChildrenHook(vnode);
        },
        move: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
        },
        remove: function (vnode, parentNode) {
            removeNodeHook(vnode, parentNode);
            removeElmHook(vnode);
        }
    };
    var CustomElementHook = {
        create: function (vnode) {
            var sel = vnode.sel, renderer = vnode.owner.renderer;
            var elm = renderer.createElement(sel);
            linkNodeToShadow(elm, vnode);
            createViewModelHook(elm, vnode);
            vnode.elm = elm;
            allocateChildrenHook(vnode);
            createCustomElmHook(vnode);
        },
        update: function (oldVnode, vnode) {
            updateCustomElmHook(oldVnode, vnode); // in fallback mode, the allocation will always set children to
            // empty and delegate the real allocation to the slot elements
            allocateChildrenHook(vnode); // in fallback mode, the children will be always empty, so, nothing
            // will happen, but in native, it does allocate the light dom
            updateChildrenHook(oldVnode, vnode); // this will update the shadowRoot
            rerenderCustomElmHook(vnode);
        },
        insert: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
            var vm = getAssociatedVM(vnode.elm);
            if (process.env.NODE_ENV !== 'production') {
                assert$1.isTrue(vm.state === VMState.created, vm + " cannot be recycled.");
            }
            runConnectedCallback(vm);
            createChildrenHook(vnode);
            insertCustomElmHook(vnode);
        },
        move: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
        },
        remove: function (vnode, parentNode) {
            removeNodeHook(vnode, parentNode);
            removeCustomElmHook(vnode);
        }
    };
    function linkNodeToShadow(elm, vnode) {
        // TODO [#1164]: this should eventually be done by the polyfill directly
        elm.$shadowResolver$ = vnode.owner.cmpRoot.$shadowResolver$;
    } // TODO [#1136]: this should be done by the compiler, adding ns to every sub-element
    function addNS(vnode) {
        var data = vnode.data, children = vnode.children, sel = vnode.sel;
        data.ns = NamespaceAttributeForSVG; // TODO [#1275]: review why `sel` equal `foreignObject` should get this `ns`
        if (isArray$2(children) && sel !== 'foreignObject') {
            for (var j = 0, n = children.length; j < n; ++j) {
                var childNode = children[j];
                if (childNode != null && childNode.hook === ElementHook) {
                    addNS(childNode);
                }
            }
        }
    }
    function addVNodeToChildLWC(vnode) {
        ArrayPush$1.call(getVMBeingRendered().velements, vnode);
    } // [h]tml node
    function h(sel, data, children) {
        var vmBeingRendered = getVMBeingRendered();
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isString(sel), "h() 1st argument sel must be a string.");
            assert$1.isTrue(isObject$2(data), "h() 2nd argument data must be an object.");
            assert$1.isTrue(isArray$2(children), "h() 3rd argument children must be an array.");
            assert$1.isTrue('key' in data, " <" + sel + "> \"key\" attribute is invalid or missing for " + vmBeingRendered + ". Key inside iterator is either undefined or null."); // checking reserved internal data properties
            assert$1.isFalse(data.className && data.classMap, "vnode.data.className and vnode.data.classMap ambiguous declaration.");
            assert$1.isFalse(data.styleMap && data.style, "vnode.data.styleMap and vnode.data.style ambiguous declaration.");
            if (data.style && !isString(data.style)) {
                logError("Invalid 'style' attribute passed to <" + sel + "> is ignored. This attribute must be a string value.", vmBeingRendered);
            }
            forEach$1.call(children, function (childVnode) {
                if (childVnode != null) {
                    assert$1.isTrue(childVnode && 'sel' in childVnode && 'data' in childVnode && 'children' in childVnode && 'text' in childVnode && 'elm' in childVnode && 'key' in childVnode, childVnode + " is not a vnode.");
                }
            });
        }
        var key = data.key;
        var text, elm;
        var vnode = {
            sel: sel,
            data: data,
            children: children,
            text: text,
            elm: elm,
            key: key,
            hook: ElementHook,
            owner: vmBeingRendered
        };
        if (sel.length === 3 && StringCharCodeAt$1.call(sel, 0) === CHAR_S && StringCharCodeAt$1.call(sel, 1) === CHAR_V && StringCharCodeAt$1.call(sel, 2) === CHAR_G) {
            addNS(vnode);
        }
        return vnode;
    } // [t]ab[i]ndex function
    function ti(value) {
        // if value is greater than 0, we normalize to 0
        // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through
        // If value is less than -1, we don't care
        var shouldNormalize = value > 0 && !(isTrue$1$1(value) || isFalse$1$1(value));
        if (process.env.NODE_ENV !== 'production') {
            var vmBeingRendered_6 = getVMBeingRendered();
            if (shouldNormalize) {
                logError("Invalid tabindex value `" + toString$1(value) + "` in template for " + vmBeingRendered_6 + ". This attribute must be set to 0 or -1.", vmBeingRendered_6);
            }
        }
        return shouldNormalize ? 0 : value;
    } // [s]lot element node
    function s(slotName, data, children, slotset) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isString(slotName), "s() 1st argument slotName must be a string.");
            assert$1.isTrue(isObject$2(data), "s() 2nd argument data must be an object.");
            assert$1.isTrue(isArray$2(children), "h() 3rd argument children must be an array.");
        }
        if (!isUndefined$1(slotset) && !isUndefined$1(slotset[slotName]) && slotset[slotName].length !== 0) {
            children = slotset[slotName];
        }
        var vnode = h('slot', data, children);
        if (vnode.owner.renderer.syntheticShadow) {
            // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
            sc(children);
        }
        return vnode;
    } // [c]ustom element node
    function c(sel, Ctor, data, children) {
        if (children === void 0) { children = EmptyArray; }
        var vmBeingRendered = getVMBeingRendered();
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isString(sel), "c() 1st argument sel must be a string.");
            assert$1.isTrue(isFunction$1(Ctor), "c() 2nd argument Ctor must be a function.");
            assert$1.isTrue(isObject$2(data), "c() 3nd argument data must be an object.");
            assert$1.isTrue(arguments.length === 3 || isArray$2(children), "c() 4nd argument data must be an array."); // checking reserved internal data properties
            assert$1.isFalse(data.className && data.classMap, "vnode.data.className and vnode.data.classMap ambiguous declaration.");
            assert$1.isFalse(data.styleMap && data.style, "vnode.data.styleMap and vnode.data.style ambiguous declaration.");
            if (data.style && !isString(data.style)) {
                logError("Invalid 'style' attribute passed to <" + sel + "> is ignored. This attribute must be a string value.", vmBeingRendered);
            }
            if (arguments.length === 4) {
                forEach$1.call(children, function (childVnode) {
                    if (childVnode != null) {
                        assert$1.isTrue(childVnode && 'sel' in childVnode && 'data' in childVnode && 'children' in childVnode && 'text' in childVnode && 'elm' in childVnode && 'key' in childVnode, childVnode + " is not a vnode.");
                    }
                });
            }
        }
        var key = data.key;
        var text, elm;
        var vnode = {
            sel: sel,
            data: data,
            children: children,
            text: text,
            elm: elm,
            key: key,
            hook: CustomElementHook,
            ctor: Ctor,
            owner: vmBeingRendered,
            mode: 'open'
        };
        addVNodeToChildLWC(vnode);
        return vnode;
    } // [i]terable node
    function i(iterable, factory) {
        var list = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
        sc(list);
        var vmBeingRendered = getVMBeingRendered();
        if (isUndefined$1(iterable) || iterable === null) {
            if (process.env.NODE_ENV !== 'production') {
                logError("Invalid template iteration for value \"" + toString$1(iterable) + "\" in " + vmBeingRendered + ". It must be an Array or an iterable Object.", vmBeingRendered);
            }
            return list;
        }
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isFalse(isUndefined$1(iterable[SymbolIterator]), "Invalid template iteration for value `" + toString$1(iterable) + "` in " + vmBeingRendered + ". It must be an array-like object and not `null` nor `undefined`.");
        }
        var iterator = iterable[SymbolIterator]();
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(iterator && isFunction$1(iterator.next), "Invalid iterator function for \"" + toString$1(iterable) + "\" in " + vmBeingRendered + ".");
        }
        var next = iterator.next();
        var j = 0;
        var value = next.value, last = next.done;
        var keyMap;
        var iterationError;
        if (process.env.NODE_ENV !== 'production') {
            keyMap = create$1(null);
        }
        while (last === false) {
            // implementing a look-back-approach because we need to know if the element is the last
            next = iterator.next();
            last = next.done; // template factory logic based on the previous collected value
            var vnode = factory(value, j, j === 0, last);
            if (isArray$2(vnode)) {
                ArrayPush$1.apply(list, vnode);
            }
            else {
                ArrayPush$1.call(list, vnode);
            }
            if (process.env.NODE_ENV !== 'production') {
                var vnodes = isArray$2(vnode) ? vnode : [vnode];
                forEach$1.call(vnodes, function (childVnode) {
                    if (!isNull$1(childVnode) && isObject$2(childVnode) && !isUndefined$1(childVnode.sel)) {
                        var key = childVnode.key;
                        if (isString(key) || isNumber(key)) {
                            if (keyMap[key] === 1 && isUndefined$1(iterationError)) {
                                iterationError = "Duplicated \"key\" attribute value for \"<" + childVnode.sel + ">\" in " + vmBeingRendered + " for item number " + j + ". A key with value \"" + childVnode.key + "\" appears more than once in the iteration. Key values must be unique numbers or strings.";
                            }
                            keyMap[key] = 1;
                        }
                        else if (isUndefined$1(iterationError)) {
                            iterationError = "Invalid \"key\" attribute value in \"<" + childVnode.sel + ">\" in " + vmBeingRendered + " for item number " + j + ". Set a unique \"key\" value on all iterated child elements.";
                        }
                    }
                });
            } // preparing next value
            j += 1;
            value = next.value;
        }
        if (process.env.NODE_ENV !== 'production') {
            if (!isUndefined$1(iterationError)) {
                logError(iterationError, vmBeingRendered);
            }
        }
        return list;
    }
    /**
     * [f]lattening
     */
    function f(items) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isArray$2(items), 'flattening api can only work with arrays.');
        }
        var len = items.length;
        var flattened = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
        sc(flattened);
        for (var j = 0; j < len; j += 1) {
            var item = items[j];
            if (isArray$2(item)) {
                ArrayPush$1.apply(flattened, item);
            }
            else {
                ArrayPush$1.call(flattened, item);
            }
        }
        return flattened;
    } // [t]ext node
    function t(text) {
        var data = EmptyObject;
        var sel, children, key, elm;
        return {
            sel: sel,
            data: data,
            children: children,
            text: text,
            elm: elm,
            key: key,
            hook: TextHook,
            owner: getVMBeingRendered()
        };
    } // [d]ynamic value to produce a text vnode
    function d(value) {
        if (value == null) {
            return null;
        }
        return t(value);
    } // [b]ind function
    function b(fn) {
        var vmBeingRendered = getVMBeingRendered();
        if (isNull$1(vmBeingRendered)) {
            throw new Error();
        }
        var vm = vmBeingRendered;
        return function (event) {
            invokeEventListener(vm, fn, vm.component, event);
        };
    } // [k]ey function
    function k(compilerKey, obj) {
        switch (typeof obj) {
            case 'number':
            case 'string':
                return compilerKey + ':' + obj;
            case 'object':
                if (process.env.NODE_ENV !== 'production') {
                    assert$1.fail("Invalid key value \"" + obj + "\" in " + getVMBeingRendered() + ". Key must be a string or number.");
                }
        }
    } // [g]lobal [id] function
    function gid(id) {
        var vmBeingRendered = getVMBeingRendered();
        if (isUndefined$1(id) || id === '') {
            if (process.env.NODE_ENV !== 'production') {
                logError("Invalid id value \"" + id + "\". The id attribute must contain a non-empty string.", vmBeingRendered);
            }
            return id;
        } // We remove attributes when they are assigned a value of null
        if (isNull$1(id)) {
            return null;
        }
        return id + "-" + vmBeingRendered.idx;
    } // [f]ragment [id] function
    function fid(url) {
        var vmBeingRendered = getVMBeingRendered();
        if (isUndefined$1(url) || url === '') {
            if (process.env.NODE_ENV !== 'production') {
                if (isUndefined$1(url)) {
                    logError("Undefined url value for \"href\" or \"xlink:href\" attribute. Expected a non-empty string.", vmBeingRendered);
                }
            }
            return url;
        } // We remove attributes when they are assigned a value of null
        if (isNull$1(url)) {
            return null;
        } // Apply transformation only for fragment-only-urls
        if (/^#/.test(url)) {
            return url + "-" + vmBeingRendered.idx;
        }
        return url;
    }
    /**
     * Map to store an index value assigned to any dynamic component reference ingested
     * by dc() api. This allows us to generate a unique unique per template per dynamic
     * component reference to avoid diffing algo mismatches.
     */
    var DynamicImportedComponentMap = new Map();
    var dynamicImportedComponentCounter = 0;
    /**
     * create a dynamic component via `<x-foo lwc:dynamic={Ctor}>`
     */
    function dc(sel, Ctor, data, children) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isString(sel), "dc() 1st argument sel must be a string.");
            assert$1.isTrue(isObject$2(data), "dc() 3nd argument data must be an object.");
            assert$1.isTrue(arguments.length === 3 || isArray$2(children), "dc() 4nd argument data must be an array.");
        } // null or undefined values should produce a null value in the VNodes
        if (Ctor == null) {
            return null;
        }
        if (!isComponentConstructor(Ctor)) {
            throw new Error("Invalid LWC Constructor " + toString$1(Ctor) + " for custom element <" + sel + ">.");
        }
        var idx = DynamicImportedComponentMap.get(Ctor);
        if (isUndefined$1(idx)) {
            idx = dynamicImportedComponentCounter++;
            DynamicImportedComponentMap.set(Ctor, idx);
        } // the new vnode key is a mix of idx and compiler key, this is required by the diffing algo
        // to identify different constructors as vnodes with different keys to avoid reusing the
        // element used for previous constructors.
        data.key = "dc:" + idx + ":" + data.key;
        return c(sel, Ctor, data, children);
    }
    /**
     * slow children collection marking mechanism. this API allows the compiler to signal
     * to the engine that a particular collection of children must be diffed using the slow
     * algo based on keys due to the nature of the list. E.g.:
     *
     *   - slot element's children: the content of the slot has to be dynamic when in synthetic
     *                              shadow mode because the `vnode.children` might be the slotted
     *                              content vs default content, in which case the size and the
     *                              keys are not matching.
     *   - children that contain dynamic components
     *   - children that are produced by iteration
     *
     */
    function sc(vnodes) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isArray$2(vnodes), 'sc() api can only work with arrays.');
        } // We have to mark the vnodes collection as dynamic so we can later on
        // choose to use the snabbdom virtual dom diffing algo instead of our
        // static dummy algo.
        markAsDynamicChildren(vnodes);
        return vnodes;
    }
    var api$1 = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        h: h,
        ti: ti,
        s: s,
        c: c,
        i: i,
        f: f,
        t: t,
        d: d,
        b: b,
        k: k,
        gid: gid,
        fid: fid,
        dc: dc,
        sc: sc
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function createShadowStyleVNode(content) {
        return h('style', {
            key: 'style',
            attrs: {
                type: 'text/css'
            }
        }, [t(content)]);
    }
    function updateSyntheticShadowAttributes(vm, template) {
        var elm = vm.elm, context = vm.context, renderer = vm.renderer;
        var newStylesheets = template.stylesheets, newStylesheetTokens = template.stylesheetTokens;
        var newHostAttribute;
        var newShadowAttribute; // Reset the styling token applied to the host element.
        var oldHostAttribute = context.hostAttribute;
        if (!isUndefined$1(oldHostAttribute)) {
            renderer.removeAttribute(elm, oldHostAttribute);
        } // Apply the new template styling token to the host element, if the new template has any
        // associated stylesheets.
        if (!isUndefined$1(newStylesheetTokens) && !isUndefined$1(newStylesheets) && newStylesheets.length !== 0) {
            newHostAttribute = newStylesheetTokens.hostAttribute;
            newShadowAttribute = newStylesheetTokens.shadowAttribute;
            renderer.setAttribute(elm, newHostAttribute, '');
        } // Update the styling tokens present on the context object.
        context.hostAttribute = newHostAttribute;
        context.shadowAttribute = newShadowAttribute;
    }
    function evaluateStylesheetsContent(stylesheets, hostSelector, shadowSelector, nativeShadow) {
        var content = [];
        for (var i_9 = 0; i_9 < stylesheets.length; i_9++) {
            var stylesheet = stylesheets[i_9];
            if (isArray$2(stylesheet)) {
                ArrayPush$1.apply(content, evaluateStylesheetsContent(stylesheet, hostSelector, shadowSelector, nativeShadow));
            }
            else {
                ArrayPush$1.call(content, stylesheet(hostSelector, shadowSelector, nativeShadow));
            }
        }
        return content;
    }
    function getStylesheetsContent(vm, template) {
        var stylesheets = template.stylesheets, tokens = template.stylesheetTokens;
        var syntheticShadow = vm.renderer.syntheticShadow;
        var content = [];
        if (!isUndefined$1(stylesheets) && !isUndefined$1(tokens)) {
            var hostSelector = syntheticShadow ? "[" + tokens.hostAttribute + "]" : '';
            var shadowSelector = syntheticShadow ? "[" + tokens.shadowAttribute + "]" : '';
            content = evaluateStylesheetsContent(stylesheets, hostSelector, shadowSelector, !syntheticShadow);
        }
        return content;
    }
    function createStylesheet(vm, stylesheets) {
        var renderer = vm.renderer;
        if (renderer.syntheticShadow) {
            for (var i_10 = 0; i_10 < stylesheets.length; i_10++) {
                renderer.insertGlobalStylesheet(stylesheets[i_10]);
            }
            return null;
        }
        else {
            var shadowStyleSheetContent = ArrayJoin$1.call(stylesheets, '\n');
            return createShadowStyleVNode(shadowStyleSheetContent);
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var GlobalMeasurementPhase;
    (function (GlobalMeasurementPhase) {
        GlobalMeasurementPhase["REHYDRATE"] = "lwc-rehydrate";
        GlobalMeasurementPhase["HYDRATE"] = "lwc-hydrate";
    })(GlobalMeasurementPhase || (GlobalMeasurementPhase = {})); // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.
    // JSDom (used in Jest) for example doesn't implement the UserTiming APIs.
    var isUserTimingSupported = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
    function getMarkName(phase, vm) {
        // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce
        // the right measures for components that are recursive.
        return getComponentTag(vm) + " - " + phase + " - " + vm.idx;
    }
    function getMeasureName(phase, vm) {
        return getComponentTag(vm) + " - " + phase;
    }
    function start(markName) {
        performance.mark(markName);
    }
    function end(measureName, markName) {
        performance.measure(measureName, markName); // Clear the created marks and measure to avoid filling the performance entries buffer.
        // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.
        performance.clearMarks(markName);
        performance.clearMarks(measureName);
    }
    function noop$1() {
        /* do nothing */
    }
    var startMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {
        var markName = getMarkName(phase, vm);
        start(markName);
    };
    var endMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {
        var markName = getMarkName(phase, vm);
        var measureName = getMeasureName(phase, vm);
        end(measureName, markName);
    };
    var startGlobalMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {
        var markName = isUndefined$1(vm) ? phase : getMarkName(phase, vm);
        start(markName);
    };
    var endGlobalMeasure = !isUserTimingSupported ? noop$1 : function (phase, vm) {
        var markName = isUndefined$1(vm) ? phase : getMarkName(phase, vm);
        end(phase, markName);
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var isUpdatingTemplate = false;
    var vmBeingRendered = null;
    function getVMBeingRendered() {
        return vmBeingRendered;
    }
    function setVMBeingRendered(vm) {
        vmBeingRendered = vm;
    }
    function validateSlots(vm, html) {
        if (process.env.NODE_ENV === 'production') {
            // this method should never leak to prod
            throw new ReferenceError();
        }
        var cmpSlots = vm.cmpSlots;
        var _b = html.slots, slots = _b === void 0 ? EmptyArray : _b;
        for (var slotName in cmpSlots) {
            // eslint-disable-next-line lwc-internal/no-production-assert
            assert$1.isTrue(isArray$2(cmpSlots[slotName]), "Slots can only be set to an array, instead received " + toString$1(cmpSlots[slotName]) + " for slot \"" + slotName + "\" in " + vm + ".");
            if (slotName !== '' && ArrayIndexOf$1.call(slots, slotName) === -1) {
                // TODO [#1297]: this should never really happen because the compiler should always validate
                // eslint-disable-next-line lwc-internal/no-production-assert
                logError("Ignoring unknown provided slot name \"" + slotName + "\" in " + vm + ". Check for a typo on the slot attribute.", vm);
            }
        }
    }
    function evaluateTemplate(vm, html) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isFunction$1(html), "evaluateTemplate() second argument must be an imported template instead of " + toString$1(html));
        }
        var isUpdatingTemplateInception = isUpdatingTemplate;
        var vmOfTemplateBeingUpdatedInception = vmBeingRendered;
        var vnodes = [];
        runWithBoundaryProtection(vm, vm.owner, function () {
            // pre
            vmBeingRendered = vm;
            if (process.env.NODE_ENV !== 'production') {
                startMeasure('render', vm);
            }
        }, function () {
            // job
            var component = vm.component, context = vm.context, cmpSlots = vm.cmpSlots, cmpTemplate = vm.cmpTemplate, tro = vm.tro, renderer = vm.renderer;
            tro.observe(function () {
                // Reset the cache memoizer for template when needed.
                if (html !== cmpTemplate) {
                    // Perf opt: do not reset the shadow root during the first rendering (there is
                    // nothing to reset).
                    if (!isNull$1(cmpTemplate)) {
                        // It is important to reset the content to avoid reusing similar elements
                        // generated from a different template, because they could have similar IDs,
                        // and snabbdom just rely on the IDs.
                        resetShadowRoot(vm);
                    } // Check that the template was built by the compiler.
                    if (!isTemplateRegistered(html)) {
                        throw new TypeError("Invalid template returned by the render() method on " + vm + ". It must return an imported template (e.g.: `import html from \"./" + vm.def.name + ".html\"`), instead, it has returned: " + toString$1(html) + ".");
                    }
                    vm.cmpTemplate = html; // Create a brand new template cache for the swapped templated.
                    context.tplCache = create$1(null); // Update the synthetic shadow attributes on the host element if necessary.
                    if (renderer.syntheticShadow) {
                        updateSyntheticShadowAttributes(vm, html);
                    } // Evaluate, create stylesheet and cache the produced VNode for future
                    // re-rendering.
                    var stylesheetsContent = getStylesheetsContent(vm, html);
                    context.styleVNode = stylesheetsContent.length === 0 ? null : createStylesheet(vm, stylesheetsContent);
                }
                if (process.env.NODE_ENV !== 'production') {
                    // validating slots in every rendering since the allocated content might change over time
                    validateSlots(vm, html);
                } // right before producing the vnodes, we clear up all internal references
                // to custom elements from the template.
                vm.velements = []; // Set the global flag that template is being updated
                isUpdatingTemplate = true;
                vnodes = html.call(undefined, api$1, component, cmpSlots, context.tplCache);
                var styleVNode = context.styleVNode;
                if (!isNull$1(styleVNode)) {
                    ArrayUnshift$2.call(vnodes, styleVNode);
                }
            });
        }, function () {
            // post
            isUpdatingTemplate = isUpdatingTemplateInception;
            vmBeingRendered = vmOfTemplateBeingUpdatedInception;
            if (process.env.NODE_ENV !== 'production') {
                endMeasure('render', vm);
            }
        });
        if (process.env.NODE_ENV !== 'production') {
            assert$1.invariant(isArray$2(vnodes), "Compiler should produce html functions that always return an array.");
        }
        return vnodes;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function addErrorComponentStack(vm, error) {
        if (!isFrozen$1(error) && isUndefined$1(error.wcStack)) {
            var wcStack_1 = getErrorComponentStack(vm);
            defineProperty$1(error, 'wcStack', {
                get: function () {
                    return wcStack_1;
                }
            });
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var isInvokingRender = false;
    var vmBeingConstructed = null;
    function isBeingConstructed(vm) {
        return vmBeingConstructed === vm;
    }
    var noop$2 = function () { return void 0; };
    function invokeComponentCallback(vm, fn, args) {
        var component = vm.component, callHook = vm.callHook, owner = vm.owner;
        var result;
        runWithBoundaryProtection(vm, owner, noop$2, function () {
            // job
            result = callHook(component, fn, args);
        }, noop$2);
        return result;
    }
    function invokeComponentConstructor(vm, Ctor) {
        var vmBeingConstructedInception = vmBeingConstructed;
        var error;
        if (process.env.NODE_ENV !== 'production') {
            startMeasure('constructor', vm);
        }
        vmBeingConstructed = vm;
        /**
         * Constructors don't need to be wrapped with a boundary because for root elements
         * it should throw, while elements from template are already wrapped by a boundary
         * associated to the diffing algo.
         */
        try {
            // job
            var result = new Ctor(); // Check indirectly if the constructor result is an instance of LightningElement. Using
            // the "instanceof" operator would not work here since Locker Service provides its own
            // implementation of LightningElement, so we indirectly check if the base constructor is
            // invoked by accessing the component on the vm.
            if (vmBeingConstructed.component !== result) {
                throw new TypeError('Invalid component constructor, the class should extend LightningElement.');
            }
        }
        catch (e) {
            error = Object(e);
        }
        finally {
            if (process.env.NODE_ENV !== 'production') {
                endMeasure('constructor', vm);
            }
            vmBeingConstructed = vmBeingConstructedInception;
            if (!isUndefined$1(error)) {
                addErrorComponentStack(vm, error); // re-throwing the original error annotated after restoring the context
                throw error; // eslint-disable-line no-unsafe-finally
            }
        }
    }
    function invokeComponentRenderMethod(vm) {
        var render = vm.def.render, callHook = vm.callHook, component = vm.component, owner = vm.owner;
        var isRenderBeingInvokedInception = isInvokingRender;
        var vmBeingRenderedInception = getVMBeingRendered();
        var html;
        var renderInvocationSuccessful = false;
        runWithBoundaryProtection(vm, owner, function () {
            // pre
            isInvokingRender = true;
            setVMBeingRendered(vm);
        }, function () {
            // job
            vm.tro.observe(function () {
                html = callHook(component, render);
                renderInvocationSuccessful = true;
            });
        }, function () {
            // post
            isInvokingRender = isRenderBeingInvokedInception;
            setVMBeingRendered(vmBeingRenderedInception);
        }); // If render() invocation failed, process errorCallback in boundary and return an empty template
        return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];
    }
    function invokeComponentRenderedCallback(vm) {
        var renderedCallback = vm.def.renderedCallback, component = vm.component, callHook = vm.callHook, owner = vm.owner;
        if (!isUndefined$1(renderedCallback)) {
            runWithBoundaryProtection(vm, owner, function () {
                if (process.env.NODE_ENV !== 'production') {
                    startMeasure('renderedCallback', vm);
                }
            }, function () {
                // job
                callHook(component, renderedCallback);
            }, function () {
                // post
                if (process.env.NODE_ENV !== 'production') {
                    endMeasure('renderedCallback', vm);
                }
            });
        }
    }
    function invokeEventListener(vm, fn, thisValue, event) {
        var callHook = vm.callHook, owner = vm.owner;
        runWithBoundaryProtection(vm, owner, noop$2, function () {
            // job
            if (process.env.NODE_ENV !== 'production') {
                assert$1.isTrue(isFunction$1(fn), "Invalid event handler for event '" + event.type + "' on " + vm + ".");
            }
            callHook(thisValue, fn, [event]);
        }, noop$2);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var signedTemplateMap = new Map();
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerComponent(Ctor, _b) {
        var tmpl = _b.tmpl;
        signedTemplateMap.set(Ctor, tmpl); // chaining this method as a way to wrap existing assignment of component constructor easily,
        // without too much transformation
        return Ctor;
    }
    function getComponentRegisteredTemplate(Ctor) {
        return signedTemplateMap.get(Ctor);
    }
    function createComponent(vm, Ctor) {
        // create the component instance
        invokeComponentConstructor(vm, Ctor);
        if (isUndefined$1(vm.component)) {
            throw new ReferenceError("Invalid construction for " + Ctor + ", you must extend LightningElement.");
        }
    }
    function getTemplateReactiveObserver(vm) {
        return new ReactiveObserver(function () {
            var isDirty = vm.isDirty;
            if (isFalse$1$1(isDirty)) {
                markComponentAsDirty(vm);
                scheduleRehydration(vm);
            }
        });
    }
    function renderComponent(vm) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.invariant(vm.isDirty, vm + " is not dirty.");
        }
        vm.tro.reset();
        var vnodes = invokeComponentRenderMethod(vm);
        vm.isDirty = false;
        vm.isScheduled = false;
        if (process.env.NODE_ENV !== 'production') {
            assert$1.invariant(isArray$2(vnodes), vm + ".render() should always return an array of vnodes instead of " + vnodes);
        }
        return vnodes;
    }
    function markComponentAsDirty(vm) {
        if (process.env.NODE_ENV !== 'production') {
            var vmBeingRendered_7 = getVMBeingRendered();
            assert$1.isFalse(vm.isDirty, "markComponentAsDirty() for " + vm + " should not be called when the component is already dirty.");
            assert$1.isFalse(isInvokingRender, "markComponentAsDirty() for " + vm + " cannot be called during rendering of " + vmBeingRendered_7 + ".");
            assert$1.isFalse(isUpdatingTemplate, "markComponentAsDirty() for " + vm + " cannot be called while updating template of " + vmBeingRendered_7 + ".");
        }
        vm.isDirty = true;
    }
    var cmpEventListenerMap = new WeakMap();
    function getWrappedComponentsListener(vm, listener) {
        if (!isFunction$1(listener)) {
            throw new TypeError(); // avoiding problems with non-valid listeners
        }
        var wrappedListener = cmpEventListenerMap.get(listener);
        if (isUndefined$1(wrappedListener)) {
            wrappedListener = function (event) {
                invokeEventListener(vm, listener, undefined, event);
            };
            cmpEventListenerMap.set(listener, wrappedListener);
        }
        return wrappedListener;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var Services = create$1(null);
    var hooks = ['rendered', 'connected', 'disconnected'];
    /**
     * EXPERIMENTAL: This function allows for the registration of "services"
     * in LWC by exposing hooks into the component life-cycle. This API is
     * subject to change or being removed.
     */
    function register(service) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isObject$2(service), "Invalid service declaration, " + service + ": service must be an object");
        }
        for (var i_11 = 0; i_11 < hooks.length; ++i_11) {
            var hookName = hooks[i_11];
            if (hookName in service) {
                var l = Services[hookName];
                if (isUndefined$1(l)) {
                    Services[hookName] = l = [];
                }
                ArrayPush$1.call(l, service[hookName]);
            }
        }
    }
    function invokeServiceHook(vm, cbs) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(isArray$2(cbs) && cbs.length > 0, "Optimize invokeServiceHook() to be invoked only when needed");
        }
        var component = vm.component, def = vm.def, context = vm.context;
        for (var i_12 = 0, len = cbs.length; i_12 < len; ++i_12) {
            cbs[i_12].call(undefined, component, {}, def, context);
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var VMState;
    (function (VMState) {
        VMState[VMState["created"] = 0] = "created";
        VMState[VMState["connected"] = 1] = "connected";
        VMState[VMState["disconnected"] = 2] = "disconnected";
    })(VMState || (VMState = {}));
    var idx = 0;
    /** The internal slot used to associate different objects the engine manipulates with the VM */
    var ViewModelReflection = createHiddenField$1('ViewModel', 'engine');
    function callHook(cmp, fn, args) {
        if (args === void 0) { args = []; }
        return fn.apply(cmp, args);
    }
    function setHook(cmp, prop, newValue) {
        cmp[prop] = newValue;
    }
    function getHook(cmp, prop) {
        return cmp[prop];
    }
    function rerenderVM(vm) {
        rehydrate(vm);
    }
    function connectRootElement(elm) {
        var vm = getAssociatedVM(elm);
        startGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm); // Usually means moving the element from one place to another, which is observable via
        // life-cycle hooks.
        if (vm.state === VMState.connected) {
            disconnectRootElement(elm);
        }
        runConnectedCallback(vm);
        rehydrate(vm);
        endGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);
    }
    function disconnectRootElement(elm) {
        var vm = getAssociatedVM(elm);
        resetComponentStateWhenRemoved(vm);
    }
    function appendVM(vm) {
        rehydrate(vm);
    } // just in case the component comes back, with this we guarantee re-rendering it
    // while preventing any attempt to rehydration until after reinsertion.
    function resetComponentStateWhenRemoved(vm) {
        var state = vm.state;
        if (state !== VMState.disconnected) {
            var oar = vm.oar, tro = vm.tro; // Making sure that any observing record will not trigger the rehydrated on this vm
            tro.reset(); // Making sure that any observing accessor record will not trigger the setter to be reinvoked
            for (var key in oar) {
                oar[key].reset();
            }
            runDisconnectedCallback(vm); // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)
            runShadowChildNodesDisconnectedCallback(vm);
            runLightChildNodesDisconnectedCallback(vm);
        }
    } // this method is triggered by the diffing algo only when a vnode from the
    // old vnode.children is removed from the DOM.
    function removeVM(vm) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(vm.state === VMState.connected || vm.state === VMState.disconnected, vm + " must have been connected.");
        }
        resetComponentStateWhenRemoved(vm);
    }
    function createVM(elm, def, options) {
        var mode = options.mode, owner = options.owner, renderer = options.renderer, tagName = options.tagName;
        var vm = {
            elm: elm,
            def: def,
            idx: idx++,
            state: VMState.created,
            isScheduled: false,
            isDirty: true,
            tagName: tagName,
            mode: mode,
            owner: owner,
            renderer: renderer,
            children: EmptyArray,
            aChildren: EmptyArray,
            velements: EmptyArray,
            cmpProps: create$1(null),
            cmpFields: create$1(null),
            cmpSlots: create$1(null),
            oar: create$1(null),
            cmpTemplate: null,
            context: {
                hostAttribute: undefined,
                shadowAttribute: undefined,
                styleVNode: null,
                tplCache: EmptyObject,
                wiredConnecting: EmptyArray,
                wiredDisconnecting: EmptyArray
            },
            tro: null,
            component: null,
            cmpRoot: null,
            callHook: callHook,
            setHook: setHook,
            getHook: getHook
        };
        vm.tro = getTemplateReactiveObserver(vm);
        if (process.env.NODE_ENV !== 'production') {
            vm.toString = function () {
                return "[object:vm " + def.name + " (" + vm.idx + ")]";
            };
        } // Create component instance associated to the vm and the element.
        createComponent(vm, def.ctor); // Initializing the wire decorator per instance only when really needed
        if (isFalse$1$1(renderer.ssr) && hasWireAdapters(vm)) {
            installWireAdapters(vm);
        }
        return vm;
    }
    function assertIsVM(obj) {
        if (isNull$1(obj) || !isObject$2(obj) || !('cmpRoot' in obj)) {
            throw new TypeError(obj + " is not a VM.");
        }
    }
    function associateVM(obj, vm) {
        setHiddenField$1(obj, ViewModelReflection, vm);
    }
    function getAssociatedVM(obj) {
        var vm = getHiddenField$1(obj, ViewModelReflection);
        if (process.env.NODE_ENV !== 'production') {
            assertIsVM(vm);
        }
        return vm;
    }
    function getAssociatedVMIfPresent(obj) {
        var maybeVm = getHiddenField$1(obj, ViewModelReflection);
        if (process.env.NODE_ENV !== 'production') {
            if (!isUndefined$1(maybeVm)) {
                assertIsVM(maybeVm);
            }
        }
        return maybeVm;
    }
    function rehydrate(vm) {
        if (isTrue$1$1(vm.isDirty)) {
            var children = renderComponent(vm);
            patchShadowRoot(vm, children);
        }
    }
    function patchShadowRoot(vm, newCh) {
        var cmpRoot = vm.cmpRoot, oldCh = vm.children; // caching the new children collection
        vm.children = newCh;
        if (newCh.length > 0 || oldCh.length > 0) {
            // patch function mutates vnodes by adding the element reference,
            // however, if patching fails it contains partial changes.
            if (oldCh !== newCh) {
                var fn_1 = hasDynamicChildren(newCh) ? updateDynamicChildren : updateStaticChildren;
                runWithBoundaryProtection(vm, vm, function () {
                    // pre
                    if (process.env.NODE_ENV !== 'production') {
                        startMeasure('patch', vm);
                    }
                }, function () {
                    // job
                    fn_1(cmpRoot, oldCh, newCh);
                }, function () {
                    // post
                    if (process.env.NODE_ENV !== 'production') {
                        endMeasure('patch', vm);
                    }
                });
            }
        }
        if (vm.state === VMState.connected) {
            // If the element is connected, that means connectedCallback was already issued, and
            // any successive rendering should finish with the call to renderedCallback, otherwise
            // the connectedCallback will take care of calling it in the right order at the end of
            // the current rehydration process.
            runRenderedCallback(vm);
        }
    }
    function runRenderedCallback(vm) {
        if (isTrue$1$1(vm.renderer.ssr)) {
            return;
        }
        var rendered = Services.rendered;
        if (rendered) {
            invokeServiceHook(vm, rendered);
        }
        invokeComponentRenderedCallback(vm);
    }
    var rehydrateQueue = [];
    function flushRehydrationQueue() {
        startGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);
        if (process.env.NODE_ENV !== 'production') {
            assert$1.invariant(rehydrateQueue.length, "If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of " + rehydrateQueue + ".");
        }
        var vms = rehydrateQueue.sort(function (a, b) { return a.idx - b.idx; });
        rehydrateQueue = []; // reset to a new queue
        for (var i_13 = 0, len = vms.length; i_13 < len; i_13 += 1) {
            var vm = vms[i_13];
            try {
                rehydrate(vm);
            }
            catch (error) {
                if (i_13 + 1 < len) {
                    // pieces of the queue are still pending to be rehydrated, those should have priority
                    if (rehydrateQueue.length === 0) {
                        addCallbackToNextTick(flushRehydrationQueue);
                    }
                    ArrayUnshift$2.apply(rehydrateQueue, ArraySlice$2.call(vms, i_13 + 1));
                } // we need to end the measure before throwing.
                endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE); // re-throwing the original error will break the current tick, but since the next tick is
                // already scheduled, it should continue patching the rest.
                throw error; // eslint-disable-line no-unsafe-finally
            }
        }
        endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);
    }
    function runConnectedCallback(vm) {
        var state = vm.state;
        if (state === VMState.connected) {
            return; // nothing to do since it was already connected
        }
        vm.state = VMState.connected; // reporting connection
        var connected = Services.connected;
        if (connected) {
            invokeServiceHook(vm, connected);
        }
        if (hasWireAdapters(vm)) {
            connectWireAdapters(vm);
        }
        var connectedCallback = vm.def.connectedCallback;
        if (!isUndefined$1(connectedCallback)) {
            if (process.env.NODE_ENV !== 'production') {
                startMeasure('connectedCallback', vm);
            }
            invokeComponentCallback(vm, connectedCallback);
            if (process.env.NODE_ENV !== 'production') {
                endMeasure('connectedCallback', vm);
            }
        }
    }
    function hasWireAdapters(vm) {
        return getOwnPropertyNames$1(vm.def.wire).length > 0;
    }
    function runDisconnectedCallback(vm) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.isTrue(vm.state !== VMState.disconnected, vm + " must be inserted.");
        }
        if (isFalse$1$1(vm.isDirty)) {
            // this guarantees that if the component is reused/reinserted,
            // it will be re-rendered because we are disconnecting the reactivity
            // linking, so mutations are not automatically reflected on the state
            // of disconnected components.
            vm.isDirty = true;
        }
        vm.state = VMState.disconnected; // reporting disconnection
        var disconnected = Services.disconnected;
        if (disconnected) {
            invokeServiceHook(vm, disconnected);
        }
        if (hasWireAdapters(vm)) {
            disconnectWireAdapters(vm);
        }
        var disconnectedCallback = vm.def.disconnectedCallback;
        if (!isUndefined$1(disconnectedCallback)) {
            if (process.env.NODE_ENV !== 'production') {
                startMeasure('disconnectedCallback', vm);
            }
            invokeComponentCallback(vm, disconnectedCallback);
            if (process.env.NODE_ENV !== 'production') {
                endMeasure('disconnectedCallback', vm);
            }
        }
    }
    function runShadowChildNodesDisconnectedCallback(vm) {
        var vCustomElementCollection = vm.velements; // Reporting disconnection for every child in inverse order since they are
        // inserted in reserved order.
        for (var i_14 = vCustomElementCollection.length - 1; i_14 >= 0; i_14 -= 1) {
            var elm = vCustomElementCollection[i_14].elm; // There are two cases where the element could be undefined:
            // * when there is an error during the construction phase, and an error
            //   boundary picks it, there is a possibility that the VCustomElement
            //   is not properly initialized, and therefore is should be ignored.
            // * when slotted custom element is not used by the element where it is
            //   slotted into it, as  a result, the custom element was never
            //   initialized.
            if (!isUndefined$1(elm)) {
                var childVM = getAssociatedVMIfPresent(elm); // The VM associated with the element might be associated undefined
                // in the case where the VM failed in the middle of its creation,
                // eg: constructor throwing before invoking super().
                if (!isUndefined$1(childVM)) {
                    resetComponentStateWhenRemoved(childVM);
                }
            }
        }
    }
    function runLightChildNodesDisconnectedCallback(vm) {
        var adoptedChildren = vm.aChildren;
        recursivelyDisconnectChildren(adoptedChildren);
    }
    /**
     * The recursion doesn't need to be a complete traversal of the vnode graph,
     * instead it can be partial, when a custom element vnode is found, we don't
     * need to continue into its children because by attempting to disconnect the
     * custom element itself will trigger the removal of anything slotted or anything
     * defined on its shadow.
     */
    function recursivelyDisconnectChildren(vnodes) {
        for (var i_15 = 0, len = vnodes.length; i_15 < len; i_15 += 1) {
            var vnode = vnodes[i_15];
            if (!isNull$1(vnode) && isArray$2(vnode.children) && !isUndefined$1(vnode.elm)) {
                // vnode is a VElement with children
                if (isUndefined$1(vnode.ctor)) {
                    // it is a VElement, just keep looking (recursively)
                    recursivelyDisconnectChildren(vnode.children);
                }
                else {
                    // it is a VCustomElement, disconnect it and ignore its children
                    resetComponentStateWhenRemoved(getAssociatedVM(vnode.elm));
                }
            }
        }
    } // This is a super optimized mechanism to remove the content of the shadowRoot without having to go
    // into snabbdom. Especially useful when the reset is a consequence of an error, in which case the
    // children VNodes might not be representing the current state of the DOM.
    function resetShadowRoot(vm) {
        var children = vm.children, cmpRoot = vm.cmpRoot, renderer = vm.renderer;
        for (var i_16 = 0, len = children.length; i_16 < len; i_16++) {
            var child = children[i_16];
            if (!isNull$1(child) && !isUndefined$1(child.elm)) {
                renderer.remove(child.elm, cmpRoot);
            }
        }
        vm.children = EmptyArray;
        runShadowChildNodesDisconnectedCallback(vm);
        vm.velements = EmptyArray;
    }
    function scheduleRehydration(vm) {
        if (isTrue$1$1(vm.renderer.ssr) || isTrue$1$1(vm.isScheduled)) {
            return;
        }
        vm.isScheduled = true;
        if (rehydrateQueue.length === 0) {
            addCallbackToNextTick(flushRehydrationQueue);
        }
        ArrayPush$1.call(rehydrateQueue, vm);
    }
    function getErrorBoundaryVM(vm) {
        var currentVm = vm;
        while (!isNull$1(currentVm)) {
            if (!isUndefined$1(currentVm.def.errorCallback)) {
                return currentVm;
            }
            currentVm = currentVm.owner;
        }
    } // slow path routine
    // NOTE: we should probably more this routine to the synthetic shadow folder
    // and get the allocation to be cached by in the elm instead of in the VM
    function allocateInSlot(vm, children) {
        if (process.env.NODE_ENV !== 'production') {
            assert$1.invariant(isObject$2(vm.cmpSlots), "When doing manual allocation, there must be a cmpSlots object available.");
        }
        var oldSlots = vm.cmpSlots;
        var cmpSlots = vm.cmpSlots = create$1(null);
        for (var i_17 = 0, len = children.length; i_17 < len; i_17 += 1) {
            var vnode = children[i_17];
            if (isNull$1(vnode)) {
                continue;
            }
            var data = vnode.data;
            var slotName = data.attrs && data.attrs.slot || '';
            var vnodes = cmpSlots[slotName] = cmpSlots[slotName] || []; // re-keying the vnodes is necessary to avoid conflicts with default content for the slot
            // which might have similar keys. Each vnode will always have a key that
            // starts with a numeric character from compiler. In this case, we add a unique
            // notation for slotted vnodes keys, e.g.: `@foo:1:1`
            if (!isUndefined$1(vnode.key)) {
                vnode.key = "@" + slotName + ":" + vnode.key;
            }
            ArrayPush$1.call(vnodes, vnode);
        }
        if (isFalse$1$1(vm.isDirty)) {
            // We need to determine if the old allocation is really different from the new one
            // and mark the vm as dirty
            var oldKeys = keys$1(oldSlots);
            if (oldKeys.length !== keys$1(cmpSlots).length) {
                markComponentAsDirty(vm);
                return;
            }
            for (var i_18 = 0, len = oldKeys.length; i_18 < len; i_18 += 1) {
                var key = oldKeys[i_18];
                if (isUndefined$1(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {
                    markComponentAsDirty(vm);
                    return;
                }
                var oldVNodes = oldSlots[key];
                var vnodes = cmpSlots[key];
                for (var j = 0, a = cmpSlots[key].length; j < a; j += 1) {
                    if (oldVNodes[j] !== vnodes[j]) {
                        markComponentAsDirty(vm);
                        return;
                    }
                }
            }
        }
    }
    function runWithBoundaryProtection(vm, owner, pre, job, post) {
        var error;
        pre();
        try {
            job();
        }
        catch (e) {
            error = Object(e);
        }
        finally {
            post();
            if (!isUndefined$1(error)) {
                addErrorComponentStack(vm, error);
                var errorBoundaryVm = isNull$1(owner) ? undefined : getErrorBoundaryVM(owner);
                if (isUndefined$1(errorBoundaryVm)) {
                    throw error; // eslint-disable-line no-unsafe-finally
                }
                resetShadowRoot(vm); // remove offenders
                if (process.env.NODE_ENV !== 'production') {
                    startMeasure('errorCallback', errorBoundaryVm);
                } // error boundaries must have an ErrorCallback
                var errorCallback = errorBoundaryVm.def.errorCallback;
                invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);
                if (process.env.NODE_ENV !== 'production') {
                    endMeasure('errorCallback', errorBoundaryVm);
                }
            }
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';
    var DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';
    var WireMetaMap = new Map();
    function noop$3() { }
    var WireContextRegistrationEvent = /** @class */ (function (_super) {
        __extends(WireContextRegistrationEvent, _super);
        function WireContextRegistrationEvent(adapterToken, _b) {
            var setNewContext = _b.setNewContext, setDisconnectedCallback = _b.setDisconnectedCallback;
            var _this = _super.call(this, adapterToken, {
                bubbles: true,
                composed: true
            }) || this;
            defineProperties$1(_this, {
                setNewContext: {
                    value: setNewContext
                },
                setDisconnectedCallback: {
                    value: setDisconnectedCallback
                }
            });
            return _this;
        }
        return WireContextRegistrationEvent;
    }(CustomEvent));
    function createFieldDataCallback(vm, name) {
        var cmpFields = vm.cmpFields;
        return function (value) {
            if (value !== vm.cmpFields[name]) {
                // storing the value in the underlying storage
                cmpFields[name] = value;
                componentValueMutated(vm, name);
            }
        };
    }
    function createMethodDataCallback(vm, method) {
        return function (value) {
            // dispatching new value into the wired method
            invokeComponentCallback(vm, method, [value]);
        };
    }
    function createConfigWatcher(vm, wireDef, callbackWhenConfigIsReady) {
        var component = vm.component;
        var configCallback = wireDef.configCallback;
        var hasPendingConfig = false; // creating the reactive observer for reactive params when needed
        var ro = new ReactiveObserver(function () {
            if (hasPendingConfig === false) {
                hasPendingConfig = true; // collect new config in the micro-task
                Promise.resolve().then(function () {
                    hasPendingConfig = false; // resetting current reactive params
                    ro.reset(); // dispatching a new config due to a change in the configuration
                    callback();
                });
            }
        });
        var callback = function () {
            var config;
            ro.observe(function () { return config = configCallback(component); }); // eslint-disable-next-line lwc-internal/no-invalid-todo
            // TODO: dev-mode validation of config based on the adapter.configSchema
            // @ts-ignore it is assigned in the observe() callback
            callbackWhenConfigIsReady(config);
        };
        return callback;
    }
    function createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {
        var adapter = wireDef.adapter;
        var adapterContextToken = getAdapterToken(adapter);
        if (isUndefined$1(adapterContextToken)) {
            return; // no provider found, nothing to be done
        }
        var elm = vm.elm, renderer = vm.renderer, _b = vm.context, wiredConnecting = _b.wiredConnecting, wiredDisconnecting = _b.wiredDisconnecting; // waiting for the component to be connected to formally request the context via the token
        ArrayPush$1.call(wiredConnecting, function () {
            // This event is responsible for connecting the host element with another
            // element in the composed path that is providing contextual data. The provider
            // must be listening for a special dom event with the name corresponding to the value of
            // `adapterContextToken`, which will remain secret and internal to this file only to
            // guarantee that the linkage can be forged.
            var contextRegistrationEvent = new WireContextRegistrationEvent(adapterContextToken, {
                setNewContext: function (newContext) {
                    // eslint-disable-next-line lwc-internal/no-invalid-todo
                    // TODO: dev-mode validation of config based on the adapter.contextSchema
                    callbackWhenContextIsReady(newContext);
                },
                setDisconnectedCallback: function (disconnectCallback) {
                    // adds this callback into the disconnect bucket so it gets disconnected from parent
                    // the the element hosting the wire is disconnected
                    ArrayPush$1.call(wiredDisconnecting, disconnectCallback);
                }
            });
            renderer.dispatchEvent(elm, contextRegistrationEvent);
        });
    }
    function createConnector(vm, name, wireDef) {
        var method = wireDef.method, adapter = wireDef.adapter, configCallback = wireDef.configCallback, dynamic = wireDef.dynamic;
        var hasDynamicParams = dynamic.length > 0;
        var component = vm.component;
        var dataCallback = isUndefined$1(method) ? createFieldDataCallback(vm, name) : createMethodDataCallback(vm, method);
        var context;
        var connector; // Workaround to pass the component element associated to this wire adapter instance.
        defineProperty$1(dataCallback, DeprecatedWiredElementHost, {
            value: vm.elm
        });
        defineProperty$1(dataCallback, DeprecatedWiredParamsMeta, {
            value: dynamic
        });
        runWithBoundaryProtection(vm, vm, noop$3, function () {
            // job
            connector = new adapter(dataCallback);
        }, noop$3);
        var updateConnectorConfig = function (config) {
            // every time the config is recomputed due to tracking,
            // this callback will be invoked with the new computed config
            runWithBoundaryProtection(vm, vm, noop$3, function () {
                // job
                connector.update(config, context);
            }, noop$3);
        }; // Computes the current wire config and calls the update method on the wire adapter.
        // This initial implementation may change depending on the specific wire instance, if it has params, we will need
        // to observe changes in the next tick.
        var computeConfigAndUpdate = function () {
            updateConnectorConfig(configCallback(component));
        };
        if (hasDynamicParams) {
            // This wire has dynamic parameters: we wait for the component instance is created and its values set
            // in order to call the update(config) method.
            Promise.resolve().then(function () {
                computeConfigAndUpdate = createConfigWatcher(vm, wireDef, updateConnectorConfig);
                computeConfigAndUpdate();
            });
        }
        else {
            computeConfigAndUpdate();
        } // if the adapter needs contextualization, we need to watch for new context and push it alongside the config
        if (!isUndefined$1(adapter.contextSchema)) {
            createContextWatcher(vm, wireDef, function (newContext) {
                // every time the context is pushed into this component,
                // this callback will be invoked with the new computed context
                if (context !== newContext) {
                    context = newContext; // Note: when new context arrives, the config will be recomputed and pushed along side the new
                    // context, this is to preserve the identity characteristics, config should not have identity
                    // (ever), while context can have identity
                    computeConfigAndUpdate();
                }
            });
        } // @ts-ignore the boundary protection executes sync, connector is always defined
        return connector;
    }
    var AdapterToTokenMap = new Map();
    function getAdapterToken(adapter) {
        return AdapterToTokenMap.get(adapter);
    }
    function setAdapterToken(adapter, token) {
        AdapterToTokenMap.set(adapter, token);
    }
    function storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic) {
        // support for callable adapters
        if (adapter.adapter) {
            adapter = adapter.adapter;
        }
        var method = descriptor.value;
        var def = {
            adapter: adapter,
            method: method,
            configCallback: configCallback,
            dynamic: dynamic
        };
        WireMetaMap.set(descriptor, def);
    }
    function storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic) {
        // support for callable adapters
        if (adapter.adapter) {
            adapter = adapter.adapter;
        }
        var def = {
            adapter: adapter,
            configCallback: configCallback,
            dynamic: dynamic
        };
        WireMetaMap.set(descriptor, def);
    }
    function installWireAdapters(vm) {
        var context = vm.context, wire = vm.def.wire;
        var wiredConnecting = context.wiredConnecting = [];
        var wiredDisconnecting = context.wiredDisconnecting = [];
        var _loop_1 = function (fieldNameOrMethod) {
            var descriptor = wire[fieldNameOrMethod];
            var wireDef = WireMetaMap.get(descriptor);
            if (process.env.NODE_ENV !== 'production') {
                assert$1.invariant(wireDef, "Internal Error: invalid wire definition found.");
            }
            if (!isUndefined$1(wireDef)) {
                var adapterInstance_1 = createConnector(vm, fieldNameOrMethod, wireDef);
                ArrayPush$1.call(wiredConnecting, function () { return adapterInstance_1.connect(); });
                ArrayPush$1.call(wiredDisconnecting, function () { return adapterInstance_1.disconnect(); });
            }
        };
        for (var fieldNameOrMethod in wire) {
            _loop_1(fieldNameOrMethod);
        }
    }
    function connectWireAdapters(vm) {
        var wiredConnecting = vm.context.wiredConnecting;
        for (var i_19 = 0, len = wiredConnecting.length; i_19 < len; i_19 += 1) {
            wiredConnecting[i_19]();
        }
    }
    function disconnectWireAdapters(vm) {
        var wiredDisconnecting = vm.context.wiredDisconnecting;
        runWithBoundaryProtection(vm, vm, noop$3, function () {
            // job
            for (var i_20 = 0, len = wiredDisconnecting.length; i_20 < len; i_20 += 1) {
                wiredDisconnecting[i_20]();
            }
        }, noop$3);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function createContextProvider(adapter) {
        var adapterContextToken = getAdapterToken(adapter);
        if (!isUndefined$1(adapterContextToken)) {
            throw new Error("Adapter already has a context provider.");
        }
        adapterContextToken = guid();
        setAdapterToken(adapter, adapterContextToken);
        var providers = new WeakSet();
        return function (elm, options) {
            if (providers.has(elm)) {
                throw new Error("Adapter was already installed on " + elm + ".");
            }
            providers.add(elm);
            var consumerConnectedCallback = options.consumerConnectedCallback, consumerDisconnectedCallback = options.consumerDisconnectedCallback;
            elm.addEventListener(adapterContextToken, function (evt) {
                var setNewContext = evt.setNewContext, setDisconnectedCallback = evt.setDisconnectedCallback;
                var consumer = {
                    provide: function (newContext) {
                        setNewContext(newContext);
                    }
                };
                var disconnectCallback = function () {
                    if (!isUndefined$1(consumerDisconnectedCallback)) {
                        consumerDisconnectedCallback(consumer);
                    }
                };
                setDisconnectedCallback(disconnectCallback);
                consumerConnectedCallback(consumer);
                evt.stopImmediatePropagation();
            });
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function allows you to create a reactive readonly
     * membrane around any object value. This API is subject to change or
     * being removed.
     */
    function readonly(obj) {
        if (process.env.NODE_ENV !== 'production') {
            // TODO [#1292]: Remove the readonly decorator
            if (arguments.length !== 1) {
                assert$1.fail('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');
            }
        }
        return reactiveMembrane.getReadOnlyProxy(obj);
    }
    /* version: 1.7.7 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var globalStylesheets = create(null);
    var globalStylesheetsParentElement = document.head || document.body || document; // TODO [#0]: Evaluate how we can extract the `$shadowToken$` property name in a shared package
    // to avoid having to synchronize it between the different modules.
    var useSyntheticShadow = hasOwnProperty.call(Element.prototype, '$shadowToken$');
    var renderer = {
        ssr: false,
        syntheticShadow: useSyntheticShadow,
        createElement: function (tagName, namespace) {
            return isUndefined(namespace) ? document.createElement(tagName) : document.createElementNS(namespace, tagName);
        },
        createText: function (content) {
            return document.createTextNode(content);
        },
        insert: function (node, parent, anchor) {
            parent.insertBefore(node, anchor);
        },
        remove: function (node, parent) {
            parent.removeChild(node);
        },
        nextSibling: function (node) {
            return node.nextSibling;
        },
        attachShadow: function (element, options) {
            return element.attachShadow(options);
        },
        setText: function (node, content) {
            node.nodeValue = content;
        },
        getProperty: function (node, key) {
            return node[key];
        },
        setProperty: function (node, key, value) {
            if (process.env.NODE_ENV !== 'production') {
                if (node instanceof Element && !(key in node)) {
                    // TODO [#1297]: Move this validation to the compiler
                    assert.fail("Unknown public property \"" + key + "\" of element <" + node.tagName + ">. This is likely a typo on the corresponding attribute \"" + getAttrNameFromPropName(key) + "\".");
                }
            }
            node[key] = value;
        },
        getAttribute: function (element, name, namespace) {
            return isUndefined(namespace) ? element.getAttribute(name) : element.getAttributeNS(namespace, name);
        },
        setAttribute: function (element, name, value, namespace) {
            return isUndefined(namespace) ? element.setAttribute(name, value) : element.setAttributeNS(namespace, name, value);
        },
        removeAttribute: function (element, name, namespace) {
            if (isUndefined(namespace)) {
                element.removeAttribute(name);
            }
            else {
                element.removeAttributeNS(namespace, name);
            }
        },
        addEventListener: function (target, type, callback, options) {
            target.addEventListener(type, callback, options);
        },
        removeEventListener: function (target, type, callback, options) {
            target.removeEventListener(type, callback, options);
        },
        dispatchEvent: function (target, event) {
            return target.dispatchEvent(event);
        },
        getClassList: function (element) {
            return element.classList;
        },
        getStyleDeclaration: function (element) {
            // TODO [#0]: How to avoid this type casting? Shall we use a different type interface to
            // represent elements in the engine?
            return element.style;
        },
        getBoundingClientRect: function (element) {
            return element.getBoundingClientRect();
        },
        querySelector: function (element, selectors) {
            return element.querySelector(selectors);
        },
        querySelectorAll: function (element, selectors) {
            return element.querySelectorAll(selectors);
        },
        getElementsByTagName: function (element, tagNameOrWildCard) {
            return element.getElementsByTagName(tagNameOrWildCard);
        },
        getElementsByClassName: function (element, names) {
            return element.getElementsByClassName(names);
        },
        isConnected: function (node) {
            return node.isConnected;
        },
        insertGlobalStylesheet: function (content) {
            if (!isUndefined(globalStylesheets[content])) {
                return;
            }
            globalStylesheets[content] = true;
            var elm = document.createElement('style');
            elm.type = 'text/css';
            elm.textContent = content;
            globalStylesheetsParentElement.appendChild(elm);
        },
        assertInstanceOfHTMLElement: function (elm, msg) {
            assert.invariant(elm instanceof HTMLElement, msg);
        }
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This function builds a Web Component class from a LWC constructor so it can be
     * registered as a new element via customElements.define() at any given time.
     *
     * @deprecated since version 1.3.11
     *
     * @example
     * ```
     * import { buildCustomElementConstructor } from 'lwc';
     * import Foo from 'ns/foo';
     * const WC = buildCustomElementConstructor(Foo);
     * customElements.define('x-foo', WC);
     * const elm = document.createElement('x-foo');
     * ```
     */
    function deprecatedBuildCustomElementConstructor(Ctor) {
        if (process.env.NODE_ENV !== 'production') {
            /* eslint-disable-next-line no-console */
            console.warn('Deprecated function called: "buildCustomElementConstructor" function is deprecated and it will be removed.' + ("Use \"" + Ctor.name + ".CustomElementConstructor\" static property of the component constructor to access the corresponding custom element constructor instead."));
        }
        return Ctor.CustomElementConstructor;
    }
    function buildCustomElementConstructor(Ctor) {
        var _a;
        var def = getComponentInternalDef(Ctor); // generating the hash table for attributes to avoid duplicate fields and facilitate validation
        // and false positives in case of inheritance.
        var attributeToPropMap = create(null);
        for (var propName in def.props) {
            attributeToPropMap[getAttrNameFromPropName(propName)] = propName;
        }
        return _a = /** @class */ (function (_super) {
            __extends(_a, _super);
            function _a() {
                var _this = _super.call(this) || this;
                createVM(_this, def, {
                    mode: 'open',
                    owner: null,
                    tagName: _this.tagName,
                    renderer: renderer
                });
                return _this;
            }
            _a.prototype.connectedCallback = function () {
                connectRootElement(this);
            };
            _a.prototype.disconnectedCallback = function () {
                disconnectRootElement(this);
            };
            _a.prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {
                if (oldValue === newValue) {
                    // Ignore same values.
                    return;
                }
                var propName = attributeToPropMap[attrName];
                if (isUndefined(propName)) {
                    // Ignore unknown attributes.
                    return;
                }
                if (!isAttributeLocked(this, attrName)) {
                    // Ignore changes triggered by the engine itself during:
                    // * diffing when public props are attempting to reflect to the DOM
                    // * component via `this.setAttribute()`, should never update the prop
                    // Both cases, the setAttribute call is always wrapped by the unlocking of the
                    // attribute to be changed
                    return;
                } // Reflect attribute change to the corresponding property when changed from outside.
                this[propName] = newValue;
            };
            return _a;
        }(def.bridge)), // Specify attributes for which we want to reflect changes back to their corresponding
            // properties via attributeChangedCallback.
            _a.observedAttributes = keys(attributeToPropMap), _a;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ConnectingSlot = createHiddenField('connecting', 'engine');
    var DisconnectingSlot = createHiddenField('disconnecting', 'engine');
    function callNodeSlot(node, slot) {
        if (process.env.NODE_ENV !== 'production') {
            assert.isTrue(node, "callNodeSlot() should not be called for a non-object");
        }
        var fn = getHiddenField(node, slot);
        if (!isUndefined(fn)) {
            fn(node);
        }
        return node; // for convenience
    } // Monkey patching Node methods to be able to detect the insertions and removal of root elements
    // created via createElement.
    var _l = Node.prototype, appendChild = _l.appendChild, insertBefore = _l.insertBefore, removeChild = _l.removeChild, replaceChild = _l.replaceChild;
    assign(Node.prototype, {
        appendChild: function (newChild) {
            var appendedNode = appendChild.call(this, newChild);
            return callNodeSlot(appendedNode, ConnectingSlot);
        },
        insertBefore: function (newChild, referenceNode) {
            var insertedNode = insertBefore.call(this, newChild, referenceNode);
            return callNodeSlot(insertedNode, ConnectingSlot);
        },
        removeChild: function (oldChild) {
            var removedNode = removeChild.call(this, oldChild);
            return callNodeSlot(removedNode, DisconnectingSlot);
        },
        replaceChild: function (newChild, oldChild) {
            var replacedNode = replaceChild.call(this, newChild, oldChild);
            callNodeSlot(replacedNode, DisconnectingSlot);
            callNodeSlot(newChild, ConnectingSlot);
            return replacedNode;
        }
    });
    /**
     * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly
     * difference that in the options, you can pass the `is` property set to a Constructor instead of
     * just a string value. The intent is to allow the creation of an element controlled by LWC without
     * having to register the element as a custom element.
     *
     * @example
     * ```
     * const el = createElement('x-foo', { is: FooCtor });
     * ```
     */
    function createElement(sel, options) {
        if (!isObject$1(options) || isNull(options)) {
            throw new TypeError("\"createElement\" function expects an object as second parameter but received \"" + toString(options) + "\".");
        }
        var Ctor = options.is;
        if (!isFunction(Ctor)) {
            throw new TypeError("\"createElement\" function expects an \"is\" option with a valid component constructor.");
        }
        var element = document.createElement(sel); // There is a possibility that a custom element is registered under tagName, in which case, the
        // initialization is already carry on, and there is nothing else to do here.
        if (!isUndefined(getAssociatedVMIfPresent(element))) {
            return element;
        }
        var def = getComponentInternalDef(Ctor);
        setElementProto(element, def);
        createVM(element, def, {
            tagName: sel,
            mode: options.mode !== 'closed' ? 'open' : 'closed',
            owner: null,
            renderer: renderer
        });
        setHiddenField(element, ConnectingSlot, connectRootElement);
        setHiddenField(element, DisconnectingSlot, disconnectRootElement);
        return element;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function provides access to the component constructor, given an HTMLElement.
     * This API is subject to change or being removed.
     */
    function getComponentConstructor(elm) {
        var ctor = null;
        if (elm instanceof HTMLElement) {
            var vm = getAssociatedVMIfPresent(elm);
            if (!isUndefined(vm)) {
                ctor = vm.def.ctor;
            }
        }
        return ctor;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function detects whether or not a Node is controlled by a LWC template. This
     * API is subject to change or being removed.
     */
    function isNodeFromTemplate(node) {
        if (isFalse$1(node instanceof Node)) {
            return false;
        } // TODO [#1250]: skipping the shadowRoot instances itself makes no sense, we need to revisit
        // this with locker
        if (node instanceof ShadowRoot) {
            return false;
        }
        if (useSyntheticShadow) {
            // TODO [#1252]: old behavior that is still used by some pieces of the platform,
            // specifically, nodes inserted manually on places where `lwc:dom="manual"` directive is not
            // used, will be considered global elements.
            if (isUndefined(node.$shadowResolver$)) {
                return false;
            }
        }
        var root = node.getRootNode();
        return root instanceof ShadowRoot;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ComponentConstructorToCustomElementConstructorMap = new Map();
    function getCustomElementConstructor(Ctor) {
        if (Ctor === BaseLightningElement) {
            throw new TypeError("Invalid Constructor. LightningElement base class can't be claimed as a custom element.");
        }
        var ce = ComponentConstructorToCustomElementConstructorMap.get(Ctor);
        if (isUndefined(ce)) {
            ce = buildCustomElementConstructor(Ctor);
            ComponentConstructorToCustomElementConstructorMap.set(Ctor, ce);
        }
        return ce;
    }
    /**
     * This static getter builds a Web Component class from a LWC constructor so it can be registered
     * as a new element via customElements.define() at any given time. E.g.:
     *
     *      import Foo from 'ns/foo';
     *      customElements.define('x-foo', Foo.CustomElementConstructor);
     *      const elm = document.createElement('x-foo');
     *
     */
    defineProperty(BaseLightningElement, 'CustomElementConstructor', {
        get: function () {
            return getCustomElementConstructor(this);
        }
    });
    freeze(BaseLightningElement);
    seal(BaseLightningElement.prototype);
    /* version: 1.7.7 */

    exports.LightningElement = BaseLightningElement;
    exports.api = api;
    exports.buildCustomElementConstructor = deprecatedBuildCustomElementConstructor;
    exports.createContextProvider = createContextProvider;
    exports.createElement = createElement;
    exports.getComponentConstructor = getComponentConstructor;
    exports.getComponentDef = getComponentDef;
    exports.isComponentConstructor = isComponentConstructor;
    exports.isNodeFromTemplate = isNodeFromTemplate;
    exports.readonly = readonly;
    exports.register = register;
    exports.registerComponent = registerComponent;
    exports.registerDecorators = registerDecorators;
    exports.registerTemplate = registerTemplate;
    exports.sanitizeAttribute = sanitizeAttribute;
    exports.setFeatureFlag = setFeatureFlag;
    exports.setFeatureFlagForTest = setFeatureFlagForTest;
    exports.track = track;
    exports.unwrap = unwrap$1;
    exports.wire = wire;

    return exports;

}({}));
