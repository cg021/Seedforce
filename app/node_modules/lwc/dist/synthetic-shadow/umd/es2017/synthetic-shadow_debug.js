(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
}((function () { 'use strict';

  /* proxy-compat-disable */
  function invariant(value, msg) {
    if (!value) {
      throw new Error(`Invariant Violation: ${msg}`);
    }
  }

  function isTrue(value, msg) {
    if (!value) {
      throw new Error(`Assert Violation: ${msg}`);
    }
  }

  function isFalse(value, msg) {
    if (value) {
      throw new Error(`Assert Violation: ${msg}`);
    }
  }

  function fail(msg) {
    throw new Error(msg);
  }

  var assert = Object.freeze({
    __proto__: null,
    invariant: invariant,
    isTrue: isTrue,
    isFalse: isFalse,
    fail: fail
  });
  const {
    assign,
    create,
    defineProperties,
    defineProperty,
    freeze,
    getOwnPropertyDescriptor,
    getOwnPropertyNames,
    getPrototypeOf,
    hasOwnProperty,
    isFrozen,
    keys,
    seal,
    setPrototypeOf
  } = Object;
  const {
    filter: ArrayFilter,
    find: ArrayFind,
    indexOf: ArrayIndexOf,
    join: ArrayJoin,
    map: ArrayMap,
    push: ArrayPush,
    reduce: ArrayReduce,
    reverse: ArrayReverse,
    slice: ArraySlice,
    splice: ArraySplice,
    unshift: ArrayUnshift,
    forEach
  } = Array.prototype;
  const {
    charCodeAt: StringCharCodeAt,
    replace: StringReplace,
    slice: StringSlice,
    toLowerCase: StringToLowerCase
  } = String.prototype;

  function isUndefined(obj) {
    return obj === undefined;
  }

  function isNull(obj) {
    return obj === null;
  }

  function isTrue$1(obj) {
    return obj === true;
  }

  function isFalse$1(obj) {
    return obj === false;
  }

  function isFunction(obj) {
    return typeof obj === 'function';
  }

  function isObject(obj) {
    return typeof obj === 'object';
  }

  function getPropertyDescriptor(o, p) {
    do {
      const d = getOwnPropertyDescriptor(o, p);

      if (!isUndefined(d)) {
        return d;
      }

      o = getPrototypeOf(o);
    } while (o !== null);
  }
  const AriaPropertyNames = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
  const AttrNameToPropNameMap = create(null);
  const PropNameToAttrNameMap = create(null);
  forEach.call(AriaPropertyNames, propName => {
    const attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, 'aria-'));
    AttrNameToPropNameMap[attrName] = propName;
    PropNameToAttrNameMap[propName] = attrName;
  });

  const _globalThis = function () {
    if (typeof globalThis === 'object') {
      return globalThis;
    }

    let _globalThis;

    try {
      Object.defineProperty(Object.prototype, '__magic__', {
        get: function () {
          return this;
        },
        configurable: true
      });
      _globalThis = __magic__;
      delete Object.prototype.__magic__;
    } catch (ex) {} finally {
      if (typeof _globalThis === 'undefined') {
        _globalThis = window;
      }
    }

    return _globalThis;
  }();

  const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';

  function createHiddenField(key, namespace) {
    return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${namespace}-${key}$$`;
  }

  const hiddenFieldsMap = new WeakMap();

  function setHiddenField(o, field, value) {
    let valuesByField = hiddenFieldsMap.get(o);

    if (isUndefined(valuesByField)) {
      valuesByField = create(null);
      hiddenFieldsMap.set(o, valuesByField);
    }

    valuesByField[field] = value;
  }

  function getHiddenField(o, field) {
    const valuesByField = hiddenFieldsMap.get(o);

    if (!isUndefined(valuesByField)) {
      return valuesByField[field];
    }
  }

  const HTML_ATTRIBUTES_TO_PROPERTY = {
    accesskey: 'accessKey',
    readonly: 'readOnly',
    tabindex: 'tabIndex',
    bgcolor: 'bgColor',
    colspan: 'colSpan',
    rowspan: 'rowSpan',
    contenteditable: 'contentEditable',
    crossorigin: 'crossOrigin',
    datetime: 'dateTime',
    formaction: 'formAction',
    ismap: 'isMap',
    maxlength: 'maxLength',
    minlength: 'minLength',
    novalidate: 'noValidate',
    usemap: 'useMap',
    for: 'htmlFor'
  };
  keys(HTML_ATTRIBUTES_TO_PROPERTY).forEach(attrName => {});
  const {
    DOCUMENT_POSITION_CONTAINED_BY,
    DOCUMENT_POSITION_CONTAINS,
    DOCUMENT_POSITION_PRECEDING,
    DOCUMENT_POSITION_FOLLOWING,
    ELEMENT_NODE,
    TEXT_NODE,
    CDATA_SECTION_NODE,
    PROCESSING_INSTRUCTION_NODE,
    COMMENT_NODE,
    DOCUMENT_FRAGMENT_NODE
  } = Node;
  const {
    appendChild,
    cloneNode,
    compareDocumentPosition,
    insertBefore,
    removeChild,
    replaceChild,
    hasChildNodes
  } = Node.prototype;
  const {
    contains
  } = HTMLElement.prototype;
  const firstChildGetter = getOwnPropertyDescriptor(Node.prototype, 'firstChild').get;
  const lastChildGetter = getOwnPropertyDescriptor(Node.prototype, 'lastChild').get;
  const textContentGetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
  const parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
  const ownerDocumentGetter = getOwnPropertyDescriptor(Node.prototype, 'ownerDocument').get;
  const parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement') ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get;
  const textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;
  const childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes') ? getOwnPropertyDescriptor(Node.prototype, 'childNodes').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get;
  const isConnected = hasOwnProperty.call(Node.prototype, 'isConnected') ? getOwnPropertyDescriptor(Node.prototype, 'isConnected').get : function () {
    const doc = ownerDocumentGetter.call(this);
    return doc === null || (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  };
  const {
    addEventListener,
    getAttribute,
    getBoundingClientRect,
    getElementsByTagName,
    getElementsByTagNameNS,
    hasAttribute,
    querySelector,
    querySelectorAll,
    removeAttribute,
    removeEventListener,
    setAttribute
  } = Element.prototype;
  const attachShadow = hasOwnProperty.call(Element.prototype, 'attachShadow') ? Element.prototype.attachShadow : () => {
    throw new TypeError('attachShadow() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill and use Lightning Web Components');
  };
  const childElementCountGetter = getOwnPropertyDescriptor(Element.prototype, 'childElementCount').get;
  const firstElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').get;
  const lastElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'lastElementChild').get;
  const innerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'innerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML');
  const innerHTMLGetter = innerHTMLDescriptor.get;
  const innerHTMLSetter = innerHTMLDescriptor.set;
  const outerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'outerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML');
  const outerHTMLGetter = outerHTMLDescriptor.get;
  const outerHTMLSetter = outerHTMLDescriptor.set;
  const tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
  const tabIndexDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex');
  const tabIndexGetter = tabIndexDescriptor.get;
  const tabIndexSetter = tabIndexDescriptor.set;
  const matches = hasOwnProperty.call(Element.prototype, 'matches') ? Element.prototype.matches : Element.prototype.msMatchesSelector;
  const childrenGetter = hasOwnProperty.call(Element.prototype, 'children') ? getOwnPropertyDescriptor(Element.prototype, 'children').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get;
  const {
    getElementsByClassName
  } = HTMLElement.prototype;
  const shadowRootGetter = hasOwnProperty.call(Element.prototype, 'shadowRoot') ? getOwnPropertyDescriptor(Element.prototype, 'shadowRoot').get : () => null;
  let assignedNodes, assignedElements;

  if (typeof HTMLSlotElement !== 'undefined') {
    assignedNodes = HTMLSlotElement.prototype.assignedNodes;
    assignedElements = HTMLSlotElement.prototype.assignedElements;
  } else {
    assignedNodes = () => {
      throw new TypeError("assignedNodes() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };

    assignedElements = () => {
      throw new TypeError("assignedElements() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
    };
  }

  const dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent;
  const eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
  const eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
  const focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;
  const DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
  const elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint') ? Document.prototype.elementFromPoint : Document.prototype.msElementFromPoint;
  const defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
  const {
    createComment,
    querySelectorAll: querySelectorAll$1,
    getElementById,
    getElementsByClassName: getElementsByClassName$1,
    getElementsByTagName: getElementsByTagName$1,
    getElementsByTagNameNS: getElementsByTagNameNS$1
  } = Document.prototype;
  const {
    getElementsByName
  } = HTMLDocument.prototype;
  const {
    addEventListener: windowAddEventListener,
    removeEventListener: windowRemoveEventListener
  } = window;
  const MO = MutationObserver;
  const MutationObserverObserve = MO.prototype.observe;

  function detect() {
    return typeof HTMLSlotElement === 'undefined';
  }

  const {
    createElement
  } = Document.prototype;
  const CHAR_S = 115;
  const CHAR_L = 108;
  const CHAR_O = 111;
  const CHAR_T = 116;

  function apply() {
    class HTMLSlotElement {}

    setPrototypeOf(HTMLSlotElement, HTMLElement.constructor);
    setPrototypeOf(HTMLSlotElement.prototype, HTMLElement.prototype);
    Window.prototype.HTMLSlotElement = HTMLSlotElement;
    defineProperty(Document.prototype, 'createElement', {
      value: function (tagName, _options) {
        const elm = createElement.apply(this, ArraySlice.call(arguments));

        if (tagName.length === 4 && StringCharCodeAt.call(tagName, 0) === CHAR_S && StringCharCodeAt.call(tagName, 1) === CHAR_L && StringCharCodeAt.call(tagName, 2) === CHAR_O && StringCharCodeAt.call(tagName, 3) === CHAR_T) {
          setPrototypeOf(elm, HTMLSlotElement.prototype);
        }

        return elm;
      }
    });
  }

  if (detect()) {
    apply();
  }

  const {
    assign: assign$1,
    create: create$1,
    defineProperties: defineProperties$1,
    defineProperty: defineProperty$1,
    freeze: freeze$1,
    getOwnPropertyDescriptor: getOwnPropertyDescriptor$1,
    getOwnPropertyNames: getOwnPropertyNames$1,
    getPrototypeOf: getPrototypeOf$1,
    hasOwnProperty: hasOwnProperty$1,
    isFrozen: isFrozen$1,
    keys: keys$1,
    seal: seal$1,
    setPrototypeOf: setPrototypeOf$1
  } = Object;
  const {
    filter: ArrayFilter$1,
    find: ArrayFind$1,
    indexOf: ArrayIndexOf$1,
    join: ArrayJoin$1,
    map: ArrayMap$1,
    push: ArrayPush$1,
    reduce: ArrayReduce$1,
    reverse: ArrayReverse$1,
    slice: ArraySlice$1,
    splice: ArraySplice$1,
    unshift: ArrayUnshift$1,
    forEach: forEach$1
  } = Array.prototype;
  const {
    charCodeAt: StringCharCodeAt$1,
    replace: StringReplace$1,
    slice: StringSlice$1,
    toLowerCase: StringToLowerCase$1
  } = String.prototype;
  const AriaPropertyNames$1 = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
  const AttrNameToPropNameMap$1 = create$1(null);
  const PropNameToAttrNameMap$1 = create$1(null);
  forEach$1.call(AriaPropertyNames$1, propName => {
    const attrName = StringToLowerCase$1.call(StringReplace$1.call(propName, /^aria/, 'aria-'));
    AttrNameToPropNameMap$1[attrName] = propName;
    PropNameToAttrNameMap$1[propName] = attrName;
  });

  const _globalThis$1 = function () {
    if (typeof globalThis === 'object') {
      return globalThis;
    }

    let _globalThis;

    try {
      Object.defineProperty(Object.prototype, '__magic__', {
        get: function () {
          return this;
        },
        configurable: true
      });
      _globalThis = __magic__;
      delete Object.prototype.__magic__;
    } catch (ex) {} finally {
      if (typeof _globalThis === 'undefined') {
        _globalThis = window;
      }
    }

    return _globalThis;
  }();

  const hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';
  const HTML_ATTRIBUTES_TO_PROPERTY$1 = {
    accesskey: 'accessKey',
    readonly: 'readOnly',
    tabindex: 'tabIndex',
    bgcolor: 'bgColor',
    colspan: 'colSpan',
    rowspan: 'rowSpan',
    contenteditable: 'contentEditable',
    crossorigin: 'crossOrigin',
    datetime: 'dateTime',
    formaction: 'formAction',
    ismap: 'isMap',
    maxlength: 'maxLength',
    minlength: 'minLength',
    novalidate: 'noValidate',
    usemap: 'useMap',
    for: 'htmlFor'
  };
  keys$1(HTML_ATTRIBUTES_TO_PROPERTY$1).forEach(attrName => {});

  if (!_globalThis$1.lwcRuntimeFlags) {
    Object.defineProperty(_globalThis$1, 'lwcRuntimeFlags', {
      value: create$1(null)
    });
  }

  const runtimeFlags = _globalThis$1.lwcRuntimeFlags;

  function getOwnerDocument(node) {
    const doc = ownerDocumentGetter.call(node);
    return doc === null ? node : doc;
  }

  function getOwnerWindow(node) {
    const doc = getOwnerDocument(node);
    const win = defaultViewGetter.call(doc);

    if (win === null) {
      throw new TypeError();
    }

    return win;
  }

  let skipGlobalPatching;

  function isGlobalPatchingSkipped(node) {
    if (isUndefined(skipGlobalPatching)) {
      const ownerDocument = getOwnerDocument(node);
      skipGlobalPatching = ownerDocument.body && getAttribute.call(ownerDocument.body, 'data-global-patching-bypass') === 'temporary-bypass';
    }

    return isTrue$1(skipGlobalPatching);
  }

  function arrayFromCollection(collection) {
    const size = collection.length;
    const cloned = [];

    if (size > 0) {
      for (let i = 0; i < size; i++) {
        cloned[i] = collection[i];
      }
    }

    return cloned;
  }

  function pathComposer(startNode, composed) {
    const composedPath = [];
    let current = startNode;
    const startRoot = startNode instanceof Window ? startNode : startNode.getRootNode();

    while (!isNull(current)) {
      composedPath.push(current);
      let assignedSlot = null;

      if (current instanceof Element) {
        assignedSlot = current.assignedSlot;
      }

      if (!isNull(assignedSlot)) {
        current = assignedSlot;
      } else if (current instanceof ShadowRoot && (composed || current !== startRoot)) {
        current = current.host;
      } else {
        current = current.parentNode;
      }
    }

    let doc;

    if (startNode instanceof Window) {
      doc = startNode.document;
    } else {
      doc = getOwnerDocument(startNode);
    }

    if (composedPath[composedPath.length - 1] === doc) {
      composedPath.push(window);
    }

    return composedPath;
  }

  function retarget(refNode, path) {
    if (isNull(refNode)) {
      return null;
    }

    const refNodePath = pathComposer(refNode, true);
    const p$ = path;

    for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
      ancestor = p$[i];
      root = ancestor instanceof Window ? ancestor : ancestor.getRootNode();

      if (root !== lastRoot) {
        rootIdx = refNodePath.indexOf(root);
        lastRoot = root;
      }

      if (!(root instanceof SyntheticShadowRoot) || !isUndefined(rootIdx) && rootIdx > -1) {
        return ancestor;
      }
    }

    return null;
  }

  var EventListenerContext;

  (function (EventListenerContext) {
    EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
    EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
  })(EventListenerContext || (EventListenerContext = {}));

  const eventToContextMap = new WeakMap();

  function isChildNode(root, node) {
    return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);
  }

  const GET_ROOT_NODE_CONFIG_FALSE = {
    composed: false
  };

  function getRootNodeHost(node, options) {
    let rootNode = node.getRootNode(options);

    if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
      rootNode = getHost(rootNode);
    }

    return rootNode;
  }

  function targetGetter() {
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    const originalTarget = eventTargetGetter.call(this);
    const composedPath = pathComposer(originalTarget, this.composed);
    const doc = getOwnerDocument(originalTarget);

    if (!(originalCurrentTarget instanceof Node)) {
      if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }

      return retarget(doc, composedPath);
    } else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
      if (isUndefined(getNodeOwnerKey(originalTarget))) {
        return originalTarget;
      }

      return retarget(doc, composedPath);
    }

    const eventContext = eventToContextMap.get(this);
    const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
    return retarget(currentTarget, composedPath);
  }

  function composedPathValue() {
    const originalTarget = eventTargetGetter.call(this);
    const originalCurrentTarget = eventCurrentTargetGetter.call(this);
    return isNull(originalCurrentTarget) ? [] : pathComposer(originalTarget, this.composed);
  }

  function patchEvent(event) {
    if (eventToContextMap.has(event)) {
      return;
    }

    defineProperties(event, {
      target: {
        get: targetGetter,
        enumerable: true,
        configurable: true
      },
      composedPath: {
        value: composedPathValue,
        writable: true,
        enumerable: true,
        configurable: true
      },
      srcElement: {
        get: targetGetter,
        enumerable: true,
        configurable: true
      },
      path: {
        get: composedPathValue,
        enumerable: true,
        configurable: true
      }
    });
    const originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');

    if (!isUndefined(originalRelatedTargetDescriptor)) {
      const relatedTargetGetter = originalRelatedTargetDescriptor.get;
      defineProperty(event, 'relatedTarget', {
        get() {
          const eventContext = eventToContextMap.get(this);
          const originalCurrentTarget = eventCurrentTargetGetter.call(this);
          const relatedTarget = relatedTargetGetter.call(this);

          if (isNull(relatedTarget)) {
            return null;
          }

          const currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
          return retarget(currentTarget, pathComposer(relatedTarget, true));
        },

        enumerable: true,
        configurable: true
      });
    }

    eventToContextMap.set(event, 0);
  }

  const customElementToWrappedListeners = new WeakMap();

  function getEventMap(elm) {
    let listenerInfo = customElementToWrappedListeners.get(elm);

    if (isUndefined(listenerInfo)) {
      listenerInfo = create(null);
      customElementToWrappedListeners.set(elm, listenerInfo);
    }

    return listenerInfo;
  }

  const shadowRootEventListenerMap = new WeakMap();

  function getWrappedShadowRootListener(sr, listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }

    let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);

    if (isUndefined(shadowRootWrappedListener)) {
      shadowRootWrappedListener = function (event) {
        const {
          composed
        } = event;
        const target = eventTargetGetter.call(event);
        const currentTarget = eventCurrentTargetGetter.call(event);

        if (target !== currentTarget) {
          const rootNode = getRootNodeHost(target, {
            composed
          });

          if (isChildNode(rootNode, currentTarget) || composed === false && rootNode === currentTarget) {
            listener.call(sr, event);
          }
        }
      };

      shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;

      shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
    }

    return shadowRootWrappedListener;
  }

  const customElementEventListenerMap = new WeakMap();

  function getWrappedCustomElementListener(elm, listener) {
    if (!isFunction(listener)) {
      throw new TypeError();
    }

    let customElementWrappedListener = customElementEventListenerMap.get(listener);

    if (isUndefined(customElementWrappedListener)) {
      customElementWrappedListener = function (event) {
        if (isValidEventForCustomElement(event)) {
          listener.call(elm, event);
        }
      };

      customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;

      customElementEventListenerMap.set(listener, customElementWrappedListener);
    }

    return customElementWrappedListener;
  }

  function domListener(evt) {
    patchEvent(evt);
    let immediatePropagationStopped = false;
    let propagationStopped = false;
    const {
      type,
      stopImmediatePropagation,
      stopPropagation
    } = evt;
    const currentTarget = eventCurrentTargetGetter.call(evt);
    const listenerMap = getEventMap(currentTarget);
    const listeners = listenerMap[type];
    defineProperty(evt, 'stopImmediatePropagation', {
      value() {
        immediatePropagationStopped = true;
        stopImmediatePropagation.call(evt);
      },

      writable: true,
      enumerable: true,
      configurable: true
    });
    defineProperty(evt, 'stopPropagation', {
      value() {
        propagationStopped = true;
        stopPropagation.call(evt);
      },

      writable: true,
      enumerable: true,
      configurable: true
    });
    const bookkeeping = ArraySlice.call(listeners);

    function invokeListenersByPlacement(placement) {
      forEach.call(bookkeeping, listener => {
        if (isFalse$1(immediatePropagationStopped) && listener.placement === placement) {
          if (ArrayIndexOf.call(listeners, listener) !== -1) {
            listener.call(undefined, evt);
          }
        }
      });
    }

    eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
    invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);

    if (isFalse$1(immediatePropagationStopped) && isFalse$1(propagationStopped)) {
      eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
      invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
    }

    eventToContextMap.set(evt, 0);
  }

  function attachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let cmpEventHandlers = listenerMap[type];

    if (isUndefined(cmpEventHandlers)) {
      cmpEventHandlers = listenerMap[type] = [];
    }

    if (cmpEventHandlers.length === 0) {
      addEventListener.call(elm, type, domListener);
    }

    ArrayPush.call(cmpEventHandlers, wrappedListener);
  }

  function detachDOMListener(elm, type, wrappedListener) {
    const listenerMap = getEventMap(elm);
    let p;
    let listeners;

    if (!isUndefined(listeners = listenerMap[type]) && (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
      ArraySplice.call(listeners, p, 1);

      if (listeners.length === 0) {
        removeEventListener.call(elm, type, domListener);
      }
    }
  }

  function isValidEventForCustomElement(event) {
    const target = eventTargetGetter.call(event);
    const currentTarget = eventCurrentTargetGetter.call(event);
    const {
      composed
    } = event;
    return composed === true || target === currentTarget || isChildNode(getRootNodeHost(target, GET_ROOT_NODE_CONFIG_FALSE), currentTarget);
  }

  function addCustomElementEventListener(elm, type, listener, _options) {

    const wrappedListener = getWrappedCustomElementListener(elm, listener);
    attachDOMListener(elm, type, wrappedListener);
  }

  function removeCustomElementEventListener(elm, type, listener, _options) {
    const wrappedListener = getWrappedCustomElementListener(elm, listener);
    detachDOMListener(elm, type, wrappedListener);
  }

  function addShadowRootEventListener(sr, type, listener, _options) {

    const elm = getHost(sr);
    const wrappedListener = getWrappedShadowRootListener(sr, listener);
    attachDOMListener(elm, type, wrappedListener);
  }

  function removeShadowRootEventListener(sr, type, listener, _options) {
    const elm = getHost(sr);
    const wrappedListener = getWrappedShadowRootListener(sr, listener);
    detachDOMListener(elm, type, wrappedListener);
  }

  function getTextContent(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE:
        {
          const childNodes = getFilteredChildNodes(node);
          let content = '';

          for (let i = 0, len = childNodes.length; i < len; i += 1) {
            const currentNode = childNodes[i];

            if (currentNode.nodeType !== COMMENT_NODE) {
              content += getTextContent(currentNode);
            }
          }

          return content;
        }

      default:
        return node.nodeValue;
    }
  }

  const Items = createHiddenField('StaticNodeListItems', 'synthetic-shadow');

  function StaticNodeList() {
    throw new TypeError('Illegal constructor');
  }

  StaticNodeList.prototype = create(NodeList.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticNodeList
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(index) {
        return this[index];
      }

    },
    length: {
      enumerable: true,
      configurable: true,

      get() {
        return getHiddenField(this, Items).length;
      }

    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(cb, thisArg) {
        forEach.call(getHiddenField(this, Items), cb, thisArg);
      }

    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items), (v, i) => [i, v]);
      }

    },
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items), (_v, i) => i);
      }

    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return getHiddenField(this, Items);
      }

    },
    [Symbol.iterator]: {
      writable: true,
      configurable: true,

      value() {
        let nextIndex = 0;
        return {
          next: () => {
            const items = getHiddenField(this, Items);
            return nextIndex < items.length ? {
              value: items[nextIndex++],
              done: false
            } : {
              done: true
            };
          }
        };
      }

    },
    [Symbol.toStringTag]: {
      configurable: true,

      get() {
        return 'NodeList';
      }

    },
    toString: {
      writable: true,
      configurable: true,

      value() {
        return '[object NodeList]';
      }

    }
  });
  setPrototypeOf(StaticNodeList, NodeList);

  function createStaticNodeList(items) {
    const nodeList = create(StaticNodeList.prototype);
    setHiddenField(nodeList, Items, items);
    forEach.call(items, (item, index) => {
      defineProperty(nodeList, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return nodeList;
  }

  const Items$1 = createHiddenField('StaticHTMLCollectionItems', 'synthetic-shadow');

  function StaticHTMLCollection() {
    throw new TypeError('Illegal constructor');
  }

  StaticHTMLCollection.prototype = create(HTMLCollection.prototype, {
    constructor: {
      writable: true,
      configurable: true,
      value: StaticHTMLCollection
    },
    item: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(index) {
        return this[index];
      }

    },
    length: {
      enumerable: true,
      configurable: true,

      get() {
        return getHiddenField(this, Items$1).length;
      }

    },
    namedItem: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(name) {
        if (name === '') {
          return null;
        }

        const items = getHiddenField(this, Items$1);

        for (let i = 0, len = items.length; i < len; i++) {
          const item = items[len];

          if (name === getAttribute.call(item, 'id') || name === getAttribute.call(item, 'name')) {
            return item;
          }
        }

        return null;
      }

    },
    forEach: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(cb, thisArg) {
        forEach.call(getHiddenField(this, Items$1), cb, thisArg);
      }

    },
    entries: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items$1), (v, i) => [i, v]);
      }

    },
    keys: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return ArrayMap.call(getHiddenField(this, Items$1), (v, i) => i);
      }

    },
    values: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        return getHiddenField(this, Items$1);
      }

    },
    [Symbol.iterator]: {
      writable: true,
      configurable: true,

      value() {
        let nextIndex = 0;
        return {
          next: () => {
            const items = getHiddenField(this, Items$1);
            return nextIndex < items.length ? {
              value: items[nextIndex++],
              done: false
            } : {
              done: true
            };
          }
        };
      }

    },
    [Symbol.toStringTag]: {
      configurable: true,

      get() {
        return 'HTMLCollection';
      }

    },
    toString: {
      writable: true,
      configurable: true,

      value() {
        return '[object HTMLCollection]';
      }

    }
  });
  setPrototypeOf(StaticHTMLCollection, HTMLCollection);

  function createStaticHTMLCollection(items) {
    const collection = create(StaticHTMLCollection.prototype);
    setHiddenField(collection, Items$1, items);
    forEach.call(items, (item, index) => {
      defineProperty(collection, index, {
        value: item,
        enumerable: true,
        configurable: true
      });
    });
    return collection;
  }

  function getInnerHTML(node) {
    let s = '';
    const childNodes = getFilteredChildNodes(node);

    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      s += getOuterHTML(childNodes[i]);
    }

    return s;
  }

  const escapeAttrRegExp = /[&\u00A0"]/g;
  const escapeDataRegExp = /[&\u00A0<>]/g;
  const {
    replace,
    toLowerCase
  } = String.prototype;

  function escapeReplace(c) {
    switch (c) {
      case '&':
        return '&amp;';

      case '<':
        return '&lt;';

      case '>':
        return '&gt;';

      case '"':
        return '&quot;';

      case '\u00A0':
        return '&nbsp;';

      default:
        return '';
    }
  }

  function escapeAttr(s) {
    return replace.call(s, escapeAttrRegExp, escapeReplace);
  }

  function escapeData(s) {
    return replace.call(s, escapeDataRegExp, escapeReplace);
  }

  const voidElements = new Set(['AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR']);
  const plaintextParents = new Set(['STYLE', 'SCRIPT', 'XMP', 'IFRAME', 'NOEMBED', 'NOFRAMES', 'PLAINTEXT', 'NOSCRIPT']);

  function getOuterHTML(node) {
    switch (node.nodeType) {
      case ELEMENT_NODE:
        {
          const {
            attributes: attrs
          } = node;
          const tagName = tagNameGetter.call(node);
          let s = '<' + toLowerCase.call(tagName);

          for (let i = 0, attr; attr = attrs[i]; i++) {
            s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
          }

          s += '>';

          if (voidElements.has(tagName)) {
            return s;
          }

          return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
        }

      case TEXT_NODE:
        {
          const {
            data,
            parentNode
          } = node;

          if (parentNode instanceof Element && plaintextParents.has(tagNameGetter.call(parentNode))) {
            return data;
          }

          return escapeData(data);
        }

      case CDATA_SECTION_NODE:
        {
          return `<!CDATA[[${node.data}]]>`;
        }

      case PROCESSING_INSTRUCTION_NODE:
        {
          return `<?${node.target} ${node.data}?>`;
        }

      case COMMENT_NODE:
        {
          return `<!--${node.data}-->`;
        }

      default:
        {
          return '';
        }
    }
  }

  const InternalSlot = createHiddenField('shadowRecord', 'synthetic-shadow');
  const {
    createDocumentFragment
  } = document;

  function getInternalSlot(root) {
    const record = getHiddenField(root, InternalSlot);

    if (isUndefined(record)) {
      throw new TypeError();
    }

    return record;
  }

  const ShadowRootResolverKey = '$shadowResolver$';
  const ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
  defineProperty(Node.prototype, ShadowRootResolverKey, {
    set(fn) {
      this[ShadowResolverPrivateKey] = fn;
      setNodeOwnerKey(this, fn.nodeKey);
    },

    get() {
      return this[ShadowResolverPrivateKey];
    },

    configurable: true,
    enumerable: true
  });

  function getShadowRootResolver(node) {
    return node[ShadowRootResolverKey];
  }

  function setShadowRootResolver(node, fn) {
    node[ShadowRootResolverKey] = fn;
  }

  function isDelegatingFocus(host) {
    return getInternalSlot(host).delegatesFocus;
  }

  function getHost(root) {
    return getInternalSlot(root).host;
  }

  function getShadowRoot(elm) {
    return getInternalSlot(elm).shadowRoot;
  }

  function isHostElement(elm) {
    return !isUndefined(getHiddenField(elm, InternalSlot));
  }

  let uid = 0;

  function attachShadow$1(elm, options) {
    if (!isUndefined(getHiddenField(elm, InternalSlot))) {
      throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);
    }

    const {
      mode,
      delegatesFocus
    } = options;
    const doc = getOwnerDocument(elm);
    const sr = createDocumentFragment.call(doc);
    const record = {
      mode,
      delegatesFocus: !!delegatesFocus,
      host: elm,
      shadowRoot: sr
    };
    setHiddenField(sr, InternalSlot, record);
    setHiddenField(elm, InternalSlot, record);

    const shadowResolver = () => sr;

    const x = shadowResolver.nodeKey = uid++;
    setNodeKey(elm, x);
    setShadowRootResolver(sr, shadowResolver);
    setPrototypeOf(sr, SyntheticShadowRoot.prototype);
    return sr;
  }

  const SyntheticShadowRootDescriptors = {
    constructor: {
      writable: true,
      configurable: true,
      value: SyntheticShadowRoot
    },
    toString: {
      writable: true,
      configurable: true,

      value() {
        return `[object ShadowRoot]`;
      }

    }
  };
  const ShadowRootDescriptors = {
    activeElement: {
      enumerable: true,
      configurable: true,

      get() {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        const activeElement = DocumentPrototypeActiveElement.call(doc);

        if (isNull(activeElement)) {
          return activeElement;
        }

        if ((compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) === 0) {
          return null;
        }

        let node = activeElement;

        while (!isNodeOwnedBy(host, node)) {
          node = parentElementGetter.call(node);
        }

        if (isSlotElement(node)) {
          return null;
        }

        return node;
      }

    },
    delegatesFocus: {
      configurable: true,

      get() {
        return getInternalSlot(this).delegatesFocus;
      }

    },
    elementFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(left, top) {
        const host = getHost(this);
        const doc = getOwnerDocument(host);
        const element = elementFromPoint.call(doc, left, top);

        if (isNull(element)) {
          return element;
        }

        return retarget(this, pathComposer(element, true));
      }

    },
    elementsFromPoint: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(_left, _top) {
        throw new Error();
      }

    },
    getSelection: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        throw new Error();
      }

    },
    host: {
      enumerable: true,
      configurable: true,

      get() {
        return getHost(this);
      }

    },
    mode: {
      configurable: true,

      get() {
        return getInternalSlot(this).mode;
      }

    },
    styleSheets: {
      enumerable: true,
      configurable: true,

      get() {
        throw new Error();
      }

    }
  };
  const NodePatchDescriptors = {
    insertBefore: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(newChild, refChild) {
        insertBefore.call(getHost(this), newChild, refChild);
        return newChild;
      }

    },
    removeChild: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(oldChild) {
        removeChild.call(getHost(this), oldChild);
        return oldChild;
      }

    },
    appendChild: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(newChild) {
        appendChild.call(getHost(this), newChild);
        return newChild;
      }

    },
    replaceChild: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(newChild, oldChild) {
        replaceChild.call(getHost(this), newChild, oldChild);
        return oldChild;
      }

    },
    addEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(type, listener, options) {
        addShadowRootEventListener(this, type, listener);
      }

    },
    removeEventListener: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(type, listener, options) {
        removeShadowRootEventListener(this, type, listener);
      }

    },
    baseURI: {
      enumerable: true,
      configurable: true,

      get() {
        return getHost(this).baseURI;
      }

    },
    childNodes: {
      enumerable: true,
      configurable: true,

      get() {
        return createStaticNodeList(shadowRootChildNodes(this));
      }

    },
    compareDocumentPosition: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(otherNode) {
        const host = getHost(this);

        if (this === otherNode) {
          return 0;
        } else if (this.contains(otherNode)) {
          return 20;
        } else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
          return 37;
        } else {
          return 35;
        }
      }

    },
    contains: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(otherNode) {
        if (this === otherNode) {
          return true;
        }

        const host = getHost(this);
        return (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 && isNodeOwnedBy(host, otherNode);
      }

    },
    firstChild: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        return childNodes[0] || null;
      }

    },
    lastChild: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        return childNodes[childNodes.length - 1] || null;
      }

    },
    hasChildNodes: {
      writable: true,
      enumerable: true,
      configurable: true,

      value() {
        const childNodes = getInternalChildNodes(this);
        return childNodes.length > 0;
      }

    },
    isConnected: {
      enumerable: true,
      configurable: true,

      get() {
        return isConnected.call(getHost(this));
      }

    },
    nextSibling: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    previousSibling: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    nodeName: {
      enumerable: true,
      configurable: true,

      get() {
        return '#document-fragment';
      }

    },
    nodeType: {
      enumerable: true,
      configurable: true,

      get() {
        return 11;
      }

    },
    nodeValue: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    ownerDocument: {
      enumerable: true,
      configurable: true,

      get() {
        return getHost(this).ownerDocument;
      }

    },
    parentElement: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    parentNode: {
      enumerable: true,
      configurable: true,

      get() {
        return null;
      }

    },
    textContent: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        let textContent = '';

        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          const currentNode = childNodes[i];

          if (currentNode.nodeType !== COMMENT_NODE) {
            textContent += getTextContent(currentNode);
          }
        }

        return textContent;
      },

      set(v) {
        const host = getHost(this);
        textContextSetter.call(host, v);
      }

    },
    getRootNode: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(options) {
        return !isUndefined(options) && isTrue$1(options.composed) ? getHost(this).getRootNode(options) : this;
      }

    }
  };
  const ElementPatchDescriptors = {
    innerHTML: {
      enumerable: true,
      configurable: true,

      get() {
        const childNodes = getInternalChildNodes(this);
        let innerHTML = '';

        for (let i = 0, len = childNodes.length; i < len; i += 1) {
          innerHTML += getOuterHTML(childNodes[i]);
        }

        return innerHTML;
      },

      set(v) {
        const host = getHost(this);
        innerHTMLSetter.call(host, v);
      }

    }
  };
  const ParentNodePatchDescriptors = {
    childElementCount: {
      enumerable: true,
      configurable: true,

      get() {
        return this.children.length;
      }

    },
    children: {
      enumerable: true,
      configurable: true,

      get() {
        return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), elm => elm instanceof Element));
      }

    },
    firstElementChild: {
      enumerable: true,
      configurable: true,

      get() {
        return this.children[0] || null;
      }

    },
    lastElementChild: {
      enumerable: true,
      configurable: true,

      get() {
        const {
          children
        } = this;
        return children.item(children.length - 1) || null;
      }

    },
    querySelector: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(selectors) {
        return shadowRootQuerySelector(this, selectors);
      }

    },
    querySelectorAll: {
      writable: true,
      enumerable: true,
      configurable: true,

      value(selectors) {
        return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
      }

    }
  };
  assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);

  function SyntheticShadowRoot() {
    throw new TypeError('Illegal constructor');
  }

  SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);

  function foldSlotElement(slot) {
    let parent = parentElementGetter.call(slot);

    while (!isNull(parent) && isSlotElement(parent)) {
      slot = parent;
      parent = parentElementGetter.call(slot);
    }

    return slot;
  }

  function isNodeSlotted(host, node) {

    const hostKey = getNodeKey(host);
    let currentElement = node instanceof Element ? node : parentElementGetter.call(node);

    while (!isNull(currentElement) && currentElement !== host) {
      const elmOwnerKey = getNodeNearestOwnerKey(currentElement);
      const parent = parentElementGetter.call(currentElement);

      if (elmOwnerKey === hostKey) {
        return isSlotElement(currentElement);
      } else if (parent === host) {
        return false;
      } else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
        if (isSlotElement(parent)) {
          currentElement = getNodeOwner(foldSlotElement(parent));

          if (!isNull(currentElement)) {
            if (currentElement === host) {
              return true;
            } else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
              return true;
            }
          }
        } else {
          return false;
        }
      } else {
        currentElement = parent;
      }
    }

    return false;
  }

  function getNodeOwner(node) {
    if (!(node instanceof Node)) {
      return null;
    }

    const ownerKey = getNodeNearestOwnerKey(node);

    if (isUndefined(ownerKey)) {
      return null;
    }

    let nodeOwner = node;

    while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
      nodeOwner = parentNodeGetter.call(nodeOwner);
    }

    if (isNull(nodeOwner)) {
      return null;
    }

    return nodeOwner;
  }

  function isSlotElement(node) {
    return node instanceof HTMLSlotElement;
  }

  function isNodeOwnedBy(owner, node) {

    const ownerKey = getNodeNearestOwnerKey(node);
    return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;
  }

  function shadowRootChildNodes(root) {
    const elm = getHost(root);
    return getAllMatches(elm, arrayFromCollection(childNodesGetter.call(elm)));
  }

  function getAllSlottedMatches(host, nodeList) {
    const filteredAndPatched = [];

    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];

      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }

    return filteredAndPatched;
  }

  function getFirstSlottedMatch(host, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];

      if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
        return node;
      }
    }

    return null;
  }

  function getAllMatches(owner, nodeList) {
    const filteredAndPatched = [];

    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      const node = nodeList[i];
      const isOwned = isNodeOwnedBy(owner, node);

      if (isOwned) {
        ArrayPush.call(filteredAndPatched, node);
      }
    }

    return filteredAndPatched;
  }

  function getFirstMatch(owner, nodeList) {
    for (let i = 0, len = nodeList.length; i < len; i += 1) {
      if (isNodeOwnedBy(owner, nodeList[i])) {
        return nodeList[i];
      }
    }

    return null;
  }

  function shadowRootQuerySelector(root, selector) {
    const elm = getHost(root);
    const nodeList = arrayFromCollection(querySelectorAll.call(elm, selector));
    return getFirstMatch(elm, nodeList);
  }

  function shadowRootQuerySelectorAll(root, selector) {
    const elm = getHost(root);
    const nodeList = querySelectorAll.call(elm, selector);
    return getAllMatches(elm, arrayFromCollection(nodeList));
  }

  function getFilteredChildNodes(node) {
    let children;

    if (!isHostElement(node) && !isSlotElement(node)) {
      children = childNodesGetter.call(node);
      return arrayFromCollection(children);
    }

    if (isHostElement(node)) {
      const slots = arrayFromCollection(querySelectorAll.call(node, 'slot'));
      const resolver = getShadowRootResolver(getShadowRoot(node));
      return ArrayReduce.call(slots, (seed, slot) => {
        if (resolver === getShadowRootResolver(slot)) {
          ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
        }

        return seed;
      }, []);
    } else {
      children = arrayFromCollection(childNodesGetter.call(node));
      const resolver = getShadowRootResolver(node);
      return ArrayReduce.call(children, (seed, child) => {
        if (resolver === getShadowRootResolver(child)) {
          ArrayPush.call(seed, child);
        }

        return seed;
      }, []);
    }
  }

  function getFilteredSlotAssignedNodes(slot) {
    const owner = getNodeOwner(slot);

    if (isNull(owner)) {
      return [];
    }

    const childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, (seed, child) => {
      if (!isNodeOwnedBy(owner, child)) {
        ArrayPush.call(seed, child);
      }

      return seed;
    }, []);
  }

  const OwnKey = '$$OwnKey$$';
  const OwnerKey = '$$OwnerKey$$';
  const hasNativeSymbolsSupport$2 = Symbol('x').toString() === 'Symbol(x)';

  function getNodeOwnerKey(node) {
    return node[OwnerKey];
  }

  function setNodeOwnerKey(node, value) {
    {
      node[OwnerKey] = value;
    }
  }

  function getNodeKey(node) {
    return node[OwnKey];
  }

  function setNodeKey(node, value) {
    {
      node[OwnKey] = value;
    }
  }

  function getNodeNearestOwnerKey(node) {
    let ownerNode = node;
    let ownerKey;

    while (!isNull(ownerNode)) {
      ownerKey = getNodeOwnerKey(ownerNode);

      if (!isUndefined(ownerKey)) {
        return ownerKey;
      }

      ownerNode = parentNodeGetter.call(ownerNode);
    }
  }

  function isNodeShadowed(node) {
    return !isUndefined(getNodeOwnerKey(node));
  }

  function isNodeDeepShadowed(node) {
    return !isUndefined(getNodeNearestOwnerKey(node));
  }

  function hasMountedChildren(node) {
    return isSlotElement(node) || isHostElement(node);
  }

  function getShadowParent(node, value) {
    const owner = getNodeOwner(node);

    if (value === owner) {
      return getShadowRoot(owner);
    } else if (value instanceof Element) {
      if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
        return value;
      } else if (!isNull(owner) && isSlotElement(value)) {
        const slotOwner = getNodeOwner(value);

        if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
          return slotOwner;
        }
      }
    }

    return null;
  }

  function hasChildNodesPatched() {
    return getInternalChildNodes(this).length > 0;
  }

  function firstChildGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    return childNodes[0] || null;
  }

  function lastChildGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    return childNodes[childNodes.length - 1] || null;
  }

  function textContentGetterPatched() {
    return getTextContent(this);
  }

  function textContentSetterPatched(value) {
    textContextSetter.call(this, value);
  }

  function parentNodeGetterPatched() {
    const value = parentNodeGetter.call(this);

    if (isNull(value)) {
      return value;
    }

    return getShadowParent(this, value);
  }

  function parentElementGetterPatched() {
    const value = parentNodeGetter.call(this);

    if (isNull(value)) {
      return null;
    }

    const parentNode = getShadowParent(this, value);
    return parentNode instanceof Element ? parentNode : null;
  }

  function compareDocumentPositionPatched(otherNode) {
    if (this.getRootNode() === otherNode) {
      return 10;
    } else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return 35;
    }

    return compareDocumentPosition.call(this, otherNode);
  }

  function containsPatched(otherNode) {
    if (otherNode == null || getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
      return false;
    }

    return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }

  function cloneNodePatched(deep) {
    const clone = cloneNode.call(this, false);

    if (!deep) {
      return clone;
    }

    const childNodes = getInternalChildNodes(this);

    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      clone.appendChild(childNodes[i].cloneNode(true));
    }

    return clone;
  }

  function childNodesGetterPatched() {
    if (this instanceof Element && isHostElement(this)) {
      const owner = getNodeOwner(this);
      const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));

      return createStaticNodeList(childNodes);
    }

    return childNodesGetter.call(this);
  }

  const nativeGetRootNode = Node.prototype.getRootNode;
  const getDocumentOrRootNode = !isUndefined(nativeGetRootNode) ? nativeGetRootNode : function () {
    let node = this;
    let nodeParent;

    while (!isNull(nodeParent = parentNodeGetter.call(node))) {
      node = nodeParent;
    }

    return node;
  };

  function getNearestRoot(node) {
    const ownerNode = getNodeOwner(node);

    if (isNull(ownerNode)) {
      return getDocumentOrRootNode.call(node);
    }

    return getShadowRoot(ownerNode);
  }

  function getRootNodePatched(options) {
    const composed = isUndefined(options) ? false : !!options.composed;
    return isTrue$1(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
  }

  defineProperties(Node.prototype, {
    firstChild: {
      get() {
        if (hasMountedChildren(this)) {
          return firstChildGetterPatched.call(this);
        }

        return firstChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    lastChild: {
      get() {
        if (hasMountedChildren(this)) {
          return lastChildGetterPatched.call(this);
        }

        return lastChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    textContent: {
      get() {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return textContentGetterPatched.call(this);
          }

          return textContentGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return textContentGetter.call(this);
        }

        return textContentGetterPatched.call(this);
      },

      set: textContentSetterPatched,
      enumerable: true,
      configurable: true
    },
    parentNode: {
      get() {
        if (isNodeShadowed(this)) {
          return parentNodeGetterPatched.call(this);
        }

        return parentNodeGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    parentElement: {
      get() {
        if (isNodeShadowed(this)) {
          return parentElementGetterPatched.call(this);
        }

        return parentElementGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    childNodes: {
      get() {
        if (hasMountedChildren(this)) {
          return childNodesGetterPatched.call(this);
        }

        return childNodesGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    hasChildNodes: {
      value() {
        if (hasMountedChildren(this)) {
          return hasChildNodesPatched.call(this);
        }

        return hasChildNodes.call(this);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    compareDocumentPosition: {
      value(otherNode) {
        if (isGlobalPatchingSkipped(this)) {
          return compareDocumentPosition.call(this, otherNode);
        }

        return compareDocumentPositionPatched.call(this, otherNode);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    contains: {
      value(otherNode) {
        if (this === otherNode) {
          return true;
        }

        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (otherNode == null) {
            return false;
          }

          if (isNodeShadowed(this) || isHostElement(this)) {
            return containsPatched.call(this, otherNode);
          }

          return contains.call(this, otherNode);
        }

        if (isGlobalPatchingSkipped(this)) {
          return contains.call(this, otherNode);
        }

        return containsPatched.call(this, otherNode);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    cloneNode: {
      value(deep) {
        if (!runtimeFlags.ENABLE_NODE_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return cloneNodePatched.call(this, deep);
          }

          return cloneNode.call(this, deep);
        }

        if (isTrue$1(deep)) {
          if (isGlobalPatchingSkipped(this)) {
            return cloneNode.call(this, deep);
          }

          return cloneNodePatched.call(this, deep);
        }

        return cloneNode.call(this, deep);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    getRootNode: {
      value: getRootNodePatched,
      enumerable: true,
      configurable: true,
      writable: true
    },
    isConnected: {
      enumerable: true,
      configurable: true,

      get() {
        return isConnected.call(this);
      }

    }
  });

  const getInternalChildNodes =  function (node) {
    return node.childNodes;
  };

  if (hasOwnProperty.call(HTMLElement.prototype, 'contains')) {
    defineProperty(HTMLElement.prototype, 'contains', getOwnPropertyDescriptor(Node.prototype, 'contains'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'parentElement')) {
    defineProperty(HTMLElement.prototype, 'parentElement', getOwnPropertyDescriptor(Node.prototype, 'parentElement'));
  }

  function elemFromPoint(left, top) {
    const element = elementFromPoint.call(this, left, top);

    if (isNull(element)) {
      return element;
    }

    return retarget(this, pathComposer(element, true));
  }

  Document.prototype.elementFromPoint = elemFromPoint;
  defineProperty(Document.prototype, 'activeElement', {
    get() {
      let node = DocumentPrototypeActiveElement.call(this);

      if (isNull(node)) {
        return node;
      }

      while (!isUndefined(getNodeOwnerKey(node))) {
        node = parentElementGetter.call(node);

        if (isNull(node)) {
          return null;
        }
      }

      if (node.tagName === 'HTML') {
        node = this.body;
      }

      return node;
    },

    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementById', {
    value() {
      const elm = getElementById.apply(this, ArraySlice.call(arguments));

      if (isNull(elm)) {
        return null;
      }

      return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'querySelector', {
    value() {
      const elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFind.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return !isUndefined(filtered) ? filtered : null;
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'querySelectorAll', {
    value() {
      const elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticNodeList(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByClassName', {
    value() {
      const elements = arrayFromCollection(getElementsByClassName$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByTagName', {
    value() {
      const elements = arrayFromCollection(getElementsByTagName$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByTagNameNS', {
    value() {
      const elements = arrayFromCollection(getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticHTMLCollection(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  defineProperty(getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName') ? HTMLDocument.prototype : Document.prototype, 'getElementsByName', {
    value() {
      const elements = arrayFromCollection(getElementsByName.apply(this, ArraySlice.call(arguments)));
      const filtered = ArrayFilter.call(elements, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));
      return createStaticNodeList(filtered);
    },

    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(window, 'ShadowRoot', {
    value: SyntheticShadowRoot,
    configurable: true,
    writable: true
  });

  function doesEventNeedsPatch(e) {
    const originalTarget = eventTargetGetter.call(e);
    return originalTarget instanceof Node && isNodeDeepShadowed(originalTarget);
  }

  function isValidEventListener(listener) {
    return isFunction(listener) || !isNull(listener) && isObject(listener) && isFunction(listener.handleEvent);
  }

  function getEventListenerWrapper(listener) {
    if ('$$lwcEventWrapper$$' in listener) {
      return listener.$$lwcEventWrapper$$;
    }

    const isHandlerFunction = isFunction(listener);

    const wrapperFn = listener.$$lwcEventWrapper$$ = function (e) {
      if (doesEventNeedsPatch(e)) {
        patchEvent(e);
      }

      return isHandlerFunction ? listener.call(this, e) : listener.handleEvent && listener.handleEvent(e);
    };

    return wrapperFn;
  }

  function windowAddEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }

  function windowRemoveEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    windowRemoveEventListener.call(this, type, wrapperFn || listener, optionsOrCapture);
  }

  function addEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    addEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }

  function removeEventListener$1(type, listener, optionsOrCapture) {
    if (!isValidEventListener(listener)) {
      return;
    }

    const wrapperFn = getEventListenerWrapper(listener);
    removeEventListener.call(this, type, wrapperFn || listener, optionsOrCapture);
  }

  window.addEventListener = windowAddEventListener$1;
  window.removeEventListener = windowRemoveEventListener$1;
  const protoToBePatched = typeof EventTarget !== 'undefined' ? EventTarget.prototype : Node.prototype;
  defineProperties(protoToBePatched, {
    addEventListener: {
      value: addEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    },
    removeEventListener: {
      value: removeEventListener$1,
      enumerable: true,
      writable: true,
      configurable: true
    }
  });
  const composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');

  function detect$1() {
    if (!composedDescriptor) {
      return false;
    }

    let clickEvent = new Event('click');
    const button = document.createElement('button');
    button.addEventListener('click', event => clickEvent = event);
    button.click();
    return !composedDescriptor.get.call(clickEvent);
  }

  const originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');

  function handleClick(event) {
    Object.defineProperty(event, 'composed', {
      configurable: true,
      enumerable: true,

      get() {
        return true;
      }

    });
  }

  function apply$1() {
    HTMLElement.prototype.click = function () {
      addEventListener.call(this, 'click', handleClick);

      try {
        originalClickDescriptor.value.call(this);
      } finally {
        removeEventListener.call(this, 'click', handleClick);
      }
    };
  }

  if (detect$1()) {
    apply$1();
  }

  function detect$2() {
    return new Event('test', {
      composed: true
    }).composed !== true;
  }

  function apply$2() {
    const composedEvents = assign(create(null), {
      beforeinput: 1,
      blur: 1,
      click: 1,
      compositionend: 1,
      compositionstart: 1,
      compositionupdate: 1,
      copy: 1,
      cut: 1,
      dblclick: 1,
      DOMActivate: 1,
      DOMFocusIn: 1,
      DOMFocusOut: 1,
      drag: 1,
      dragend: 1,
      dragenter: 1,
      dragleave: 1,
      dragover: 1,
      dragstart: 1,
      drop: 1,
      focus: 1,
      focusin: 1,
      focusout: 1,
      gotpointercapture: 1,
      input: 1,
      keydown: 1,
      keypress: 1,
      keyup: 1,
      lostpointercapture: 1,
      mousedown: 1,
      mouseenter: 1,
      mouseleave: 1,
      mousemove: 1,
      mouseout: 1,
      mouseover: 1,
      mouseup: 1,
      paste: 1,
      pointercancel: 1,
      pointerdown: 1,
      pointerenter: 1,
      pointerleave: 1,
      pointermove: 1,
      pointerout: 1,
      pointerover: 1,
      pointerup: 1,
      touchcancel: 1,
      touchend: 1,
      touchmove: 1,
      touchstart: 1,
      wheel: 1
    });
    const EventConstructor = Event;

    function PatchedEvent(type, eventInitDict) {
      const event = new EventConstructor(type, eventInitDict);
      const isComposed = !!(eventInitDict && eventInitDict.composed);
      Object.defineProperties(event, {
        composed: {
          get() {
            return isComposed;
          },

          configurable: true,
          enumerable: true
        }
      });
      return event;
    }

    PatchedEvent.prototype = EventConstructor.prototype;
    PatchedEvent.AT_TARGET = EventConstructor.AT_TARGET;
    PatchedEvent.BUBBLING_PHASE = EventConstructor.BUBBLING_PHASE;
    PatchedEvent.CAPTURING_PHASE = EventConstructor.CAPTURING_PHASE;
    PatchedEvent.NONE = EventConstructor.NONE;
    window.Event = PatchedEvent;
    Object.defineProperties(Event.prototype, {
      composed: {
        get() {
          const {
            type
          } = this;
          return composedEvents[type] === 1;
        },

        configurable: true,
        enumerable: true
      }
    });
  }

  if (detect$2()) {
    apply$2();
  }

  const CustomEventConstructor = CustomEvent;

  function PatchedCustomEvent(type, eventInitDict) {
    const event = new CustomEventConstructor(type, eventInitDict);
    const isComposed = !!(eventInitDict && eventInitDict.composed);
    Object.defineProperties(event, {
      composed: {
        get() {
          return isComposed;
        },

        configurable: true,
        enumerable: true
      }
    });
    return event;
  }

  PatchedCustomEvent.prototype = CustomEventConstructor.prototype;
  window.CustomEvent = PatchedCustomEvent;

  if (typeof ClipboardEvent !== 'undefined') {
    const isComposedType = assign(create(null), {
      copy: 1,
      cut: 1,
      paste: 1
    });
    defineProperties(ClipboardEvent.prototype, {
      composed: {
        get() {
          const {
            type
          } = this;
          return isComposedType[type] === 1;
        },

        configurable: true,
        enumerable: true
      }
    });
  }

  function detect$3() {
    return typeof HTMLIFrameElement !== 'undefined';
  }

  function apply$3() {
    const desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
    const {
      get: originalGetter
    } = desc;

    desc.get = function () {
      const original = originalGetter.call(this);

      if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
        return original;
      }

      return wrapIframeWindow(original);
    };

    defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);
  }

  function wrapIframeWindow(win) {
    return {
      addEventListener() {
        return win.addEventListener.apply(win, arguments);
      },

      blur() {
        return win.blur.apply(win, arguments);
      },

      close() {
        return win.close.apply(win, arguments);
      },

      focus() {
        return win.focus.apply(win, arguments);
      },

      postMessage() {
        return win.postMessage.apply(win, arguments);
      },

      removeEventListener() {
        return win.removeEventListener.apply(win, arguments);
      },

      get closed() {
        return win.closed;
      },

      get frames() {
        return win.frames;
      },

      get length() {
        return win.length;
      },

      get location() {
        return win.location;
      },

      set location(value) {
        win.location = value;
      },

      get opener() {
        return win.opener;
      },

      get parent() {
        return win.parent;
      },

      get self() {
        return win.self;
      },

      get top() {
        return win.top;
      },

      get window() {
        return win.window;
      }

    };
  }

  if (detect$3()) {
    apply$3();
  }

  const OriginalMutationObserver = MutationObserver;
  const {
    disconnect: originalDisconnect,
    observe: originalObserve,
    takeRecords: originalTakeRecords
  } = OriginalMutationObserver.prototype;
  const wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
  const observerLookupField = '$$lwcNodeObservers$$';
  const observerToNodesMap = new WeakMap();

  function getNodeObservers(node) {
    return node[observerLookupField];
  }

  function setNodeObservers(node, observers) {
    node[observerLookupField] = observers;
  }

  function retargetMutationRecord(originalRecord) {
    const {
      addedNodes,
      removedNodes,
      target,
      type
    } = originalRecord;
    const retargetedRecord = create(MutationRecord.prototype);
    defineProperties(retargetedRecord, {
      addedNodes: {
        get() {
          return addedNodes;
        },

        enumerable: true,
        configurable: true
      },
      removedNodes: {
        get() {
          return removedNodes;
        },

        enumerable: true,
        configurable: true
      },
      type: {
        get() {
          return type;
        },

        enumerable: true,
        configurable: true
      },
      target: {
        get() {
          return target.shadowRoot;
        },

        enumerable: true,
        configurable: true
      }
    });
    return retargetedRecord;
  }

  function isQualifiedObserver(observer, target) {
    let parentNode = target;

    while (!isNull(parentNode)) {
      const parentNodeObservers = getNodeObservers(parentNode);

      if (!isUndefined(parentNodeObservers) && (parentNodeObservers[0] === observer || ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
        return true;
      }

      parentNode = parentNode.parentNode;
    }

    return false;
  }

  function filterMutationRecords(mutations, observer) {
    return ArrayReduce.call(mutations, (filteredSet, record) => {
      const {
        target,
        addedNodes,
        removedNodes,
        type
      } = record;

      if (type === 'childList' && !isUndefined(getNodeKey(target))) {
        if (addedNodes.length > 0) {
          const sampleNode = addedNodes[0];

          if (isQualifiedObserver(observer, sampleNode)) {
            const nodeObservers = getNodeObservers(target);

            if (nodeObservers && (nodeObservers[0] === observer || ArrayIndexOf.call(nodeObservers, observer) !== -1)) {
              ArrayPush.call(filteredSet, record);
            } else {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        } else {
          const shadowRoot = target.shadowRoot;
          const sampleNode = removedNodes[0];

          if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && isQualifiedObserver(observer, target)) {
            ArrayPush.call(filteredSet, record);
          } else if (shadowRoot) {
            const shadowRootObservers = getNodeObservers(shadowRoot);

            if (shadowRootObservers && (shadowRootObservers[0] === observer || ArrayIndexOf.call(shadowRootObservers, observer) !== -1)) {
              ArrayPush.call(filteredSet, retargetMutationRecord(record));
            }
          }
        }
      } else {
        if (isQualifiedObserver(observer, target)) {
          ArrayPush.call(filteredSet, record);
        }
      }

      return filteredSet;
    }, []);
  }

  function getWrappedCallback(callback) {
    let wrappedCallback = callback[wrapperLookupField];

    if (isUndefined(wrappedCallback)) {
      wrappedCallback = callback[wrapperLookupField] = (mutations, observer) => {
        const filteredRecords = filterMutationRecords(mutations, observer);

        if (filteredRecords.length === 0) {
          return;
        }

        callback.call(observer, filteredRecords, observer);
      };
    }

    return wrappedCallback;
  }

  function PatchedMutationObserver(callback) {
    const wrappedCallback = getWrappedCallback(callback);
    const observer = new OriginalMutationObserver(wrappedCallback);
    return observer;
  }

  function patchedDisconnect() {
    originalDisconnect.call(this);
    const observedNodes = observerToNodesMap.get(this);

    if (!isUndefined(observedNodes)) {
      forEach.call(observedNodes, observedNode => {
        const observers = observedNode[observerLookupField];

        if (!isUndefined(observers)) {
          const index = ArrayIndexOf.call(observers, this);

          if (index !== -1) {
            ArraySplice.call(observers, index, 1);
          }
        }
      });
      observedNodes.length = 0;
    }
  }

  function patchedObserve(target, options) {
    let targetObservers = getNodeObservers(target);

    if (isUndefined(targetObservers)) {
      targetObservers = [];
      setNodeObservers(target, targetObservers);
    }

    if (ArrayIndexOf.call(targetObservers, this) === -1) {
      ArrayPush.call(targetObservers, this);
    }

    if (target instanceof SyntheticShadowRoot) {
      target = target.host;
    }

    if (observerToNodesMap.has(this)) {
      const observedNodes = observerToNodesMap.get(this);

      if (ArrayIndexOf.call(observedNodes, target) === -1) {
        ArrayPush.call(observedNodes, target);
      }
    } else {
      observerToNodesMap.set(this, [target]);
    }

    return originalObserve.call(this, target, options);
  }

  function patchedTakeRecords() {
    return filterMutationRecords(originalTakeRecords.call(this), this);
  }

  PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
  PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
  PatchedMutationObserver.prototype.observe = patchedObserve;
  PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
  defineProperty(window, 'MutationObserver', {
    value: PatchedMutationObserver,
    configurable: true,
    writable: true
  });
  let observer;
  const observerConfig = {
    childList: true
  };
  const SlotChangeKey = createHiddenField('slotchange', 'synthetic-shadow');

  function initSlotObserver() {
    return new MO(mutations => {
      const slots = [];
      forEach.call(mutations, mutation => {

        const {
          target: slot
        } = mutation;

        if (ArrayIndexOf.call(slots, slot) === -1) {
          ArrayPush.call(slots, slot);
          dispatchEvent.call(slot, new CustomEvent('slotchange'));
        }
      });
    });
  }

  function getFilteredSlotFlattenNodes(slot) {
    const childNodes = arrayFromCollection(childNodesGetter.call(slot));
    return ArrayReduce.call(childNodes, (seed, child) => {
      if (child instanceof Element && isSlotElement(child)) {
        ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
      } else {
        ArrayPush.call(seed, child);
      }

      return seed;
    }, []);
  }

  function assignedSlotGetterPatched() {
    const parentNode = parentNodeGetter.call(this);

    if (isNull(parentNode) || !isSlotElement(parentNode) || getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
      return null;
    }

    return parentNode;
  }

  defineProperties(HTMLSlotElement.prototype, {
    addEventListener: {
      value(type, listener, options) {
        HTMLElement.prototype.addEventListener.call(this, type, listener, options);

        if (type === 'slotchange' && !getHiddenField(this, SlotChangeKey)) {
          setHiddenField(this, SlotChangeKey, true);

          if (!observer) {
            observer = initSlotObserver();
          }

          MutationObserverObserve.call(observer, this, observerConfig);
        }
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedElements: {
      value(options) {
        if (isNodeShadowed(this)) {
          const flatten = !isUndefined(options) && isTrue$1(options.flatten);
          const nodes = flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
          return ArrayFilter.call(nodes, node => node instanceof Element);
        } else {
          return assignedElements.apply(this, ArraySlice.call(arguments));
        }
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    assignedNodes: {
      value(options) {
        if (isNodeShadowed(this)) {
          const flatten = !isUndefined(options) && isTrue$1(options.flatten);
          return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
        } else {
          return assignedNodes.apply(this, ArraySlice.call(arguments));
        }
      },

      writable: true,
      enumerable: true,
      configurable: true
    },
    name: {
      get() {
        const name = getAttribute.call(this, 'name');
        return isNull(name) ? '' : name;
      },

      set(value) {
        setAttribute.call(this, 'name', value);
      },

      enumerable: true,
      configurable: true
    },
    childNodes: {
      get() {
        if (isNodeShadowed(this)) {
          const owner = getNodeOwner(this);
          const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
          return createStaticNodeList(childNodes);
        }

        return childNodesGetter.call(this);
      },

      enumerable: true,
      configurable: true
    }
  });
  defineProperties(Text.prototype, {
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });

  function getNonPatchedFilteredArrayOfNodes(context, unfilteredNodes) {
    let filtered;
    const ownerKey = getNodeOwnerKey(context);

    if (!isUndefined(ownerKey)) {
      if (isHostElement(context)) {
        const owner = getNodeOwner(context);

        if (isNull(owner)) {
          filtered = [];
        } else if (getNodeKey(context)) {
          filtered = getAllSlottedMatches(context, unfilteredNodes);
        } else {
          filtered = getAllMatches(owner, unfilteredNodes);
        }
      } else {
        filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === ownerKey);
      }
    } else if (context instanceof HTMLBodyElement) {
      filtered = ArrayFilter.call(unfilteredNodes, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
    } else {
      filtered = ArraySlice.call(unfilteredNodes);
    }

    return filtered;
  }

  var ShadowDomSemantic;

  (function (ShadowDomSemantic) {
    ShadowDomSemantic[ShadowDomSemantic["Disabled"] = 0] = "Disabled";
    ShadowDomSemantic[ShadowDomSemantic["Enabled"] = 1] = "Enabled";
  })(ShadowDomSemantic || (ShadowDomSemantic = {}));

  function innerHTMLGetterPatched() {
    const childNodes = getInternalChildNodes(this);
    let innerHTML = '';

    for (let i = 0, len = childNodes.length; i < len; i += 1) {
      innerHTML += getOuterHTML(childNodes[i]);
    }

    return innerHTML;
  }

  function outerHTMLGetterPatched() {
    return getOuterHTML(this);
  }

  function attachShadowPatched(options) {
    if (isTrue$1(options['$$lwc-synthetic-mode$$'])) {
      return attachShadow$1(this, options);
    } else {
      return attachShadow.call(this, options);
    }
  }

  function shadowRootGetterPatched() {
    if (isHostElement(this)) {
      const shadow = getShadowRoot(this);

      if (shadow.mode === 'open') {
        return shadow;
      }
    }

    return shadowRootGetter.call(this);
  }

  function childrenGetterPatched() {
    const owner = getNodeOwner(this);
    const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
    return createStaticHTMLCollection(ArrayFilter.call(childNodes, node => node instanceof Element));
  }

  function childElementCountGetterPatched() {
    return this.children.length;
  }

  function firstElementChildGetterPatched() {
    return this.children[0] || null;
  }

  function lastElementChildGetterPatched() {
    const {
      children
    } = this;
    return children.item(children.length - 1) || null;
  }

  defineProperties(Element.prototype, {
    innerHTML: {
      get() {
        if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return innerHTMLGetterPatched.call(this);
          }

          return innerHTMLGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return innerHTMLGetter.call(this);
        }

        return innerHTMLGetterPatched.call(this);
      },

      set(v) {
        innerHTMLSetter.call(this, v);
      },

      enumerable: true,
      configurable: true
    },
    outerHTML: {
      get() {
        if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
          if (isNodeShadowed(this) || isHostElement(this)) {
            return outerHTMLGetterPatched.call(this);
          }

          return outerHTMLGetter.call(this);
        }

        if (isGlobalPatchingSkipped(this)) {
          return outerHTMLGetter.call(this);
        }

        return outerHTMLGetterPatched.call(this);
      },

      set(v) {
        outerHTMLSetter.call(this, v);
      },

      enumerable: true,
      configurable: true
    },
    attachShadow: {
      value: attachShadowPatched,
      enumerable: true,
      writable: true,
      configurable: true
    },
    shadowRoot: {
      get: shadowRootGetterPatched,
      enumerable: true,
      configurable: true
    },
    children: {
      get() {
        if (hasMountedChildren(this)) {
          return childrenGetterPatched.call(this);
        }

        return childrenGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    childElementCount: {
      get() {
        if (hasMountedChildren(this)) {
          return childElementCountGetterPatched.call(this);
        }

        return childElementCountGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    firstElementChild: {
      get() {
        if (hasMountedChildren(this)) {
          return firstElementChildGetterPatched.call(this);
        }

        return firstElementChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    lastElementChild: {
      get() {
        if (hasMountedChildren(this)) {
          return lastElementChildGetterPatched.call(this);
        }

        return lastElementChildGetter.call(this);
      },

      enumerable: true,
      configurable: true
    },
    assignedSlot: {
      get: assignedSlotGetterPatched,
      enumerable: true,
      configurable: true
    }
  });

  if (hasOwnProperty.call(HTMLElement.prototype, 'innerHTML')) {
    defineProperty(HTMLElement.prototype, 'innerHTML', getOwnPropertyDescriptor(Element.prototype, 'innerHTML'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'outerHTML')) {
    defineProperty(HTMLElement.prototype, 'outerHTML', getOwnPropertyDescriptor(Element.prototype, 'outerHTML'));
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'children')) {
    defineProperty(HTMLElement.prototype, 'children', getOwnPropertyDescriptor(Element.prototype, 'children'));
  }

  function querySelectorPatched() {
    const nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));

    if (isHostElement(this)) {
      const owner = getNodeOwner(this);

      if (isNull(owner)) {
        return null;
      } else if (getNodeKey(this)) {
        return getFirstSlottedMatch(this, nodeList);
      } else {
        return getFirstMatch(owner, nodeList);
      }
    } else if (isNodeShadowed(this)) {
      const ownerKey = getNodeOwnerKey(this);

      if (!isUndefined(ownerKey)) {
        const elm = ArrayFind.call(nodeList, elm => getNodeNearestOwnerKey(elm) === ownerKey);
        return isUndefined(elm) ? null : elm;
      } else {
        if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
          return nodeList.length === 0 ? null : nodeList[0];
        }

        const contextNearestOwnerKey = getNodeNearestOwnerKey(this);
        const elm = ArrayFind.call(nodeList, elm => getNodeNearestOwnerKey(elm) === contextNearestOwnerKey);
        return isUndefined(elm) ? null : elm;
      }
    } else {
      if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
        if (!(this instanceof HTMLBodyElement)) {
          const elm = nodeList[0];
          return isUndefined(elm) ? null : elm;
        }
      }

      const elm = ArrayFind.call(nodeList, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(this));
      return isUndefined(elm) ? null : elm;
    }
  }

  function getFilteredArrayOfNodes(context, unfilteredNodes, shadowDomSemantic) {
    let filtered;

    if (isHostElement(context)) {
      const owner = getNodeOwner(context);

      if (isNull(owner)) {
        filtered = [];
      } else if (getNodeKey(context)) {
        filtered = getAllSlottedMatches(context, unfilteredNodes);
      } else {
        filtered = getAllMatches(owner, unfilteredNodes);
      }
    } else if (isNodeShadowed(context)) {
      const ownerKey = getNodeOwnerKey(context);

      if (!isUndefined(ownerKey)) {
        filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === ownerKey);
      } else if (shadowDomSemantic === ShadowDomSemantic.Enabled) {
        const contextNearestOwnerKey = getNodeNearestOwnerKey(context);
        filtered = ArrayFilter.call(unfilteredNodes, elm => getNodeNearestOwnerKey(elm) === contextNearestOwnerKey);
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    } else {
      if (context instanceof HTMLBodyElement || shadowDomSemantic === ShadowDomSemantic.Enabled) {
        filtered = ArrayFilter.call(unfilteredNodes, elm => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));
      } else {
        filtered = ArraySlice.call(unfilteredNodes);
      }
    }

    return filtered;
  }

  defineProperties(Element.prototype, {
    querySelector: {
      value: querySelectorPatched,
      writable: true,
      enumerable: true,
      configurable: true
    },
    querySelectorAll: {
      value() {
        const nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));

        if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
          const filteredResults = getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Disabled);
          return createStaticNodeList(filteredResults);
        }

        return createStaticNodeList(getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Enabled));
      },

      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  {
    defineProperties(Element.prototype, {
      getElementsByClassName: {
        value() {
          const elements = arrayFromCollection(getElementsByClassName.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },

        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagName: {
        value() {
          const elements = arrayFromCollection(getElementsByTagName.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },

        writable: true,
        enumerable: true,
        configurable: true
      },
      getElementsByTagNameNS: {
        value() {
          const elements = arrayFromCollection(getElementsByTagNameNS.apply(this, ArraySlice.call(arguments)));

          if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
            return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
          }

          const filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
          return createStaticHTMLCollection(filteredResults);
        },

        writable: true,
        enumerable: true,
        configurable: true
      }
    });
  }

  if (hasOwnProperty.call(HTMLElement.prototype, 'getElementsByClassName')) {
    defineProperty(HTMLElement.prototype, 'getElementsByClassName', getOwnPropertyDescriptor(Element.prototype, 'getElementsByClassName'));
  }

  const FocusableSelector = `
    [contenteditable],
    [tabindex],
    a[href],
    area[href],
    audio[controls],
    button,
    iframe,
    input,
    select,
    textarea,
    video[controls]
`;
  const formElementTagNames = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA']);

  function filterSequentiallyFocusableElements(elements) {
    return elements.filter(element => {
      if (hasAttribute.call(element, 'tabindex')) {
        return getAttribute.call(element, 'tabindex') === '0';
      }

      if (formElementTagNames.has(tagNameGetter.call(element))) {
        return !hasAttribute.call(element, 'disabled');
      }

      return true;
    });
  }

  const DidAddMouseDownListener = createHiddenField('DidAddMouseDownListener', 'synthetic-shadow');

  function isVisible(element) {
    const {
      width,
      height
    } = getBoundingClientRect.call(element);
    const noZeroSize = width > 0 || height > 0;
    const isAreaElement = element.tagName === 'AREA';
    return (noZeroSize || isAreaElement) && getComputedStyle(element).visibility !== 'hidden';
  }

  function isTabbable(element) {
    if (isHostElement(element) && isDelegatingFocus(element)) {
      return false;
    }

    return matches.call(element, FocusableSelector) && isVisible(element);
  }

  function hostElementFocus() {
    const _rootNode = this.getRootNode();

    if (_rootNode === this) {
      const focusable = querySelector.call(this, FocusableSelector);

      if (!isNull(focusable)) {
        focusable.focus.apply(focusable, arguments);
      }

      return;
    }

    const rootNode = _rootNode;

    if (rootNode.activeElement === this) {
      return;
    }

    const focusables = arrayFromCollection(querySelectorAll.call(this, FocusableSelector));
    let didFocus = false;

    while (!didFocus && focusables.length !== 0) {
      const focusable = focusables.shift();
      focusable.focus.apply(focusable, arguments);
      const currentRootNode = focusable.getRootNode();
      didFocus = currentRootNode.activeElement === focusable;
    }
  }

  function getTabbableSegments(host) {
    const doc = getOwnerDocument(host);
    const all = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll$1.call(doc, FocusableSelector)));
    const inner = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll.call(host, FocusableSelector)));

    const firstChild = inner[0];
    const lastChild = inner[inner.length - 1];
    const hostIndex = ArrayIndexOf.call(all, host);
    const firstChildIndex = hostIndex > -1 ? hostIndex : ArrayIndexOf.call(all, firstChild);
    const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;
    const prev = ArraySlice.call(all, 0, firstChildIndex);
    const next = ArraySlice.call(all, lastChildIndex);
    return {
      prev,
      inner,
      next
    };
  }

  function getActiveElement(host) {
    const doc = getOwnerDocument(host);
    const activeElement = DocumentPrototypeActiveElement.call(doc);

    if (isNull(activeElement)) {
      return activeElement;
    }

    return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 ? activeElement : null;
  }

  function relatedTargetPosition(host, relatedTarget) {
    const pos = compareDocumentPosition.call(host, relatedTarget);

    if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
      return 0;
    } else if (pos & DOCUMENT_POSITION_PRECEDING) {
      return 1;
    } else if (pos & DOCUMENT_POSITION_FOLLOWING) {
      return 2;
    }

    return -1;
  }

  function muteEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  function muteFocusEventsDuringExecution(win, func) {
    windowAddEventListener.call(win, 'focusin', muteEvent, true);
    windowAddEventListener.call(win, 'focusout', muteEvent, true);
    func();
    windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
    windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
  }

  function focusOnNextOrBlur(segment, target, relatedTarget) {
    const win = getOwnerWindow(relatedTarget);
    const next = getNextTabbable(segment, relatedTarget);

    if (isNull(next)) {
      muteFocusEventsDuringExecution(win, () => {
        target.blur();
      });
    } else {
      muteFocusEventsDuringExecution(win, () => {
        next.focus();
      });
    }
  }

  let letBrowserHandleFocus = false;

  function disableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = true;
  }

  function enableKeyboardFocusNavigationRoutines() {
    letBrowserHandleFocus = false;
  }

  function skipHostHandler(event) {
    if (letBrowserHandleFocus) {
      enableKeyboardFocusNavigationRoutines();
      return;
    }

    const host = eventCurrentTargetGetter.call(event);
    const target = eventTargetGetter.call(event);

    if (host !== target) {
      return;
    }

    const relatedTarget = focusEventRelatedTargetGetter.call(event);

    if (isNull(relatedTarget)) {
      return;
    }

    const segments = getTabbableSegments(host);
    const position = relatedTargetPosition(host, relatedTarget);

    if (position === 1) {
      const findTabbableElms = isTabbableFrom.bind(null, host.getRootNode());
      const first = ArrayFind.call(segments.inner, findTabbableElms);

      if (!isUndefined(first)) {
        const win = getOwnerWindow(first);
        muteFocusEventsDuringExecution(win, () => {
          first.focus();
        });
      } else {
        focusOnNextOrBlur(segments.next, target, relatedTarget);
      }
    } else if (host === target) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }

  function skipShadowHandler(event) {
    if (letBrowserHandleFocus) {
      enableKeyboardFocusNavigationRoutines();
      return;
    }

    const relatedTarget = focusEventRelatedTargetGetter.call(event);

    if (isNull(relatedTarget)) {
      return;
    }

    const host = eventCurrentTargetGetter.call(event);
    const segments = getTabbableSegments(host);

    if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
      return;
    }

    const target = eventTargetGetter.call(event);
    const position = relatedTargetPosition(host, relatedTarget);

    if (position === 1) {
      focusOnNextOrBlur(segments.next, target, relatedTarget);
    }

    if (position === 2) {
      focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
    }
  }

  function isTabbableFrom(fromRoot, toElm) {
    if (!isTabbable(toElm)) {
      return false;
    }

    const ownerDocument = getOwnerDocument(toElm);
    let root = toElm.getRootNode();

    while (root !== ownerDocument && root !== fromRoot) {
      const sr = root;
      const host = sr.host;

      if (getAttribute.call(host, 'tabindex') === '-1') {
        return false;
      }

      root = host && host.getRootNode();
    }

    return true;
  }

  function getNextTabbable(tabbables, relatedTarget) {
    const len = tabbables.length;

    if (len > 0) {
      for (let i = 0; i < len; i += 1) {
        const next = tabbables[i];

        if (isTabbableFrom(relatedTarget.getRootNode(), next)) {
          return next;
        }
      }
    }

    return null;
  }

  function handleFocus(elm) {

    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocusIn(elm);
    addEventListener.call(elm, 'focusin', skipHostHandler, true);
  }

  function ignoreFocus(elm) {
    removeEventListener.call(elm, 'focusin', skipHostHandler, true);
  }

  function bindDocumentMousedownMouseupHandlers(elm) {
    const ownerDocument = getOwnerDocument(elm);

    if (!getHiddenField(ownerDocument, DidAddMouseDownListener)) {
      setHiddenField(ownerDocument, DidAddMouseDownListener, true);
      addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
      addEventListener.call(ownerDocument, 'mouseup', () => {
        setTimeout(enableKeyboardFocusNavigationRoutines);
      }, true);
    }
  }

  function handleFocusIn(elm) {

    bindDocumentMousedownMouseupHandlers(elm);
    ignoreFocus(elm);
    addEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }

  function ignoreFocusIn(elm) {
    removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }

  const {
    blur,
    focus
  } = HTMLElement.prototype;

  function tabIndexGetterPatched() {
    if (isDelegatingFocus(this) && isFalse$1(hasAttribute.call(this, 'tabindex'))) {
      return 0;
    }

    return tabIndexGetter.call(this);
  }

  function tabIndexSetterPatched(value) {
    const delegatesFocus = isDelegatingFocus(this);
    const prevValue = tabIndexGetter.call(this);
    const prevHasAttr = hasAttribute.call(this, 'tabindex');
    tabIndexSetter.call(this, value);
    const currValue = tabIndexGetter.call(this);
    const currHasAttr = hasAttribute.call(this, 'tabindex');
    const didValueChange = prevValue !== currValue;

    if (prevHasAttr && (didValueChange || isFalse$1(currHasAttr))) {
      if (prevValue === -1) {
        ignoreFocusIn(this);
      }

      if (prevValue === 0 && delegatesFocus) {
        ignoreFocus(this);
      }
    }

    if (isFalse$1(currHasAttr)) {
      return;
    }

    if (prevHasAttr && currHasAttr && isFalse$1(didValueChange)) {
      return;
    }

    if (currValue === -1) {
      handleFocusIn(this);
    }

    if (currValue === 0 && delegatesFocus) {
      handleFocus(this);
    }
  }

  function blurPatched() {
    if (isDelegatingFocus(this)) {
      const currentActiveElement = getActiveElement(this);

      if (!isNull(currentActiveElement)) {
        currentActiveElement.blur();
        return;
      }
    }

    return blur.call(this);
  }

  function focusPatched() {
    disableKeyboardFocusNavigationRoutines();

    if (isHostElement(this) && isDelegatingFocus(this)) {
      hostElementFocus.call(this);
      return;
    }

    focus.apply(this, arguments);
    enableKeyboardFocusNavigationRoutines();
  }

  defineProperties(HTMLElement.prototype, {
    tabIndex: {
      get() {
        if (isHostElement(this)) {
          return tabIndexGetterPatched.call(this);
        }

        return tabIndexGetter.call(this);
      },

      set(v) {
        if (isHostElement(this)) {
          return tabIndexSetterPatched.call(this, v);
        }

        return tabIndexSetter.call(this, v);
      },

      enumerable: true,
      configurable: true
    },
    blur: {
      value() {
        if (isHostElement(this)) {
          return blurPatched.call(this);
        }

        blur.call(this);
      },

      enumerable: true,
      writable: true,
      configurable: true
    },
    focus: {
      value() {
        focusPatched.apply(this, arguments);
      },

      enumerable: true,
      writable: true,
      configurable: true
    }
  });
  const {
    addEventListener: superAddEventListener,
    removeEventListener: superRemoveEventListener
  } = Node.prototype;

  function addEventListenerPatched(type, listener, options) {
    if (isHostElement(this)) {
      addCustomElementEventListener(this, type, listener);
    } else {
      superAddEventListener.call(this, type, listener, options);
    }
  }

  function removeEventListenerPatched(type, listener, options) {
    if (isHostElement(this)) {
      removeCustomElementEventListener(this, type, listener);
    } else {
      superRemoveEventListener.call(this, type, listener, options);
    }
  }

  if (typeof EventTarget !== 'undefined') {
    defineProperties(EventTarget.prototype, {
      addEventListener: {
        value: addEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      },
      removeEventListener: {
        value: removeEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      }
    });
  } else {
    defineProperties(Node.prototype, {
      addEventListener: {
        value: addEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      },
      removeEventListener: {
        value: removeEventListenerPatched,
        enumerable: true,
        writable: true,
        configurable: true
      }
    });
  }

  const ShadowTokenKey = '$shadowToken$';
  const ShadowTokenPrivateKey = '$$ShadowTokenKey$$';

  function getShadowToken(node) {
    return node[ShadowTokenKey];
  }

  function setShadowToken(node, shadowToken) {
    node[ShadowTokenKey] = shadowToken;
  }

  defineProperty(Element.prototype, ShadowTokenKey, {
    set(shadowToken) {
      const oldShadowToken = this[ShadowTokenPrivateKey];

      if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
        removeAttribute.call(this, oldShadowToken);
      }

      if (!isUndefined(shadowToken)) {
        setAttribute.call(this, shadowToken, '');
      }

      this[ShadowTokenPrivateKey] = shadowToken;
    },

    get() {
      return this[ShadowTokenPrivateKey];
    },

    configurable: true
  });
  const DomManualPrivateKey = '$$DomManualKey$$';

  const DocumentResolverFn = function () {};

  let portalObserver;
  const portalObserverConfig = {
    childList: true
  };

  function adoptChildNode(node, fn, shadowToken) {
    const previousNodeShadowResolver = getShadowRootResolver(node);

    if (previousNodeShadowResolver === fn) {
      return;
    }

    setShadowRootResolver(node, fn);

    if (node instanceof Element) {
      setShadowToken(node, shadowToken);

      if (isHostElement(node)) {
        return;
      }

      if (isUndefined(previousNodeShadowResolver)) {
        MutationObserverObserve.call(portalObserver, node, portalObserverConfig);
      }

      const childNodes = childNodesGetter.call(node);

      for (let i = 0, len = childNodes.length; i < len; i += 1) {
        adoptChildNode(childNodes[i], fn, shadowToken);
      }
    }
  }

  function initPortalObserver() {
    return new MO(mutations => {
      forEach.call(mutations, mutation => {
        const {
          target: elm,
          addedNodes,
          removedNodes
        } = mutation;
        const fn = getShadowRootResolver(elm);
        const shadowToken = getShadowToken(elm);

        for (let i = 0, len = removedNodes.length; i < len; i += 1) {
          const node = removedNodes[i];

          if (!(compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
            adoptChildNode(node, DocumentResolverFn, undefined);
          }
        }

        for (let i = 0, len = addedNodes.length; i < len; i += 1) {
          const node = addedNodes[i];

          if (compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
            adoptChildNode(node, fn, shadowToken);
          }
        }
      });
    });
  }

  function markElementAsPortal(elm) {
    if (isUndefined(portalObserver)) {
      portalObserver = initPortalObserver();
    }

    if (isUndefined(getShadowRootResolver(elm))) {
      throw new Error(`Invalid Element`);
    }

    MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
  }

  defineProperty(Element.prototype, '$domManual$', {
    set(v) {
      this[DomManualPrivateKey] = v;

      if (isTrue$1(v)) {
        markElementAsPortal(this);
      }
    },

    get() {
      return this[DomManualPrivateKey];
    },

    configurable: true
  });
  /** version: 1.7.7 */

})));
