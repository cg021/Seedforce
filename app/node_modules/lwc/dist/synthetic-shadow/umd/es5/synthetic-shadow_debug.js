(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
}((function () { 'use strict';

  var _a, _b;
  /* proxy-compat-disable */
  function invariant(value, msg) {
      if (!value) {
          throw new Error("Invariant Violation: " + msg);
      }
  }
  function isTrue(value, msg) {
      if (!value) {
          throw new Error("Assert Violation: " + msg);
      }
  }
  function isFalse(value, msg) {
      if (value) {
          throw new Error("Assert Violation: " + msg);
      }
  }
  function fail(msg) {
      throw new Error(msg);
  }
  var assert = Object.freeze({
      __proto__: null,
      invariant: invariant,
      isTrue: isTrue,
      isFalse: isFalse,
      fail: fail
  });
  var assign = Object.assign, create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, hasOwnProperty = Object.hasOwnProperty, keys = Object.keys, setPrototypeOf = Object.setPrototypeOf;
  var _c = Array.prototype, ArrayFilter = _c.filter, ArrayFind = _c.find, ArrayIndexOf = _c.indexOf, ArrayMap = _c.map, ArrayPush = _c.push, ArrayReduce = _c.reduce, ArrayReverse = _c.reverse, ArraySlice = _c.slice, ArraySplice = _c.splice, forEach = _c.forEach;
  var _d = String.prototype, StringCharCodeAt = _d.charCodeAt, StringReplace = _d.replace, StringToLowerCase = _d.toLowerCase;
  function isUndefined(obj) {
      return obj === undefined;
  }
  function isNull(obj) {
      return obj === null;
  }
  function isTrue$1(obj) {
      return obj === true;
  }
  function isFalse$1(obj) {
      return obj === false;
  }
  function isFunction(obj) {
      return typeof obj === 'function';
  }
  function isObject(obj) {
      return typeof obj === 'object';
  }
  function getPropertyDescriptor(o, p) {
      do {
          var d = getOwnPropertyDescriptor(o, p);
          if (!isUndefined(d)) {
              return d;
          }
          o = getPrototypeOf(o);
      } while (o !== null);
  }
  var AriaPropertyNames = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
  var AttrNameToPropNameMap = create(null);
  var PropNameToAttrNameMap = create(null);
  forEach.call(AriaPropertyNames, function (propName) {
      var attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, 'aria-'));
      AttrNameToPropNameMap[attrName] = propName;
      PropNameToAttrNameMap[propName] = attrName;
  });
  var _globalThis = function () {
      if (typeof globalThis === 'object') {
          return globalThis;
      }
      var _globalThis;
      try {
          Object.defineProperty(Object.prototype, '__magic__', {
              get: function () {
                  return this;
              },
              configurable: true
          });
          _globalThis = __magic__;
          delete Object.prototype.__magic__;
      }
      catch (ex) { }
      finally {
          if (typeof _globalThis === 'undefined') {
              _globalThis = window;
          }
      }
      return _globalThis;
  }();
  var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
  function createHiddenField(key, namespace) {
      return hasNativeSymbolsSupport ? Symbol(key) : "$$lwc-" + namespace + "-" + key + "$$";
  }
  var hiddenFieldsMap = new WeakMap();
  function setHiddenField(o, field, value) {
      var valuesByField = hiddenFieldsMap.get(o);
      if (isUndefined(valuesByField)) {
          valuesByField = create(null);
          hiddenFieldsMap.set(o, valuesByField);
      }
      valuesByField[field] = value;
  }
  function getHiddenField(o, field) {
      var valuesByField = hiddenFieldsMap.get(o);
      if (!isUndefined(valuesByField)) {
          return valuesByField[field];
      }
  }
  var HTML_ATTRIBUTES_TO_PROPERTY = {
      accesskey: 'accessKey',
      readonly: 'readOnly',
      tabindex: 'tabIndex',
      bgcolor: 'bgColor',
      colspan: 'colSpan',
      rowspan: 'rowSpan',
      contenteditable: 'contentEditable',
      crossorigin: 'crossOrigin',
      datetime: 'dateTime',
      formaction: 'formAction',
      ismap: 'isMap',
      maxlength: 'maxLength',
      minlength: 'minLength',
      novalidate: 'noValidate',
      usemap: 'useMap',
      for: 'htmlFor'
  };
  keys(HTML_ATTRIBUTES_TO_PROPERTY).forEach(function (attrName) { });
  var DOCUMENT_POSITION_CONTAINED_BY = Node.DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_PRECEDING = Node.DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING = Node.DOCUMENT_POSITION_FOLLOWING, ELEMENT_NODE = Node.ELEMENT_NODE, TEXT_NODE = Node.TEXT_NODE, CDATA_SECTION_NODE = Node.CDATA_SECTION_NODE, PROCESSING_INSTRUCTION_NODE = Node.PROCESSING_INSTRUCTION_NODE, COMMENT_NODE = Node.COMMENT_NODE;
  var _e = Node.prototype, appendChild = _e.appendChild, cloneNode = _e.cloneNode, compareDocumentPosition = _e.compareDocumentPosition, insertBefore = _e.insertBefore, removeChild = _e.removeChild, replaceChild = _e.replaceChild, hasChildNodes = _e.hasChildNodes;
  var contains = HTMLElement.prototype.contains;
  var firstChildGetter = getOwnPropertyDescriptor(Node.prototype, 'firstChild').get;
  var lastChildGetter = getOwnPropertyDescriptor(Node.prototype, 'lastChild').get;
  var textContentGetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
  var parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;
  var ownerDocumentGetter = getOwnPropertyDescriptor(Node.prototype, 'ownerDocument').get;
  var parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement') ? getOwnPropertyDescriptor(Node.prototype, 'parentElement').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get;
  var textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;
  var childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes') ? getOwnPropertyDescriptor(Node.prototype, 'childNodes').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get;
  var isConnected = hasOwnProperty.call(Node.prototype, 'isConnected') ? getOwnPropertyDescriptor(Node.prototype, 'isConnected').get : function () {
      var doc = ownerDocumentGetter.call(this);
      return doc === null || (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  };
  var _f = Element.prototype, addEventListener = _f.addEventListener, getAttribute = _f.getAttribute, getBoundingClientRect = _f.getBoundingClientRect, getElementsByTagName = _f.getElementsByTagName, getElementsByTagNameNS = _f.getElementsByTagNameNS, hasAttribute = _f.hasAttribute, querySelector = _f.querySelector, querySelectorAll = _f.querySelectorAll, removeAttribute = _f.removeAttribute, removeEventListener = _f.removeEventListener, setAttribute = _f.setAttribute;
  var attachShadow = hasOwnProperty.call(Element.prototype, 'attachShadow') ? Element.prototype.attachShadow : function () {
      throw new TypeError('attachShadow() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill and use Lightning Web Components');
  };
  var childElementCountGetter = getOwnPropertyDescriptor(Element.prototype, 'childElementCount').get;
  var firstElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').get;
  var lastElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'lastElementChild').get;
  var innerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'innerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML');
  var innerHTMLGetter = innerHTMLDescriptor.get;
  var innerHTMLSetter = innerHTMLDescriptor.set;
  var outerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'outerHTML') ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML') : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML');
  var outerHTMLGetter = outerHTMLDescriptor.get;
  var outerHTMLSetter = outerHTMLDescriptor.set;
  var tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;
  var tabIndexDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex');
  var tabIndexGetter = tabIndexDescriptor.get;
  var tabIndexSetter = tabIndexDescriptor.set;
  var matches = hasOwnProperty.call(Element.prototype, 'matches') ? Element.prototype.matches : Element.prototype.msMatchesSelector;
  var childrenGetter = hasOwnProperty.call(Element.prototype, 'children') ? getOwnPropertyDescriptor(Element.prototype, 'children').get : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get;
  var getElementsByClassName = HTMLElement.prototype.getElementsByClassName;
  var shadowRootGetter = hasOwnProperty.call(Element.prototype, 'shadowRoot') ? getOwnPropertyDescriptor(Element.prototype, 'shadowRoot').get : function () { return null; };
  var assignedNodes, assignedElements;
  if (typeof HTMLSlotElement !== 'undefined') {
      assignedNodes = HTMLSlotElement.prototype.assignedNodes;
      assignedElements = HTMLSlotElement.prototype.assignedElements;
  }
  else {
      assignedNodes = function () {
          throw new TypeError("assignedNodes() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
      };
      assignedElements = function () {
          throw new TypeError("assignedElements() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template");
      };
  }
  var dispatchEvent = 'EventTarget' in window ? EventTarget.prototype.dispatchEvent : Node.prototype.dispatchEvent;
  var eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;
  var eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;
  var focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;
  var DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;
  var elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint') ? Document.prototype.elementFromPoint : Document.prototype.msElementFromPoint;
  var defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;
  var _g = Document.prototype, querySelectorAll$1 = _g.querySelectorAll, getElementById = _g.getElementById, getElementsByClassName$1 = _g.getElementsByClassName, getElementsByTagName$1 = _g.getElementsByTagName, getElementsByTagNameNS$1 = _g.getElementsByTagNameNS;
  var getElementsByName = HTMLDocument.prototype.getElementsByName;
  var windowAddEventListener = window.addEventListener, windowRemoveEventListener = window.removeEventListener;
  var MO = MutationObserver;
  var MutationObserverObserve = MO.prototype.observe;
  function detect() {
      return typeof HTMLSlotElement === 'undefined';
  }
  var createElement = Document.prototype.createElement;
  var CHAR_S = 115;
  var CHAR_L = 108;
  var CHAR_O = 111;
  var CHAR_T = 116;
  function apply() {
      var HTMLSlotElement = /** @class */ (function () {
          function HTMLSlotElement() {
          }
          return HTMLSlotElement;
      }());
      setPrototypeOf(HTMLSlotElement, HTMLElement.constructor);
      setPrototypeOf(HTMLSlotElement.prototype, HTMLElement.prototype);
      Window.prototype.HTMLSlotElement = HTMLSlotElement;
      defineProperty(Document.prototype, 'createElement', {
          value: function (tagName, _options) {
              var elm = createElement.apply(this, ArraySlice.call(arguments));
              if (tagName.length === 4 && StringCharCodeAt.call(tagName, 0) === CHAR_S && StringCharCodeAt.call(tagName, 1) === CHAR_L && StringCharCodeAt.call(tagName, 2) === CHAR_O && StringCharCodeAt.call(tagName, 3) === CHAR_T) {
                  setPrototypeOf(elm, HTMLSlotElement.prototype);
              }
              return elm;
          }
      });
  }
  if (detect()) {
      apply();
  }
  var create$1 = Object.create, keys$1 = Object.keys;
  var _h = Array.prototype, forEach$1 = _h.forEach;
  var _j = String.prototype, StringReplace$1 = _j.replace, StringToLowerCase$1 = _j.toLowerCase;
  var AriaPropertyNames$1 = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
  var AttrNameToPropNameMap$1 = create$1(null);
  var PropNameToAttrNameMap$1 = create$1(null);
  forEach$1.call(AriaPropertyNames$1, function (propName) {
      var attrName = StringToLowerCase$1.call(StringReplace$1.call(propName, /^aria/, 'aria-'));
      AttrNameToPropNameMap$1[attrName] = propName;
      PropNameToAttrNameMap$1[propName] = attrName;
  });
  var _globalThis$1 = function () {
      if (typeof globalThis === 'object') {
          return globalThis;
      }
      var _globalThis;
      try {
          Object.defineProperty(Object.prototype, '__magic__', {
              get: function () {
                  return this;
              },
              configurable: true
          });
          _globalThis = __magic__;
          delete Object.prototype.__magic__;
      }
      catch (ex) { }
      finally {
          if (typeof _globalThis === 'undefined') {
              _globalThis = window;
          }
      }
      return _globalThis;
  }();
  var hasNativeSymbolsSupport$1 = Symbol('x').toString() === 'Symbol(x)';
  var HTML_ATTRIBUTES_TO_PROPERTY$1 = {
      accesskey: 'accessKey',
      readonly: 'readOnly',
      tabindex: 'tabIndex',
      bgcolor: 'bgColor',
      colspan: 'colSpan',
      rowspan: 'rowSpan',
      contenteditable: 'contentEditable',
      crossorigin: 'crossOrigin',
      datetime: 'dateTime',
      formaction: 'formAction',
      ismap: 'isMap',
      maxlength: 'maxLength',
      minlength: 'minLength',
      novalidate: 'noValidate',
      usemap: 'useMap',
      for: 'htmlFor'
  };
  keys$1(HTML_ATTRIBUTES_TO_PROPERTY$1).forEach(function (attrName) { });
  if (!_globalThis$1.lwcRuntimeFlags) {
      Object.defineProperty(_globalThis$1, 'lwcRuntimeFlags', {
          value: create$1(null)
      });
  }
  var runtimeFlags = _globalThis$1.lwcRuntimeFlags;
  function getOwnerDocument(node) {
      var doc = ownerDocumentGetter.call(node);
      return doc === null ? node : doc;
  }
  function getOwnerWindow(node) {
      var doc = getOwnerDocument(node);
      var win = defaultViewGetter.call(doc);
      if (win === null) {
          throw new TypeError();
      }
      return win;
  }
  var skipGlobalPatching;
  function isGlobalPatchingSkipped(node) {
      if (isUndefined(skipGlobalPatching)) {
          var ownerDocument = getOwnerDocument(node);
          skipGlobalPatching = ownerDocument.body && getAttribute.call(ownerDocument.body, 'data-global-patching-bypass') === 'temporary-bypass';
      }
      return isTrue$1(skipGlobalPatching);
  }
  function arrayFromCollection(collection) {
      var size = collection.length;
      var cloned = [];
      if (size > 0) {
          for (var i = 0; i < size; i++) {
              cloned[i] = collection[i];
          }
      }
      return cloned;
  }
  function pathComposer(startNode, composed) {
      var composedPath = [];
      var current = startNode;
      var startRoot = startNode instanceof Window ? startNode : startNode.getRootNode();
      while (!isNull(current)) {
          composedPath.push(current);
          var assignedSlot = null;
          if (current instanceof Element) {
              assignedSlot = current.assignedSlot;
          }
          if (!isNull(assignedSlot)) {
              current = assignedSlot;
          }
          else if (current instanceof ShadowRoot && (composed || current !== startRoot)) {
              current = current.host;
          }
          else {
              current = current.parentNode;
          }
      }
      var doc;
      if (startNode instanceof Window) {
          doc = startNode.document;
      }
      else {
          doc = getOwnerDocument(startNode);
      }
      if (composedPath[composedPath.length - 1] === doc) {
          composedPath.push(window);
      }
      return composedPath;
  }
  function retarget(refNode, path) {
      if (isNull(refNode)) {
          return null;
      }
      var refNodePath = pathComposer(refNode, true);
      var p$ = path;
      for (var i = 0, ancestor = void 0, lastRoot = void 0, root = void 0, rootIdx = void 0; i < p$.length; i++) {
          ancestor = p$[i];
          root = ancestor instanceof Window ? ancestor : ancestor.getRootNode();
          if (root !== lastRoot) {
              rootIdx = refNodePath.indexOf(root);
              lastRoot = root;
          }
          if (!(root instanceof SyntheticShadowRoot) || !isUndefined(rootIdx) && rootIdx > -1) {
              return ancestor;
          }
      }
      return null;
  }
  var EventListenerContext;
  (function (EventListenerContext) {
      EventListenerContext[EventListenerContext["CUSTOM_ELEMENT_LISTENER"] = 1] = "CUSTOM_ELEMENT_LISTENER";
      EventListenerContext[EventListenerContext["SHADOW_ROOT_LISTENER"] = 2] = "SHADOW_ROOT_LISTENER";
  })(EventListenerContext || (EventListenerContext = {}));
  var eventToContextMap = new WeakMap();
  function isChildNode(root, node) {
      return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);
  }
  var GET_ROOT_NODE_CONFIG_FALSE = {
      composed: false
  };
  function getRootNodeHost(node, options) {
      var rootNode = node.getRootNode(options);
      if ('mode' in rootNode && 'delegatesFocus' in rootNode) {
          rootNode = getHost(rootNode);
      }
      return rootNode;
  }
  function targetGetter() {
      var originalCurrentTarget = eventCurrentTargetGetter.call(this);
      var originalTarget = eventTargetGetter.call(this);
      var composedPath = pathComposer(originalTarget, this.composed);
      var doc = getOwnerDocument(originalTarget);
      if (!(originalCurrentTarget instanceof Node)) {
          if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {
              return originalTarget;
          }
          return retarget(doc, composedPath);
      }
      else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {
          if (isUndefined(getNodeOwnerKey(originalTarget))) {
              return originalTarget;
          }
          return retarget(doc, composedPath);
      }
      var eventContext = eventToContextMap.get(this);
      var currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
      return retarget(currentTarget, composedPath);
  }
  function composedPathValue() {
      var originalTarget = eventTargetGetter.call(this);
      var originalCurrentTarget = eventCurrentTargetGetter.call(this);
      return isNull(originalCurrentTarget) ? [] : pathComposer(originalTarget, this.composed);
  }
  function patchEvent(event) {
      if (eventToContextMap.has(event)) {
          return;
      }
      defineProperties(event, {
          target: {
              get: targetGetter,
              enumerable: true,
              configurable: true
          },
          composedPath: {
              value: composedPathValue,
              writable: true,
              enumerable: true,
              configurable: true
          },
          srcElement: {
              get: targetGetter,
              enumerable: true,
              configurable: true
          },
          path: {
              get: composedPathValue,
              enumerable: true,
              configurable: true
          }
      });
      var originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');
      if (!isUndefined(originalRelatedTargetDescriptor)) {
          var relatedTargetGetter_1 = originalRelatedTargetDescriptor.get;
          defineProperty(event, 'relatedTarget', {
              get: function () {
                  var eventContext = eventToContextMap.get(this);
                  var originalCurrentTarget = eventCurrentTargetGetter.call(this);
                  var relatedTarget = relatedTargetGetter_1.call(this);
                  if (isNull(relatedTarget)) {
                      return null;
                  }
                  var currentTarget = eventContext === EventListenerContext.SHADOW_ROOT_LISTENER ? getShadowRoot(originalCurrentTarget) : originalCurrentTarget;
                  return retarget(currentTarget, pathComposer(relatedTarget, true));
              },
              enumerable: true,
              configurable: true
          });
      }
      eventToContextMap.set(event, 0);
  }
  var customElementToWrappedListeners = new WeakMap();
  function getEventMap(elm) {
      var listenerInfo = customElementToWrappedListeners.get(elm);
      if (isUndefined(listenerInfo)) {
          listenerInfo = create(null);
          customElementToWrappedListeners.set(elm, listenerInfo);
      }
      return listenerInfo;
  }
  var shadowRootEventListenerMap = new WeakMap();
  function getWrappedShadowRootListener(sr, listener) {
      if (!isFunction(listener)) {
          throw new TypeError();
      }
      var shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);
      if (isUndefined(shadowRootWrappedListener)) {
          shadowRootWrappedListener = function (event) {
              var composed = event.composed;
              var target = eventTargetGetter.call(event);
              var currentTarget = eventCurrentTargetGetter.call(event);
              if (target !== currentTarget) {
                  var rootNode = getRootNodeHost(target, {
                      composed: composed
                  });
                  if (isChildNode(rootNode, currentTarget) || composed === false && rootNode === currentTarget) {
                      listener.call(sr, event);
                  }
              }
          };
          shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;
          shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);
      }
      return shadowRootWrappedListener;
  }
  var customElementEventListenerMap = new WeakMap();
  function getWrappedCustomElementListener(elm, listener) {
      if (!isFunction(listener)) {
          throw new TypeError();
      }
      var customElementWrappedListener = customElementEventListenerMap.get(listener);
      if (isUndefined(customElementWrappedListener)) {
          customElementWrappedListener = function (event) {
              if (isValidEventForCustomElement(event)) {
                  listener.call(elm, event);
              }
          };
          customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;
          customElementEventListenerMap.set(listener, customElementWrappedListener);
      }
      return customElementWrappedListener;
  }
  function domListener(evt) {
      patchEvent(evt);
      var immediatePropagationStopped = false;
      var propagationStopped = false;
      var type = evt.type, stopImmediatePropagation = evt.stopImmediatePropagation, stopPropagation = evt.stopPropagation;
      var currentTarget = eventCurrentTargetGetter.call(evt);
      var listenerMap = getEventMap(currentTarget);
      var listeners = listenerMap[type];
      defineProperty(evt, 'stopImmediatePropagation', {
          value: function () {
              immediatePropagationStopped = true;
              stopImmediatePropagation.call(evt);
          },
          writable: true,
          enumerable: true,
          configurable: true
      });
      defineProperty(evt, 'stopPropagation', {
          value: function () {
              propagationStopped = true;
              stopPropagation.call(evt);
          },
          writable: true,
          enumerable: true,
          configurable: true
      });
      var bookkeeping = ArraySlice.call(listeners);
      function invokeListenersByPlacement(placement) {
          forEach.call(bookkeeping, function (listener) {
              if (isFalse$1(immediatePropagationStopped) && listener.placement === placement) {
                  if (ArrayIndexOf.call(listeners, listener) !== -1) {
                      listener.call(undefined, evt);
                  }
              }
          });
      }
      eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);
      invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);
      if (isFalse$1(immediatePropagationStopped) && isFalse$1(propagationStopped)) {
          eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);
          invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);
      }
      eventToContextMap.set(evt, 0);
  }
  function attachDOMListener(elm, type, wrappedListener) {
      var listenerMap = getEventMap(elm);
      var cmpEventHandlers = listenerMap[type];
      if (isUndefined(cmpEventHandlers)) {
          cmpEventHandlers = listenerMap[type] = [];
      }
      if (cmpEventHandlers.length === 0) {
          addEventListener.call(elm, type, domListener);
      }
      ArrayPush.call(cmpEventHandlers, wrappedListener);
  }
  function detachDOMListener(elm, type, wrappedListener) {
      var listenerMap = getEventMap(elm);
      var p;
      var listeners;
      if (!isUndefined(listeners = listenerMap[type]) && (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {
          ArraySplice.call(listeners, p, 1);
          if (listeners.length === 0) {
              removeEventListener.call(elm, type, domListener);
          }
      }
  }
  function isValidEventForCustomElement(event) {
      var target = eventTargetGetter.call(event);
      var currentTarget = eventCurrentTargetGetter.call(event);
      var composed = event.composed;
      return composed === true || target === currentTarget || isChildNode(getRootNodeHost(target, GET_ROOT_NODE_CONFIG_FALSE), currentTarget);
  }
  function addCustomElementEventListener(elm, type, listener, _options) {
      var wrappedListener = getWrappedCustomElementListener(elm, listener);
      attachDOMListener(elm, type, wrappedListener);
  }
  function removeCustomElementEventListener(elm, type, listener, _options) {
      var wrappedListener = getWrappedCustomElementListener(elm, listener);
      detachDOMListener(elm, type, wrappedListener);
  }
  function addShadowRootEventListener(sr, type, listener, _options) {
      var elm = getHost(sr);
      var wrappedListener = getWrappedShadowRootListener(sr, listener);
      attachDOMListener(elm, type, wrappedListener);
  }
  function removeShadowRootEventListener(sr, type, listener, _options) {
      var elm = getHost(sr);
      var wrappedListener = getWrappedShadowRootListener(sr, listener);
      detachDOMListener(elm, type, wrappedListener);
  }
  function getTextContent(node) {
      switch (node.nodeType) {
          case ELEMENT_NODE:
              {
                  var childNodes = getFilteredChildNodes(node);
                  var content = '';
                  for (var i = 0, len = childNodes.length; i < len; i += 1) {
                      var currentNode = childNodes[i];
                      if (currentNode.nodeType !== COMMENT_NODE) {
                          content += getTextContent(currentNode);
                      }
                  }
                  return content;
              }
          default:
              return node.nodeValue;
      }
  }
  var Items = createHiddenField('StaticNodeListItems', 'synthetic-shadow');
  function StaticNodeList() {
      throw new TypeError('Illegal constructor');
  }
  StaticNodeList.prototype = create(NodeList.prototype, (_a = {
          constructor: {
              writable: true,
              configurable: true,
              value: StaticNodeList
          },
          item: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function (index) {
                  return this[index];
              }
          },
          length: {
              enumerable: true,
              configurable: true,
              get: function () {
                  return getHiddenField(this, Items).length;
              }
          },
          forEach: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function (cb, thisArg) {
                  forEach.call(getHiddenField(this, Items), cb, thisArg);
              }
          },
          entries: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function () {
                  return ArrayMap.call(getHiddenField(this, Items), function (v, i) { return [i, v]; });
              }
          },
          keys: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function () {
                  return ArrayMap.call(getHiddenField(this, Items), function (_v, i) { return i; });
              }
          },
          values: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function () {
                  return getHiddenField(this, Items);
              }
          }
      },
      _a[Symbol.iterator] = {
          writable: true,
          configurable: true,
          value: function () {
              var _this = this;
              var nextIndex = 0;
              return {
                  next: function () {
                      var items = getHiddenField(_this, Items);
                      return nextIndex < items.length ? {
                          value: items[nextIndex++],
                          done: false
                      } : {
                          done: true
                      };
                  }
              };
          }
      },
      _a[Symbol.toStringTag] = {
          configurable: true,
          get: function () {
              return 'NodeList';
          }
      },
      _a.toString = {
          writable: true,
          configurable: true,
          value: function () {
              return '[object NodeList]';
          }
      },
      _a));
  setPrototypeOf(StaticNodeList, NodeList);
  function createStaticNodeList(items) {
      var nodeList = create(StaticNodeList.prototype);
      setHiddenField(nodeList, Items, items);
      forEach.call(items, function (item, index) {
          defineProperty(nodeList, index, {
              value: item,
              enumerable: true,
              configurable: true
          });
      });
      return nodeList;
  }
  var Items$1 = createHiddenField('StaticHTMLCollectionItems', 'synthetic-shadow');
  function StaticHTMLCollection() {
      throw new TypeError('Illegal constructor');
  }
  StaticHTMLCollection.prototype = create(HTMLCollection.prototype, (_b = {
          constructor: {
              writable: true,
              configurable: true,
              value: StaticHTMLCollection
          },
          item: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function (index) {
                  return this[index];
              }
          },
          length: {
              enumerable: true,
              configurable: true,
              get: function () {
                  return getHiddenField(this, Items$1).length;
              }
          },
          namedItem: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function (name) {
                  if (name === '') {
                      return null;
                  }
                  var items = getHiddenField(this, Items$1);
                  for (var i = 0, len = items.length; i < len; i++) {
                      var item = items[len];
                      if (name === getAttribute.call(item, 'id') || name === getAttribute.call(item, 'name')) {
                          return item;
                      }
                  }
                  return null;
              }
          },
          forEach: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function (cb, thisArg) {
                  forEach.call(getHiddenField(this, Items$1), cb, thisArg);
              }
          },
          entries: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function () {
                  return ArrayMap.call(getHiddenField(this, Items$1), function (v, i) { return [i, v]; });
              }
          },
          keys: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function () {
                  return ArrayMap.call(getHiddenField(this, Items$1), function (v, i) { return i; });
              }
          },
          values: {
              writable: true,
              enumerable: true,
              configurable: true,
              value: function () {
                  return getHiddenField(this, Items$1);
              }
          }
      },
      _b[Symbol.iterator] = {
          writable: true,
          configurable: true,
          value: function () {
              var _this = this;
              var nextIndex = 0;
              return {
                  next: function () {
                      var items = getHiddenField(_this, Items$1);
                      return nextIndex < items.length ? {
                          value: items[nextIndex++],
                          done: false
                      } : {
                          done: true
                      };
                  }
              };
          }
      },
      _b[Symbol.toStringTag] = {
          configurable: true,
          get: function () {
              return 'HTMLCollection';
          }
      },
      _b.toString = {
          writable: true,
          configurable: true,
          value: function () {
              return '[object HTMLCollection]';
          }
      },
      _b));
  setPrototypeOf(StaticHTMLCollection, HTMLCollection);
  function createStaticHTMLCollection(items) {
      var collection = create(StaticHTMLCollection.prototype);
      setHiddenField(collection, Items$1, items);
      forEach.call(items, function (item, index) {
          defineProperty(collection, index, {
              value: item,
              enumerable: true,
              configurable: true
          });
      });
      return collection;
  }
  function getInnerHTML(node) {
      var s = '';
      var childNodes = getFilteredChildNodes(node);
      for (var i = 0, len = childNodes.length; i < len; i += 1) {
          s += getOuterHTML(childNodes[i]);
      }
      return s;
  }
  var escapeAttrRegExp = /[&\u00A0"]/g;
  var escapeDataRegExp = /[&\u00A0<>]/g;
  var _k = String.prototype, replace = _k.replace, toLowerCase = _k.toLowerCase;
  function escapeReplace(c) {
      switch (c) {
          case '&':
              return '&amp;';
          case '<':
              return '&lt;';
          case '>':
              return '&gt;';
          case '"':
              return '&quot;';
          case '\u00A0':
              return '&nbsp;';
          default:
              return '';
      }
  }
  function escapeAttr(s) {
      return replace.call(s, escapeAttrRegExp, escapeReplace);
  }
  function escapeData(s) {
      return replace.call(s, escapeDataRegExp, escapeReplace);
  }
  var voidElements = new Set(['AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT', 'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR']);
  var plaintextParents = new Set(['STYLE', 'SCRIPT', 'XMP', 'IFRAME', 'NOEMBED', 'NOFRAMES', 'PLAINTEXT', 'NOSCRIPT']);
  function getOuterHTML(node) {
      switch (node.nodeType) {
          case ELEMENT_NODE:
              {
                  var attrs = node.attributes;
                  var tagName = tagNameGetter.call(node);
                  var s = '<' + toLowerCase.call(tagName);
                  for (var i = 0, attr = void 0; attr = attrs[i]; i++) {
                      s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
                  }
                  s += '>';
                  if (voidElements.has(tagName)) {
                      return s;
                  }
                  return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';
              }
          case TEXT_NODE:
              {
                  var data = node.data, parentNode = node.parentNode;
                  if (parentNode instanceof Element && plaintextParents.has(tagNameGetter.call(parentNode))) {
                      return data;
                  }
                  return escapeData(data);
              }
          case CDATA_SECTION_NODE:
              {
                  return "<!CDATA[[" + node.data + "]]>";
              }
          case PROCESSING_INSTRUCTION_NODE:
              {
                  return "<?" + node.target + " " + node.data + "?>";
              }
          case COMMENT_NODE:
              {
                  return "<!--" + node.data + "-->";
              }
          default:
              {
                  return '';
              }
      }
  }
  var InternalSlot = createHiddenField('shadowRecord', 'synthetic-shadow');
  var createDocumentFragment = document.createDocumentFragment;
  function getInternalSlot(root) {
      var record = getHiddenField(root, InternalSlot);
      if (isUndefined(record)) {
          throw new TypeError();
      }
      return record;
  }
  var ShadowRootResolverKey = '$shadowResolver$';
  var ShadowResolverPrivateKey = '$$ShadowResolverKey$$';
  defineProperty(Node.prototype, ShadowRootResolverKey, {
      set: function (fn) {
          this[ShadowResolverPrivateKey] = fn;
          setNodeOwnerKey(this, fn.nodeKey);
      },
      get: function () {
          return this[ShadowResolverPrivateKey];
      },
      configurable: true,
      enumerable: true
  });
  function getShadowRootResolver(node) {
      return node[ShadowRootResolverKey];
  }
  function setShadowRootResolver(node, fn) {
      node[ShadowRootResolverKey] = fn;
  }
  function isDelegatingFocus(host) {
      return getInternalSlot(host).delegatesFocus;
  }
  function getHost(root) {
      return getInternalSlot(root).host;
  }
  function getShadowRoot(elm) {
      return getInternalSlot(elm).shadowRoot;
  }
  function isHostElement(elm) {
      return !isUndefined(getHiddenField(elm, InternalSlot));
  }
  var uid = 0;
  function attachShadow$1(elm, options) {
      if (!isUndefined(getHiddenField(elm, InternalSlot))) {
          throw new Error("Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.");
      }
      var mode = options.mode, delegatesFocus = options.delegatesFocus;
      var doc = getOwnerDocument(elm);
      var sr = createDocumentFragment.call(doc);
      var record = {
          mode: mode,
          delegatesFocus: !!delegatesFocus,
          host: elm,
          shadowRoot: sr
      };
      setHiddenField(sr, InternalSlot, record);
      setHiddenField(elm, InternalSlot, record);
      var shadowResolver = function () { return sr; };
      var x = shadowResolver.nodeKey = uid++;
      setNodeKey(elm, x);
      setShadowRootResolver(sr, shadowResolver);
      setPrototypeOf(sr, SyntheticShadowRoot.prototype);
      return sr;
  }
  var SyntheticShadowRootDescriptors = {
      constructor: {
          writable: true,
          configurable: true,
          value: SyntheticShadowRoot
      },
      toString: {
          writable: true,
          configurable: true,
          value: function () {
              return "[object ShadowRoot]";
          }
      }
  };
  var ShadowRootDescriptors = {
      activeElement: {
          enumerable: true,
          configurable: true,
          get: function () {
              var host = getHost(this);
              var doc = getOwnerDocument(host);
              var activeElement = DocumentPrototypeActiveElement.call(doc);
              if (isNull(activeElement)) {
                  return activeElement;
              }
              if ((compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) === 0) {
                  return null;
              }
              var node = activeElement;
              while (!isNodeOwnedBy(host, node)) {
                  node = parentElementGetter.call(node);
              }
              if (isSlotElement(node)) {
                  return null;
              }
              return node;
          }
      },
      delegatesFocus: {
          configurable: true,
          get: function () {
              return getInternalSlot(this).delegatesFocus;
          }
      },
      elementFromPoint: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (left, top) {
              var host = getHost(this);
              var doc = getOwnerDocument(host);
              var element = elementFromPoint.call(doc, left, top);
              if (isNull(element)) {
                  return element;
              }
              return retarget(this, pathComposer(element, true));
          }
      },
      elementsFromPoint: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (_left, _top) {
              throw new Error();
          }
      },
      getSelection: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function () {
              throw new Error();
          }
      },
      host: {
          enumerable: true,
          configurable: true,
          get: function () {
              return getHost(this);
          }
      },
      mode: {
          configurable: true,
          get: function () {
              return getInternalSlot(this).mode;
          }
      },
      styleSheets: {
          enumerable: true,
          configurable: true,
          get: function () {
              throw new Error();
          }
      }
  };
  var NodePatchDescriptors = {
      insertBefore: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (newChild, refChild) {
              insertBefore.call(getHost(this), newChild, refChild);
              return newChild;
          }
      },
      removeChild: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (oldChild) {
              removeChild.call(getHost(this), oldChild);
              return oldChild;
          }
      },
      appendChild: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (newChild) {
              appendChild.call(getHost(this), newChild);
              return newChild;
          }
      },
      replaceChild: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (newChild, oldChild) {
              replaceChild.call(getHost(this), newChild, oldChild);
              return oldChild;
          }
      },
      addEventListener: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (type, listener, options) {
              addShadowRootEventListener(this, type, listener);
          }
      },
      removeEventListener: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (type, listener, options) {
              removeShadowRootEventListener(this, type, listener);
          }
      },
      baseURI: {
          enumerable: true,
          configurable: true,
          get: function () {
              return getHost(this).baseURI;
          }
      },
      childNodes: {
          enumerable: true,
          configurable: true,
          get: function () {
              return createStaticNodeList(shadowRootChildNodes(this));
          }
      },
      compareDocumentPosition: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (otherNode) {
              var host = getHost(this);
              if (this === otherNode) {
                  return 0;
              }
              else if (this.contains(otherNode)) {
                  return 20;
              }
              else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {
                  return 37;
              }
              else {
                  return 35;
              }
          }
      },
      contains: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (otherNode) {
              if (this === otherNode) {
                  return true;
              }
              var host = getHost(this);
              return (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 && isNodeOwnedBy(host, otherNode);
          }
      },
      firstChild: {
          enumerable: true,
          configurable: true,
          get: function () {
              var childNodes = getInternalChildNodes(this);
              return childNodes[0] || null;
          }
      },
      lastChild: {
          enumerable: true,
          configurable: true,
          get: function () {
              var childNodes = getInternalChildNodes(this);
              return childNodes[childNodes.length - 1] || null;
          }
      },
      hasChildNodes: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function () {
              var childNodes = getInternalChildNodes(this);
              return childNodes.length > 0;
          }
      },
      isConnected: {
          enumerable: true,
          configurable: true,
          get: function () {
              return isConnected.call(getHost(this));
          }
      },
      nextSibling: {
          enumerable: true,
          configurable: true,
          get: function () {
              return null;
          }
      },
      previousSibling: {
          enumerable: true,
          configurable: true,
          get: function () {
              return null;
          }
      },
      nodeName: {
          enumerable: true,
          configurable: true,
          get: function () {
              return '#document-fragment';
          }
      },
      nodeType: {
          enumerable: true,
          configurable: true,
          get: function () {
              return 11;
          }
      },
      nodeValue: {
          enumerable: true,
          configurable: true,
          get: function () {
              return null;
          }
      },
      ownerDocument: {
          enumerable: true,
          configurable: true,
          get: function () {
              return getHost(this).ownerDocument;
          }
      },
      parentElement: {
          enumerable: true,
          configurable: true,
          get: function () {
              return null;
          }
      },
      parentNode: {
          enumerable: true,
          configurable: true,
          get: function () {
              return null;
          }
      },
      textContent: {
          enumerable: true,
          configurable: true,
          get: function () {
              var childNodes = getInternalChildNodes(this);
              var textContent = '';
              for (var i = 0, len = childNodes.length; i < len; i += 1) {
                  var currentNode = childNodes[i];
                  if (currentNode.nodeType !== COMMENT_NODE) {
                      textContent += getTextContent(currentNode);
                  }
              }
              return textContent;
          },
          set: function (v) {
              var host = getHost(this);
              textContextSetter.call(host, v);
          }
      },
      getRootNode: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (options) {
              return !isUndefined(options) && isTrue$1(options.composed) ? getHost(this).getRootNode(options) : this;
          }
      }
  };
  var ElementPatchDescriptors = {
      innerHTML: {
          enumerable: true,
          configurable: true,
          get: function () {
              var childNodes = getInternalChildNodes(this);
              var innerHTML = '';
              for (var i = 0, len = childNodes.length; i < len; i += 1) {
                  innerHTML += getOuterHTML(childNodes[i]);
              }
              return innerHTML;
          },
          set: function (v) {
              var host = getHost(this);
              innerHTMLSetter.call(host, v);
          }
      }
  };
  var ParentNodePatchDescriptors = {
      childElementCount: {
          enumerable: true,
          configurable: true,
          get: function () {
              return this.children.length;
          }
      },
      children: {
          enumerable: true,
          configurable: true,
          get: function () {
              return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), function (elm) { return elm instanceof Element; }));
          }
      },
      firstElementChild: {
          enumerable: true,
          configurable: true,
          get: function () {
              return this.children[0] || null;
          }
      },
      lastElementChild: {
          enumerable: true,
          configurable: true,
          get: function () {
              var children = this.children;
              return children.item(children.length - 1) || null;
          }
      },
      querySelector: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (selectors) {
              return shadowRootQuerySelector(this, selectors);
          }
      },
      querySelectorAll: {
          writable: true,
          enumerable: true,
          configurable: true,
          value: function (selectors) {
              return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));
          }
      }
  };
  assign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);
  function SyntheticShadowRoot() {
      throw new TypeError('Illegal constructor');
  }
  SyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);
  function foldSlotElement(slot) {
      var parent = parentElementGetter.call(slot);
      while (!isNull(parent) && isSlotElement(parent)) {
          slot = parent;
          parent = parentElementGetter.call(slot);
      }
      return slot;
  }
  function isNodeSlotted(host, node) {
      var hostKey = getNodeKey(host);
      var currentElement = node instanceof Element ? node : parentElementGetter.call(node);
      while (!isNull(currentElement) && currentElement !== host) {
          var elmOwnerKey = getNodeNearestOwnerKey(currentElement);
          var parent = parentElementGetter.call(currentElement);
          if (elmOwnerKey === hostKey) {
              return isSlotElement(currentElement);
          }
          else if (parent === host) {
              return false;
          }
          else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {
              if (isSlotElement(parent)) {
                  currentElement = getNodeOwner(foldSlotElement(parent));
                  if (!isNull(currentElement)) {
                      if (currentElement === host) {
                          return true;
                      }
                      else if (getNodeNearestOwnerKey(currentElement) === hostKey) {
                          return true;
                      }
                  }
              }
              else {
                  return false;
              }
          }
          else {
              currentElement = parent;
          }
      }
      return false;
  }
  function getNodeOwner(node) {
      if (!(node instanceof Node)) {
          return null;
      }
      var ownerKey = getNodeNearestOwnerKey(node);
      if (isUndefined(ownerKey)) {
          return null;
      }
      var nodeOwner = node;
      while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {
          nodeOwner = parentNodeGetter.call(nodeOwner);
      }
      if (isNull(nodeOwner)) {
          return null;
      }
      return nodeOwner;
  }
  function isSlotElement(node) {
      return node instanceof HTMLSlotElement;
  }
  function isNodeOwnedBy(owner, node) {
      var ownerKey = getNodeNearestOwnerKey(node);
      return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;
  }
  function shadowRootChildNodes(root) {
      var elm = getHost(root);
      return getAllMatches(elm, arrayFromCollection(childNodesGetter.call(elm)));
  }
  function getAllSlottedMatches(host, nodeList) {
      var filteredAndPatched = [];
      for (var i = 0, len = nodeList.length; i < len; i += 1) {
          var node = nodeList[i];
          if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
              ArrayPush.call(filteredAndPatched, node);
          }
      }
      return filteredAndPatched;
  }
  function getFirstSlottedMatch(host, nodeList) {
      for (var i = 0, len = nodeList.length; i < len; i += 1) {
          var node = nodeList[i];
          if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {
              return node;
          }
      }
      return null;
  }
  function getAllMatches(owner, nodeList) {
      var filteredAndPatched = [];
      for (var i = 0, len = nodeList.length; i < len; i += 1) {
          var node = nodeList[i];
          var isOwned = isNodeOwnedBy(owner, node);
          if (isOwned) {
              ArrayPush.call(filteredAndPatched, node);
          }
      }
      return filteredAndPatched;
  }
  function getFirstMatch(owner, nodeList) {
      for (var i = 0, len = nodeList.length; i < len; i += 1) {
          if (isNodeOwnedBy(owner, nodeList[i])) {
              return nodeList[i];
          }
      }
      return null;
  }
  function shadowRootQuerySelector(root, selector) {
      var elm = getHost(root);
      var nodeList = arrayFromCollection(querySelectorAll.call(elm, selector));
      return getFirstMatch(elm, nodeList);
  }
  function shadowRootQuerySelectorAll(root, selector) {
      var elm = getHost(root);
      var nodeList = querySelectorAll.call(elm, selector);
      return getAllMatches(elm, arrayFromCollection(nodeList));
  }
  function getFilteredChildNodes(node) {
      var children;
      if (!isHostElement(node) && !isSlotElement(node)) {
          children = childNodesGetter.call(node);
          return arrayFromCollection(children);
      }
      if (isHostElement(node)) {
          var slots = arrayFromCollection(querySelectorAll.call(node, 'slot'));
          var resolver_1 = getShadowRootResolver(getShadowRoot(node));
          return ArrayReduce.call(slots, function (seed, slot) {
              if (resolver_1 === getShadowRootResolver(slot)) {
                  ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));
              }
              return seed;
          }, []);
      }
      else {
          children = arrayFromCollection(childNodesGetter.call(node));
          var resolver_2 = getShadowRootResolver(node);
          return ArrayReduce.call(children, function (seed, child) {
              if (resolver_2 === getShadowRootResolver(child)) {
                  ArrayPush.call(seed, child);
              }
              return seed;
          }, []);
      }
  }
  function getFilteredSlotAssignedNodes(slot) {
      var owner = getNodeOwner(slot);
      if (isNull(owner)) {
          return [];
      }
      var childNodes = arrayFromCollection(childNodesGetter.call(slot));
      return ArrayReduce.call(childNodes, function (seed, child) {
          if (!isNodeOwnedBy(owner, child)) {
              ArrayPush.call(seed, child);
          }
          return seed;
      }, []);
  }
  var OwnKey = '$$OwnKey$$';
  var OwnerKey = '$$OwnerKey$$';
  var hasNativeSymbolsSupport$2 = Symbol('x').toString() === 'Symbol(x)';
  function getNodeOwnerKey(node) {
      return node[OwnerKey];
  }
  function setNodeOwnerKey(node, value) {
      {
          node[OwnerKey] = value;
      }
  }
  function getNodeKey(node) {
      return node[OwnKey];
  }
  function setNodeKey(node, value) {
      {
          node[OwnKey] = value;
      }
  }
  function getNodeNearestOwnerKey(node) {
      var ownerNode = node;
      var ownerKey;
      while (!isNull(ownerNode)) {
          ownerKey = getNodeOwnerKey(ownerNode);
          if (!isUndefined(ownerKey)) {
              return ownerKey;
          }
          ownerNode = parentNodeGetter.call(ownerNode);
      }
  }
  function isNodeShadowed(node) {
      return !isUndefined(getNodeOwnerKey(node));
  }
  function isNodeDeepShadowed(node) {
      return !isUndefined(getNodeNearestOwnerKey(node));
  }
  function hasMountedChildren(node) {
      return isSlotElement(node) || isHostElement(node);
  }
  function getShadowParent(node, value) {
      var owner = getNodeOwner(node);
      if (value === owner) {
          return getShadowRoot(owner);
      }
      else if (value instanceof Element) {
          if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {
              return value;
          }
          else if (!isNull(owner) && isSlotElement(value)) {
              var slotOwner = getNodeOwner(value);
              if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {
                  return slotOwner;
              }
          }
      }
      return null;
  }
  function hasChildNodesPatched() {
      return getInternalChildNodes(this).length > 0;
  }
  function firstChildGetterPatched() {
      var childNodes = getInternalChildNodes(this);
      return childNodes[0] || null;
  }
  function lastChildGetterPatched() {
      var childNodes = getInternalChildNodes(this);
      return childNodes[childNodes.length - 1] || null;
  }
  function textContentGetterPatched() {
      return getTextContent(this);
  }
  function textContentSetterPatched(value) {
      textContextSetter.call(this, value);
  }
  function parentNodeGetterPatched() {
      var value = parentNodeGetter.call(this);
      if (isNull(value)) {
          return value;
      }
      return getShadowParent(this, value);
  }
  function parentElementGetterPatched() {
      var value = parentNodeGetter.call(this);
      if (isNull(value)) {
          return null;
      }
      var parentNode = getShadowParent(this, value);
      return parentNode instanceof Element ? parentNode : null;
  }
  function compareDocumentPositionPatched(otherNode) {
      if (this.getRootNode() === otherNode) {
          return 10;
      }
      else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
          return 35;
      }
      return compareDocumentPosition.call(this, otherNode);
  }
  function containsPatched(otherNode) {
      if (otherNode == null || getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {
          return false;
      }
      return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;
  }
  function cloneNodePatched(deep) {
      var clone = cloneNode.call(this, false);
      if (!deep) {
          return clone;
      }
      var childNodes = getInternalChildNodes(this);
      for (var i = 0, len = childNodes.length; i < len; i += 1) {
          clone.appendChild(childNodes[i].cloneNode(true));
      }
      return clone;
  }
  function childNodesGetterPatched() {
      if (this instanceof Element && isHostElement(this)) {
          var owner = getNodeOwner(this);
          var childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
          return createStaticNodeList(childNodes);
      }
      return childNodesGetter.call(this);
  }
  var nativeGetRootNode = Node.prototype.getRootNode;
  var getDocumentOrRootNode = !isUndefined(nativeGetRootNode) ? nativeGetRootNode : function () {
      var node = this;
      var nodeParent;
      while (!isNull(nodeParent = parentNodeGetter.call(node))) {
          node = nodeParent;
      }
      return node;
  };
  function getNearestRoot(node) {
      var ownerNode = getNodeOwner(node);
      if (isNull(ownerNode)) {
          return getDocumentOrRootNode.call(node);
      }
      return getShadowRoot(ownerNode);
  }
  function getRootNodePatched(options) {
      var composed = isUndefined(options) ? false : !!options.composed;
      return isTrue$1(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);
  }
  defineProperties(Node.prototype, {
      firstChild: {
          get: function () {
              if (hasMountedChildren(this)) {
                  return firstChildGetterPatched.call(this);
              }
              return firstChildGetter.call(this);
          },
          enumerable: true,
          configurable: true
      },
      lastChild: {
          get: function () {
              if (hasMountedChildren(this)) {
                  return lastChildGetterPatched.call(this);
              }
              return lastChildGetter.call(this);
          },
          enumerable: true,
          configurable: true
      },
      textContent: {
          get: function () {
              if (!runtimeFlags.ENABLE_NODE_PATCH) {
                  if (isNodeShadowed(this) || isHostElement(this)) {
                      return textContentGetterPatched.call(this);
                  }
                  return textContentGetter.call(this);
              }
              if (isGlobalPatchingSkipped(this)) {
                  return textContentGetter.call(this);
              }
              return textContentGetterPatched.call(this);
          },
          set: textContentSetterPatched,
          enumerable: true,
          configurable: true
      },
      parentNode: {
          get: function () {
              if (isNodeShadowed(this)) {
                  return parentNodeGetterPatched.call(this);
              }
              return parentNodeGetter.call(this);
          },
          enumerable: true,
          configurable: true
      },
      parentElement: {
          get: function () {
              if (isNodeShadowed(this)) {
                  return parentElementGetterPatched.call(this);
              }
              return parentElementGetter.call(this);
          },
          enumerable: true,
          configurable: true
      },
      childNodes: {
          get: function () {
              if (hasMountedChildren(this)) {
                  return childNodesGetterPatched.call(this);
              }
              return childNodesGetter.call(this);
          },
          enumerable: true,
          configurable: true
      },
      hasChildNodes: {
          value: function () {
              if (hasMountedChildren(this)) {
                  return hasChildNodesPatched.call(this);
              }
              return hasChildNodes.call(this);
          },
          enumerable: true,
          writable: true,
          configurable: true
      },
      compareDocumentPosition: {
          value: function (otherNode) {
              if (isGlobalPatchingSkipped(this)) {
                  return compareDocumentPosition.call(this, otherNode);
              }
              return compareDocumentPositionPatched.call(this, otherNode);
          },
          enumerable: true,
          writable: true,
          configurable: true
      },
      contains: {
          value: function (otherNode) {
              if (this === otherNode) {
                  return true;
              }
              if (!runtimeFlags.ENABLE_NODE_PATCH) {
                  if (otherNode == null) {
                      return false;
                  }
                  if (isNodeShadowed(this) || isHostElement(this)) {
                      return containsPatched.call(this, otherNode);
                  }
                  return contains.call(this, otherNode);
              }
              if (isGlobalPatchingSkipped(this)) {
                  return contains.call(this, otherNode);
              }
              return containsPatched.call(this, otherNode);
          },
          enumerable: true,
          writable: true,
          configurable: true
      },
      cloneNode: {
          value: function (deep) {
              if (!runtimeFlags.ENABLE_NODE_PATCH) {
                  if (isNodeShadowed(this) || isHostElement(this)) {
                      return cloneNodePatched.call(this, deep);
                  }
                  return cloneNode.call(this, deep);
              }
              if (isTrue$1(deep)) {
                  if (isGlobalPatchingSkipped(this)) {
                      return cloneNode.call(this, deep);
                  }
                  return cloneNodePatched.call(this, deep);
              }
              return cloneNode.call(this, deep);
          },
          enumerable: true,
          writable: true,
          configurable: true
      },
      getRootNode: {
          value: getRootNodePatched,
          enumerable: true,
          configurable: true,
          writable: true
      },
      isConnected: {
          enumerable: true,
          configurable: true,
          get: function () {
              return isConnected.call(this);
          }
      }
  });
  var getInternalChildNodes =  function (node) {
      return node.childNodes;
  };
  if (hasOwnProperty.call(HTMLElement.prototype, 'contains')) {
      defineProperty(HTMLElement.prototype, 'contains', getOwnPropertyDescriptor(Node.prototype, 'contains'));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, 'parentElement')) {
      defineProperty(HTMLElement.prototype, 'parentElement', getOwnPropertyDescriptor(Node.prototype, 'parentElement'));
  }
  function elemFromPoint(left, top) {
      var element = elementFromPoint.call(this, left, top);
      if (isNull(element)) {
          return element;
      }
      return retarget(this, pathComposer(element, true));
  }
  Document.prototype.elementFromPoint = elemFromPoint;
  defineProperty(Document.prototype, 'activeElement', {
      get: function () {
          var node = DocumentPrototypeActiveElement.call(this);
          if (isNull(node)) {
              return node;
          }
          while (!isUndefined(getNodeOwnerKey(node))) {
              node = parentElementGetter.call(node);
              if (isNull(node)) {
                  return null;
              }
          }
          if (node.tagName === 'HTML') {
              node = this.body;
          }
          return node;
      },
      enumerable: true,
      configurable: true
  });
  defineProperty(Document.prototype, 'getElementById', {
      value: function () {
          var elm = getElementById.apply(this, ArraySlice.call(arguments));
          if (isNull(elm)) {
              return null;
          }
          return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;
      },
      writable: true,
      enumerable: true,
      configurable: true
  });
  defineProperty(Document.prototype, 'querySelector', {
      value: function () {
          var elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
          var filtered = ArrayFind.call(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
          return !isUndefined(filtered) ? filtered : null;
      },
      writable: true,
      enumerable: true,
      configurable: true
  });
  defineProperty(Document.prototype, 'querySelectorAll', {
      value: function () {
          var elements = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));
          var filtered = ArrayFilter.call(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
          return createStaticNodeList(filtered);
      },
      writable: true,
      enumerable: true,
      configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByClassName', {
      value: function () {
          var elements = arrayFromCollection(getElementsByClassName$1.apply(this, ArraySlice.call(arguments)));
          var filtered = ArrayFilter.call(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
          return createStaticHTMLCollection(filtered);
      },
      writable: true,
      enumerable: true,
      configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByTagName', {
      value: function () {
          var elements = arrayFromCollection(getElementsByTagName$1.apply(this, ArraySlice.call(arguments)));
          var filtered = ArrayFilter.call(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
          return createStaticHTMLCollection(filtered);
      },
      writable: true,
      enumerable: true,
      configurable: true
  });
  defineProperty(Document.prototype, 'getElementsByTagNameNS', {
      value: function () {
          var elements = arrayFromCollection(getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments)));
          var filtered = ArrayFilter.call(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
          return createStaticHTMLCollection(filtered);
      },
      writable: true,
      enumerable: true,
      configurable: true
  });
  defineProperty(getOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName') ? HTMLDocument.prototype : Document.prototype, 'getElementsByName', {
      value: function () {
          var elements = arrayFromCollection(getElementsByName.apply(this, ArraySlice.call(arguments)));
          var filtered = ArrayFilter.call(elements, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm); });
          return createStaticNodeList(filtered);
      },
      writable: true,
      enumerable: true,
      configurable: true
  });
  Object.defineProperty(window, 'ShadowRoot', {
      value: SyntheticShadowRoot,
      configurable: true,
      writable: true
  });
  function doesEventNeedsPatch(e) {
      var originalTarget = eventTargetGetter.call(e);
      return originalTarget instanceof Node && isNodeDeepShadowed(originalTarget);
  }
  function isValidEventListener(listener) {
      return isFunction(listener) || !isNull(listener) && isObject(listener) && isFunction(listener.handleEvent);
  }
  function getEventListenerWrapper(listener) {
      if ('$$lwcEventWrapper$$' in listener) {
          return listener.$$lwcEventWrapper$$;
      }
      var isHandlerFunction = isFunction(listener);
      var wrapperFn = listener.$$lwcEventWrapper$$ = function (e) {
          if (doesEventNeedsPatch(e)) {
              patchEvent(e);
          }
          return isHandlerFunction ? listener.call(this, e) : listener.handleEvent && listener.handleEvent(e);
      };
      return wrapperFn;
  }
  function windowAddEventListener$1(type, listener, optionsOrCapture) {
      if (!isValidEventListener(listener)) {
          return;
      }
      var wrapperFn = getEventListenerWrapper(listener);
      windowAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }
  function windowRemoveEventListener$1(type, listener, optionsOrCapture) {
      if (!isValidEventListener(listener)) {
          return;
      }
      var wrapperFn = getEventListenerWrapper(listener);
      windowRemoveEventListener.call(this, type, wrapperFn || listener, optionsOrCapture);
  }
  function addEventListener$1(type, listener, optionsOrCapture) {
      if (!isValidEventListener(listener)) {
          return;
      }
      var wrapperFn = getEventListenerWrapper(listener);
      addEventListener.call(this, type, wrapperFn, optionsOrCapture);
  }
  function removeEventListener$1(type, listener, optionsOrCapture) {
      if (!isValidEventListener(listener)) {
          return;
      }
      var wrapperFn = getEventListenerWrapper(listener);
      removeEventListener.call(this, type, wrapperFn || listener, optionsOrCapture);
  }
  window.addEventListener = windowAddEventListener$1;
  window.removeEventListener = windowRemoveEventListener$1;
  var protoToBePatched = typeof EventTarget !== 'undefined' ? EventTarget.prototype : Node.prototype;
  defineProperties(protoToBePatched, {
      addEventListener: {
          value: addEventListener$1,
          enumerable: true,
          writable: true,
          configurable: true
      },
      removeEventListener: {
          value: removeEventListener$1,
          enumerable: true,
          writable: true,
          configurable: true
      }
  });
  var composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');
  function detect$1() {
      if (!composedDescriptor) {
          return false;
      }
      var clickEvent = new Event('click');
      var button = document.createElement('button');
      button.addEventListener('click', function (event) { return clickEvent = event; });
      button.click();
      return !composedDescriptor.get.call(clickEvent);
  }
  var originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');
  function handleClick(event) {
      Object.defineProperty(event, 'composed', {
          configurable: true,
          enumerable: true,
          get: function () {
              return true;
          }
      });
  }
  function apply$1() {
      HTMLElement.prototype.click = function () {
          addEventListener.call(this, 'click', handleClick);
          try {
              originalClickDescriptor.value.call(this);
          }
          finally {
              removeEventListener.call(this, 'click', handleClick);
          }
      };
  }
  if (detect$1()) {
      apply$1();
  }
  function detect$2() {
      return new Event('test', {
          composed: true
      }).composed !== true;
  }
  function apply$2() {
      var composedEvents = assign(create(null), {
          beforeinput: 1,
          blur: 1,
          click: 1,
          compositionend: 1,
          compositionstart: 1,
          compositionupdate: 1,
          copy: 1,
          cut: 1,
          dblclick: 1,
          DOMActivate: 1,
          DOMFocusIn: 1,
          DOMFocusOut: 1,
          drag: 1,
          dragend: 1,
          dragenter: 1,
          dragleave: 1,
          dragover: 1,
          dragstart: 1,
          drop: 1,
          focus: 1,
          focusin: 1,
          focusout: 1,
          gotpointercapture: 1,
          input: 1,
          keydown: 1,
          keypress: 1,
          keyup: 1,
          lostpointercapture: 1,
          mousedown: 1,
          mouseenter: 1,
          mouseleave: 1,
          mousemove: 1,
          mouseout: 1,
          mouseover: 1,
          mouseup: 1,
          paste: 1,
          pointercancel: 1,
          pointerdown: 1,
          pointerenter: 1,
          pointerleave: 1,
          pointermove: 1,
          pointerout: 1,
          pointerover: 1,
          pointerup: 1,
          touchcancel: 1,
          touchend: 1,
          touchmove: 1,
          touchstart: 1,
          wheel: 1
      });
      var EventConstructor = Event;
      function PatchedEvent(type, eventInitDict) {
          var event = new EventConstructor(type, eventInitDict);
          var isComposed = !!(eventInitDict && eventInitDict.composed);
          Object.defineProperties(event, {
              composed: {
                  get: function () {
                      return isComposed;
                  },
                  configurable: true,
                  enumerable: true
              }
          });
          return event;
      }
      PatchedEvent.prototype = EventConstructor.prototype;
      PatchedEvent.AT_TARGET = EventConstructor.AT_TARGET;
      PatchedEvent.BUBBLING_PHASE = EventConstructor.BUBBLING_PHASE;
      PatchedEvent.CAPTURING_PHASE = EventConstructor.CAPTURING_PHASE;
      PatchedEvent.NONE = EventConstructor.NONE;
      window.Event = PatchedEvent;
      Object.defineProperties(Event.prototype, {
          composed: {
              get: function () {
                  var type = this.type;
                  return composedEvents[type] === 1;
              },
              configurable: true,
              enumerable: true
          }
      });
  }
  if (detect$2()) {
      apply$2();
  }
  var CustomEventConstructor = CustomEvent;
  function PatchedCustomEvent(type, eventInitDict) {
      var event = new CustomEventConstructor(type, eventInitDict);
      var isComposed = !!(eventInitDict && eventInitDict.composed);
      Object.defineProperties(event, {
          composed: {
              get: function () {
                  return isComposed;
              },
              configurable: true,
              enumerable: true
          }
      });
      return event;
  }
  PatchedCustomEvent.prototype = CustomEventConstructor.prototype;
  window.CustomEvent = PatchedCustomEvent;
  if (typeof ClipboardEvent !== 'undefined') {
      var isComposedType_1 = assign(create(null), {
          copy: 1,
          cut: 1,
          paste: 1
      });
      defineProperties(ClipboardEvent.prototype, {
          composed: {
              get: function () {
                  var type = this.type;
                  return isComposedType_1[type] === 1;
              },
              configurable: true,
              enumerable: true
          }
      });
  }
  function detect$3() {
      return typeof HTMLIFrameElement !== 'undefined';
  }
  function apply$3() {
      var desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');
      var originalGetter = desc.get;
      desc.get = function () {
          var original = originalGetter.call(this);
          if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {
              return original;
          }
          return wrapIframeWindow(original);
      };
      defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);
  }
  function wrapIframeWindow(win) {
      return {
          addEventListener: function () {
              return win.addEventListener.apply(win, arguments);
          },
          blur: function () {
              return win.blur.apply(win, arguments);
          },
          close: function () {
              return win.close.apply(win, arguments);
          },
          focus: function () {
              return win.focus.apply(win, arguments);
          },
          postMessage: function () {
              return win.postMessage.apply(win, arguments);
          },
          removeEventListener: function () {
              return win.removeEventListener.apply(win, arguments);
          },
          get closed() {
              return win.closed;
          },
          get frames() {
              return win.frames;
          },
          get length() {
              return win.length;
          },
          get location() {
              return win.location;
          },
          set location(value) {
              win.location = value;
          },
          get opener() {
              return win.opener;
          },
          get parent() {
              return win.parent;
          },
          get self() {
              return win.self;
          },
          get top() {
              return win.top;
          },
          get window() {
              return win.window;
          }
      };
  }
  if (detect$3()) {
      apply$3();
  }
  var OriginalMutationObserver = MutationObserver;
  var _l = OriginalMutationObserver.prototype, originalDisconnect = _l.disconnect, originalObserve = _l.observe, originalTakeRecords = _l.takeRecords;
  var wrapperLookupField = '$$lwcObserverCallbackWrapper$$';
  var observerLookupField = '$$lwcNodeObservers$$';
  var observerToNodesMap = new WeakMap();
  function getNodeObservers(node) {
      return node[observerLookupField];
  }
  function setNodeObservers(node, observers) {
      node[observerLookupField] = observers;
  }
  function retargetMutationRecord(originalRecord) {
      var addedNodes = originalRecord.addedNodes, removedNodes = originalRecord.removedNodes, target = originalRecord.target, type = originalRecord.type;
      var retargetedRecord = create(MutationRecord.prototype);
      defineProperties(retargetedRecord, {
          addedNodes: {
              get: function () {
                  return addedNodes;
              },
              enumerable: true,
              configurable: true
          },
          removedNodes: {
              get: function () {
                  return removedNodes;
              },
              enumerable: true,
              configurable: true
          },
          type: {
              get: function () {
                  return type;
              },
              enumerable: true,
              configurable: true
          },
          target: {
              get: function () {
                  return target.shadowRoot;
              },
              enumerable: true,
              configurable: true
          }
      });
      return retargetedRecord;
  }
  function isQualifiedObserver(observer, target) {
      var parentNode = target;
      while (!isNull(parentNode)) {
          var parentNodeObservers = getNodeObservers(parentNode);
          if (!isUndefined(parentNodeObservers) && (parentNodeObservers[0] === observer || ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {
              return true;
          }
          parentNode = parentNode.parentNode;
      }
      return false;
  }
  function filterMutationRecords(mutations, observer) {
      return ArrayReduce.call(mutations, function (filteredSet, record) {
          var target = record.target, addedNodes = record.addedNodes, removedNodes = record.removedNodes, type = record.type;
          if (type === 'childList' && !isUndefined(getNodeKey(target))) {
              if (addedNodes.length > 0) {
                  var sampleNode = addedNodes[0];
                  if (isQualifiedObserver(observer, sampleNode)) {
                      var nodeObservers = getNodeObservers(target);
                      if (nodeObservers && (nodeObservers[0] === observer || ArrayIndexOf.call(nodeObservers, observer) !== -1)) {
                          ArrayPush.call(filteredSet, record);
                      }
                      else {
                          ArrayPush.call(filteredSet, retargetMutationRecord(record));
                      }
                  }
              }
              else {
                  var shadowRoot = target.shadowRoot;
                  var sampleNode = removedNodes[0];
                  if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && isQualifiedObserver(observer, target)) {
                      ArrayPush.call(filteredSet, record);
                  }
                  else if (shadowRoot) {
                      var shadowRootObservers = getNodeObservers(shadowRoot);
                      if (shadowRootObservers && (shadowRootObservers[0] === observer || ArrayIndexOf.call(shadowRootObservers, observer) !== -1)) {
                          ArrayPush.call(filteredSet, retargetMutationRecord(record));
                      }
                  }
              }
          }
          else {
              if (isQualifiedObserver(observer, target)) {
                  ArrayPush.call(filteredSet, record);
              }
          }
          return filteredSet;
      }, []);
  }
  function getWrappedCallback(callback) {
      var wrappedCallback = callback[wrapperLookupField];
      if (isUndefined(wrappedCallback)) {
          wrappedCallback = callback[wrapperLookupField] = function (mutations, observer) {
              var filteredRecords = filterMutationRecords(mutations, observer);
              if (filteredRecords.length === 0) {
                  return;
              }
              callback.call(observer, filteredRecords, observer);
          };
      }
      return wrappedCallback;
  }
  function PatchedMutationObserver(callback) {
      var wrappedCallback = getWrappedCallback(callback);
      var observer = new OriginalMutationObserver(wrappedCallback);
      return observer;
  }
  function patchedDisconnect() {
      var _this = this;
      originalDisconnect.call(this);
      var observedNodes = observerToNodesMap.get(this);
      if (!isUndefined(observedNodes)) {
          forEach.call(observedNodes, function (observedNode) {
              var observers = observedNode[observerLookupField];
              if (!isUndefined(observers)) {
                  var index = ArrayIndexOf.call(observers, _this);
                  if (index !== -1) {
                      ArraySplice.call(observers, index, 1);
                  }
              }
          });
          observedNodes.length = 0;
      }
  }
  function patchedObserve(target, options) {
      var targetObservers = getNodeObservers(target);
      if (isUndefined(targetObservers)) {
          targetObservers = [];
          setNodeObservers(target, targetObservers);
      }
      if (ArrayIndexOf.call(targetObservers, this) === -1) {
          ArrayPush.call(targetObservers, this);
      }
      if (target instanceof SyntheticShadowRoot) {
          target = target.host;
      }
      if (observerToNodesMap.has(this)) {
          var observedNodes = observerToNodesMap.get(this);
          if (ArrayIndexOf.call(observedNodes, target) === -1) {
              ArrayPush.call(observedNodes, target);
          }
      }
      else {
          observerToNodesMap.set(this, [target]);
      }
      return originalObserve.call(this, target, options);
  }
  function patchedTakeRecords() {
      return filterMutationRecords(originalTakeRecords.call(this), this);
  }
  PatchedMutationObserver.prototype = OriginalMutationObserver.prototype;
  PatchedMutationObserver.prototype.disconnect = patchedDisconnect;
  PatchedMutationObserver.prototype.observe = patchedObserve;
  PatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;
  defineProperty(window, 'MutationObserver', {
      value: PatchedMutationObserver,
      configurable: true,
      writable: true
  });
  var observer;
  var observerConfig = {
      childList: true
  };
  var SlotChangeKey = createHiddenField('slotchange', 'synthetic-shadow');
  function initSlotObserver() {
      return new MO(function (mutations) {
          var slots = [];
          forEach.call(mutations, function (mutation) {
              var slot = mutation.target;
              if (ArrayIndexOf.call(slots, slot) === -1) {
                  ArrayPush.call(slots, slot);
                  dispatchEvent.call(slot, new CustomEvent('slotchange'));
              }
          });
      });
  }
  function getFilteredSlotFlattenNodes(slot) {
      var childNodes = arrayFromCollection(childNodesGetter.call(slot));
      return ArrayReduce.call(childNodes, function (seed, child) {
          if (child instanceof Element && isSlotElement(child)) {
              ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));
          }
          else {
              ArrayPush.call(seed, child);
          }
          return seed;
      }, []);
  }
  function assignedSlotGetterPatched() {
      var parentNode = parentNodeGetter.call(this);
      if (isNull(parentNode) || !isSlotElement(parentNode) || getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {
          return null;
      }
      return parentNode;
  }
  defineProperties(HTMLSlotElement.prototype, {
      addEventListener: {
          value: function (type, listener, options) {
              HTMLElement.prototype.addEventListener.call(this, type, listener, options);
              if (type === 'slotchange' && !getHiddenField(this, SlotChangeKey)) {
                  setHiddenField(this, SlotChangeKey, true);
                  if (!observer) {
                      observer = initSlotObserver();
                  }
                  MutationObserverObserve.call(observer, this, observerConfig);
              }
          },
          writable: true,
          enumerable: true,
          configurable: true
      },
      assignedElements: {
          value: function (options) {
              if (isNodeShadowed(this)) {
                  var flatten = !isUndefined(options) && isTrue$1(options.flatten);
                  var nodes = flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
                  return ArrayFilter.call(nodes, function (node) { return node instanceof Element; });
              }
              else {
                  return assignedElements.apply(this, ArraySlice.call(arguments));
              }
          },
          writable: true,
          enumerable: true,
          configurable: true
      },
      assignedNodes: {
          value: function (options) {
              if (isNodeShadowed(this)) {
                  var flatten = !isUndefined(options) && isTrue$1(options.flatten);
                  return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);
              }
              else {
                  return assignedNodes.apply(this, ArraySlice.call(arguments));
              }
          },
          writable: true,
          enumerable: true,
          configurable: true
      },
      name: {
          get: function () {
              var name = getAttribute.call(this, 'name');
              return isNull(name) ? '' : name;
          },
          set: function (value) {
              setAttribute.call(this, 'name', value);
          },
          enumerable: true,
          configurable: true
      },
      childNodes: {
          get: function () {
              if (isNodeShadowed(this)) {
                  var owner = getNodeOwner(this);
                  var childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
                  return createStaticNodeList(childNodes);
              }
              return childNodesGetter.call(this);
          },
          enumerable: true,
          configurable: true
      }
  });
  defineProperties(Text.prototype, {
      assignedSlot: {
          get: assignedSlotGetterPatched,
          enumerable: true,
          configurable: true
      }
  });
  function getNonPatchedFilteredArrayOfNodes(context, unfilteredNodes) {
      var filtered;
      var ownerKey = getNodeOwnerKey(context);
      if (!isUndefined(ownerKey)) {
          if (isHostElement(context)) {
              var owner = getNodeOwner(context);
              if (isNull(owner)) {
                  filtered = [];
              }
              else if (getNodeKey(context)) {
                  filtered = getAllSlottedMatches(context, unfilteredNodes);
              }
              else {
                  filtered = getAllMatches(owner, unfilteredNodes);
              }
          }
          else {
              filtered = ArrayFilter.call(unfilteredNodes, function (elm) { return getNodeNearestOwnerKey(elm) === ownerKey; });
          }
      }
      else if (context instanceof HTMLBodyElement) {
          filtered = ArrayFilter.call(unfilteredNodes, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context); });
      }
      else {
          filtered = ArraySlice.call(unfilteredNodes);
      }
      return filtered;
  }
  var ShadowDomSemantic;
  (function (ShadowDomSemantic) {
      ShadowDomSemantic[ShadowDomSemantic["Disabled"] = 0] = "Disabled";
      ShadowDomSemantic[ShadowDomSemantic["Enabled"] = 1] = "Enabled";
  })(ShadowDomSemantic || (ShadowDomSemantic = {}));
  function innerHTMLGetterPatched() {
      var childNodes = getInternalChildNodes(this);
      var innerHTML = '';
      for (var i = 0, len = childNodes.length; i < len; i += 1) {
          innerHTML += getOuterHTML(childNodes[i]);
      }
      return innerHTML;
  }
  function outerHTMLGetterPatched() {
      return getOuterHTML(this);
  }
  function attachShadowPatched(options) {
      if (isTrue$1(options['$$lwc-synthetic-mode$$'])) {
          return attachShadow$1(this, options);
      }
      else {
          return attachShadow.call(this, options);
      }
  }
  function shadowRootGetterPatched() {
      if (isHostElement(this)) {
          var shadow = getShadowRoot(this);
          if (shadow.mode === 'open') {
              return shadow;
          }
      }
      return shadowRootGetter.call(this);
  }
  function childrenGetterPatched() {
      var owner = getNodeOwner(this);
      var childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));
      return createStaticHTMLCollection(ArrayFilter.call(childNodes, function (node) { return node instanceof Element; }));
  }
  function childElementCountGetterPatched() {
      return this.children.length;
  }
  function firstElementChildGetterPatched() {
      return this.children[0] || null;
  }
  function lastElementChildGetterPatched() {
      var children = this.children;
      return children.item(children.length - 1) || null;
  }
  defineProperties(Element.prototype, {
      innerHTML: {
          get: function () {
              if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
                  if (isNodeShadowed(this) || isHostElement(this)) {
                      return innerHTMLGetterPatched.call(this);
                  }
                  return innerHTMLGetter.call(this);
              }
              if (isGlobalPatchingSkipped(this)) {
                  return innerHTMLGetter.call(this);
              }
              return innerHTMLGetterPatched.call(this);
          },
          set: function (v) {
              innerHTMLSetter.call(this, v);
          },
          enumerable: true,
          configurable: true
      },
      outerHTML: {
          get: function () {
              if (!runtimeFlags.ENABLE_ELEMENT_PATCH) {
                  if (isNodeShadowed(this) || isHostElement(this)) {
                      return outerHTMLGetterPatched.call(this);
                  }
                  return outerHTMLGetter.call(this);
              }
              if (isGlobalPatchingSkipped(this)) {
                  return outerHTMLGetter.call(this);
              }
              return outerHTMLGetterPatched.call(this);
          },
          set: function (v) {
              outerHTMLSetter.call(this, v);
          },
          enumerable: true,
          configurable: true
      },
      attachShadow: {
          value: attachShadowPatched,
          enumerable: true,
          writable: true,
          configurable: true
      },
      shadowRoot: {
          get: shadowRootGetterPatched,
          enumerable: true,
          configurable: true
      },
      children: {
          get: function () {
              if (hasMountedChildren(this)) {
                  return childrenGetterPatched.call(this);
              }
              return childrenGetter.call(this);
          },
          enumerable: true,
          configurable: true
      },
      childElementCount: {
          get: function () {
              if (hasMountedChildren(this)) {
                  return childElementCountGetterPatched.call(this);
              }
              return childElementCountGetter.call(this);
          },
          enumerable: true,
          configurable: true
      },
      firstElementChild: {
          get: function () {
              if (hasMountedChildren(this)) {
                  return firstElementChildGetterPatched.call(this);
              }
              return firstElementChildGetter.call(this);
          },
          enumerable: true,
          configurable: true
      },
      lastElementChild: {
          get: function () {
              if (hasMountedChildren(this)) {
                  return lastElementChildGetterPatched.call(this);
              }
              return lastElementChildGetter.call(this);
          },
          enumerable: true,
          configurable: true
      },
      assignedSlot: {
          get: assignedSlotGetterPatched,
          enumerable: true,
          configurable: true
      }
  });
  if (hasOwnProperty.call(HTMLElement.prototype, 'innerHTML')) {
      defineProperty(HTMLElement.prototype, 'innerHTML', getOwnPropertyDescriptor(Element.prototype, 'innerHTML'));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, 'outerHTML')) {
      defineProperty(HTMLElement.prototype, 'outerHTML', getOwnPropertyDescriptor(Element.prototype, 'outerHTML'));
  }
  if (hasOwnProperty.call(HTMLElement.prototype, 'children')) {
      defineProperty(HTMLElement.prototype, 'children', getOwnPropertyDescriptor(Element.prototype, 'children'));
  }
  function querySelectorPatched() {
      var _this = this;
      var nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));
      if (isHostElement(this)) {
          var owner = getNodeOwner(this);
          if (isNull(owner)) {
              return null;
          }
          else if (getNodeKey(this)) {
              return getFirstSlottedMatch(this, nodeList);
          }
          else {
              return getFirstMatch(owner, nodeList);
          }
      }
      else if (isNodeShadowed(this)) {
          var ownerKey_1 = getNodeOwnerKey(this);
          if (!isUndefined(ownerKey_1)) {
              var elm = ArrayFind.call(nodeList, function (elm) { return getNodeNearestOwnerKey(elm) === ownerKey_1; });
              return isUndefined(elm) ? null : elm;
          }
          else {
              if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
                  return nodeList.length === 0 ? null : nodeList[0];
              }
              var contextNearestOwnerKey_1 = getNodeNearestOwnerKey(this);
              var elm = ArrayFind.call(nodeList, function (elm) { return getNodeNearestOwnerKey(elm) === contextNearestOwnerKey_1; });
              return isUndefined(elm) ? null : elm;
          }
      }
      else {
          if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
              if (!(this instanceof HTMLBodyElement)) {
                  var elm_1 = nodeList[0];
                  return isUndefined(elm_1) ? null : elm_1;
              }
          }
          var elm = ArrayFind.call(nodeList, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(_this); });
          return isUndefined(elm) ? null : elm;
      }
  }
  function getFilteredArrayOfNodes(context, unfilteredNodes, shadowDomSemantic) {
      var filtered;
      if (isHostElement(context)) {
          var owner = getNodeOwner(context);
          if (isNull(owner)) {
              filtered = [];
          }
          else if (getNodeKey(context)) {
              filtered = getAllSlottedMatches(context, unfilteredNodes);
          }
          else {
              filtered = getAllMatches(owner, unfilteredNodes);
          }
      }
      else if (isNodeShadowed(context)) {
          var ownerKey_2 = getNodeOwnerKey(context);
          if (!isUndefined(ownerKey_2)) {
              filtered = ArrayFilter.call(unfilteredNodes, function (elm) { return getNodeNearestOwnerKey(elm) === ownerKey_2; });
          }
          else if (shadowDomSemantic === ShadowDomSemantic.Enabled) {
              var contextNearestOwnerKey_2 = getNodeNearestOwnerKey(context);
              filtered = ArrayFilter.call(unfilteredNodes, function (elm) { return getNodeNearestOwnerKey(elm) === contextNearestOwnerKey_2; });
          }
          else {
              filtered = ArraySlice.call(unfilteredNodes);
          }
      }
      else {
          if (context instanceof HTMLBodyElement || shadowDomSemantic === ShadowDomSemantic.Enabled) {
              filtered = ArrayFilter.call(unfilteredNodes, function (elm) { return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context); });
          }
          else {
              filtered = ArraySlice.call(unfilteredNodes);
          }
      }
      return filtered;
  }
  defineProperties(Element.prototype, {
      querySelector: {
          value: querySelectorPatched,
          writable: true,
          enumerable: true,
          configurable: true
      },
      querySelectorAll: {
          value: function () {
              var nodeList = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));
              if (!runtimeFlags.ENABLE_NODE_LIST_PATCH) {
                  var filteredResults = getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Disabled);
                  return createStaticNodeList(filteredResults);
              }
              return createStaticNodeList(getFilteredArrayOfNodes(this, nodeList, ShadowDomSemantic.Enabled));
          },
          writable: true,
          enumerable: true,
          configurable: true
      }
  });
  {
      defineProperties(Element.prototype, {
          getElementsByClassName: {
              value: function () {
                  var elements = arrayFromCollection(getElementsByClassName.apply(this, ArraySlice.call(arguments)));
                  if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
                      return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
                  }
                  var filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
                  return createStaticHTMLCollection(filteredResults);
              },
              writable: true,
              enumerable: true,
              configurable: true
          },
          getElementsByTagName: {
              value: function () {
                  var elements = arrayFromCollection(getElementsByTagName.apply(this, ArraySlice.call(arguments)));
                  if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
                      return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
                  }
                  var filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
                  return createStaticHTMLCollection(filteredResults);
              },
              writable: true,
              enumerable: true,
              configurable: true
          },
          getElementsByTagNameNS: {
              value: function () {
                  var elements = arrayFromCollection(getElementsByTagNameNS.apply(this, ArraySlice.call(arguments)));
                  if (!runtimeFlags.ENABLE_HTML_COLLECTIONS_PATCH) {
                      return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));
                  }
                  var filteredResults = getFilteredArrayOfNodes(this, elements, ShadowDomSemantic.Enabled);
                  return createStaticHTMLCollection(filteredResults);
              },
              writable: true,
              enumerable: true,
              configurable: true
          }
      });
  }
  if (hasOwnProperty.call(HTMLElement.prototype, 'getElementsByClassName')) {
      defineProperty(HTMLElement.prototype, 'getElementsByClassName', getOwnPropertyDescriptor(Element.prototype, 'getElementsByClassName'));
  }
  var FocusableSelector = "\n    [contenteditable],\n    [tabindex],\n    a[href],\n    area[href],\n    audio[controls],\n    button,\n    iframe,\n    input,\n    select,\n    textarea,\n    video[controls]\n";
  var formElementTagNames = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA']);
  function filterSequentiallyFocusableElements(elements) {
      return elements.filter(function (element) {
          if (hasAttribute.call(element, 'tabindex')) {
              return getAttribute.call(element, 'tabindex') === '0';
          }
          if (formElementTagNames.has(tagNameGetter.call(element))) {
              return !hasAttribute.call(element, 'disabled');
          }
          return true;
      });
  }
  var DidAddMouseDownListener = createHiddenField('DidAddMouseDownListener', 'synthetic-shadow');
  function isVisible(element) {
      var _a = getBoundingClientRect.call(element), width = _a.width, height = _a.height;
      var noZeroSize = width > 0 || height > 0;
      var isAreaElement = element.tagName === 'AREA';
      return (noZeroSize || isAreaElement) && getComputedStyle(element).visibility !== 'hidden';
  }
  function isTabbable(element) {
      if (isHostElement(element) && isDelegatingFocus(element)) {
          return false;
      }
      return matches.call(element, FocusableSelector) && isVisible(element);
  }
  function hostElementFocus() {
      var _rootNode = this.getRootNode();
      if (_rootNode === this) {
          var focusable = querySelector.call(this, FocusableSelector);
          if (!isNull(focusable)) {
              focusable.focus.apply(focusable, arguments);
          }
          return;
      }
      var rootNode = _rootNode;
      if (rootNode.activeElement === this) {
          return;
      }
      var focusables = arrayFromCollection(querySelectorAll.call(this, FocusableSelector));
      var didFocus = false;
      while (!didFocus && focusables.length !== 0) {
          var focusable = focusables.shift();
          focusable.focus.apply(focusable, arguments);
          var currentRootNode = focusable.getRootNode();
          didFocus = currentRootNode.activeElement === focusable;
      }
  }
  function getTabbableSegments(host) {
      var doc = getOwnerDocument(host);
      var all = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll$1.call(doc, FocusableSelector)));
      var inner = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll.call(host, FocusableSelector)));
      var firstChild = inner[0];
      var lastChild = inner[inner.length - 1];
      var hostIndex = ArrayIndexOf.call(all, host);
      var firstChildIndex = hostIndex > -1 ? hostIndex : ArrayIndexOf.call(all, firstChild);
      var lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;
      var prev = ArraySlice.call(all, 0, firstChildIndex);
      var next = ArraySlice.call(all, lastChildIndex);
      return {
          prev: prev,
          inner: inner,
          next: next
      };
  }
  function getActiveElement(host) {
      var doc = getOwnerDocument(host);
      var activeElement = DocumentPrototypeActiveElement.call(doc);
      if (isNull(activeElement)) {
          return activeElement;
      }
      return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 ? activeElement : null;
  }
  function relatedTargetPosition(host, relatedTarget) {
      var pos = compareDocumentPosition.call(host, relatedTarget);
      if (pos & DOCUMENT_POSITION_CONTAINED_BY) {
          return 0;
      }
      else if (pos & DOCUMENT_POSITION_PRECEDING) {
          return 1;
      }
      else if (pos & DOCUMENT_POSITION_FOLLOWING) {
          return 2;
      }
      return -1;
  }
  function muteEvent(event) {
      event.preventDefault();
      event.stopPropagation();
  }
  function muteFocusEventsDuringExecution(win, func) {
      windowAddEventListener.call(win, 'focusin', muteEvent, true);
      windowAddEventListener.call(win, 'focusout', muteEvent, true);
      func();
      windowRemoveEventListener.call(win, 'focusin', muteEvent, true);
      windowRemoveEventListener.call(win, 'focusout', muteEvent, true);
  }
  function focusOnNextOrBlur(segment, target, relatedTarget) {
      var win = getOwnerWindow(relatedTarget);
      var next = getNextTabbable(segment, relatedTarget);
      if (isNull(next)) {
          muteFocusEventsDuringExecution(win, function () {
              target.blur();
          });
      }
      else {
          muteFocusEventsDuringExecution(win, function () {
              next.focus();
          });
      }
  }
  var letBrowserHandleFocus = false;
  function disableKeyboardFocusNavigationRoutines() {
      letBrowserHandleFocus = true;
  }
  function enableKeyboardFocusNavigationRoutines() {
      letBrowserHandleFocus = false;
  }
  function skipHostHandler(event) {
      if (letBrowserHandleFocus) {
          enableKeyboardFocusNavigationRoutines();
          return;
      }
      var host = eventCurrentTargetGetter.call(event);
      var target = eventTargetGetter.call(event);
      if (host !== target) {
          return;
      }
      var relatedTarget = focusEventRelatedTargetGetter.call(event);
      if (isNull(relatedTarget)) {
          return;
      }
      var segments = getTabbableSegments(host);
      var position = relatedTargetPosition(host, relatedTarget);
      if (position === 1) {
          var findTabbableElms = isTabbableFrom.bind(null, host.getRootNode());
          var first_1 = ArrayFind.call(segments.inner, findTabbableElms);
          if (!isUndefined(first_1)) {
              var win = getOwnerWindow(first_1);
              muteFocusEventsDuringExecution(win, function () {
                  first_1.focus();
              });
          }
          else {
              focusOnNextOrBlur(segments.next, target, relatedTarget);
          }
      }
      else if (host === target) {
          focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
      }
  }
  function skipShadowHandler(event) {
      if (letBrowserHandleFocus) {
          enableKeyboardFocusNavigationRoutines();
          return;
      }
      var relatedTarget = focusEventRelatedTargetGetter.call(event);
      if (isNull(relatedTarget)) {
          return;
      }
      var host = eventCurrentTargetGetter.call(event);
      var segments = getTabbableSegments(host);
      if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {
          return;
      }
      var target = eventTargetGetter.call(event);
      var position = relatedTargetPosition(host, relatedTarget);
      if (position === 1) {
          focusOnNextOrBlur(segments.next, target, relatedTarget);
      }
      if (position === 2) {
          focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);
      }
  }
  function isTabbableFrom(fromRoot, toElm) {
      if (!isTabbable(toElm)) {
          return false;
      }
      var ownerDocument = getOwnerDocument(toElm);
      var root = toElm.getRootNode();
      while (root !== ownerDocument && root !== fromRoot) {
          var sr = root;
          var host = sr.host;
          if (getAttribute.call(host, 'tabindex') === '-1') {
              return false;
          }
          root = host && host.getRootNode();
      }
      return true;
  }
  function getNextTabbable(tabbables, relatedTarget) {
      var len = tabbables.length;
      if (len > 0) {
          for (var i = 0; i < len; i += 1) {
              var next = tabbables[i];
              if (isTabbableFrom(relatedTarget.getRootNode(), next)) {
                  return next;
              }
          }
      }
      return null;
  }
  function handleFocus(elm) {
      bindDocumentMousedownMouseupHandlers(elm);
      ignoreFocusIn(elm);
      addEventListener.call(elm, 'focusin', skipHostHandler, true);
  }
  function ignoreFocus(elm) {
      removeEventListener.call(elm, 'focusin', skipHostHandler, true);
  }
  function bindDocumentMousedownMouseupHandlers(elm) {
      var ownerDocument = getOwnerDocument(elm);
      if (!getHiddenField(ownerDocument, DidAddMouseDownListener)) {
          setHiddenField(ownerDocument, DidAddMouseDownListener, true);
          addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);
          addEventListener.call(ownerDocument, 'mouseup', function () {
              setTimeout(enableKeyboardFocusNavigationRoutines);
          }, true);
      }
  }
  function handleFocusIn(elm) {
      bindDocumentMousedownMouseupHandlers(elm);
      ignoreFocus(elm);
      addEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }
  function ignoreFocusIn(elm) {
      removeEventListener.call(elm, 'focusin', skipShadowHandler, true);
  }
  var _m = HTMLElement.prototype, blur = _m.blur, focus = _m.focus;
  function tabIndexGetterPatched() {
      if (isDelegatingFocus(this) && isFalse$1(hasAttribute.call(this, 'tabindex'))) {
          return 0;
      }
      return tabIndexGetter.call(this);
  }
  function tabIndexSetterPatched(value) {
      var delegatesFocus = isDelegatingFocus(this);
      var prevValue = tabIndexGetter.call(this);
      var prevHasAttr = hasAttribute.call(this, 'tabindex');
      tabIndexSetter.call(this, value);
      var currValue = tabIndexGetter.call(this);
      var currHasAttr = hasAttribute.call(this, 'tabindex');
      var didValueChange = prevValue !== currValue;
      if (prevHasAttr && (didValueChange || isFalse$1(currHasAttr))) {
          if (prevValue === -1) {
              ignoreFocusIn(this);
          }
          if (prevValue === 0 && delegatesFocus) {
              ignoreFocus(this);
          }
      }
      if (isFalse$1(currHasAttr)) {
          return;
      }
      if (prevHasAttr && currHasAttr && isFalse$1(didValueChange)) {
          return;
      }
      if (currValue === -1) {
          handleFocusIn(this);
      }
      if (currValue === 0 && delegatesFocus) {
          handleFocus(this);
      }
  }
  function blurPatched() {
      if (isDelegatingFocus(this)) {
          var currentActiveElement = getActiveElement(this);
          if (!isNull(currentActiveElement)) {
              currentActiveElement.blur();
              return;
          }
      }
      return blur.call(this);
  }
  function focusPatched() {
      disableKeyboardFocusNavigationRoutines();
      if (isHostElement(this) && isDelegatingFocus(this)) {
          hostElementFocus.call(this);
          return;
      }
      focus.apply(this, arguments);
      enableKeyboardFocusNavigationRoutines();
  }
  defineProperties(HTMLElement.prototype, {
      tabIndex: {
          get: function () {
              if (isHostElement(this)) {
                  return tabIndexGetterPatched.call(this);
              }
              return tabIndexGetter.call(this);
          },
          set: function (v) {
              if (isHostElement(this)) {
                  return tabIndexSetterPatched.call(this, v);
              }
              return tabIndexSetter.call(this, v);
          },
          enumerable: true,
          configurable: true
      },
      blur: {
          value: function () {
              if (isHostElement(this)) {
                  return blurPatched.call(this);
              }
              blur.call(this);
          },
          enumerable: true,
          writable: true,
          configurable: true
      },
      focus: {
          value: function () {
              focusPatched.apply(this, arguments);
          },
          enumerable: true,
          writable: true,
          configurable: true
      }
  });
  var _o = Node.prototype, superAddEventListener = _o.addEventListener, superRemoveEventListener = _o.removeEventListener;
  function addEventListenerPatched(type, listener, options) {
      if (isHostElement(this)) {
          addCustomElementEventListener(this, type, listener);
      }
      else {
          superAddEventListener.call(this, type, listener, options);
      }
  }
  function removeEventListenerPatched(type, listener, options) {
      if (isHostElement(this)) {
          removeCustomElementEventListener(this, type, listener);
      }
      else {
          superRemoveEventListener.call(this, type, listener, options);
      }
  }
  if (typeof EventTarget !== 'undefined') {
      defineProperties(EventTarget.prototype, {
          addEventListener: {
              value: addEventListenerPatched,
              enumerable: true,
              writable: true,
              configurable: true
          },
          removeEventListener: {
              value: removeEventListenerPatched,
              enumerable: true,
              writable: true,
              configurable: true
          }
      });
  }
  else {
      defineProperties(Node.prototype, {
          addEventListener: {
              value: addEventListenerPatched,
              enumerable: true,
              writable: true,
              configurable: true
          },
          removeEventListener: {
              value: removeEventListenerPatched,
              enumerable: true,
              writable: true,
              configurable: true
          }
      });
  }
  var ShadowTokenKey = '$shadowToken$';
  var ShadowTokenPrivateKey = '$$ShadowTokenKey$$';
  function getShadowToken(node) {
      return node[ShadowTokenKey];
  }
  function setShadowToken(node, shadowToken) {
      node[ShadowTokenKey] = shadowToken;
  }
  defineProperty(Element.prototype, ShadowTokenKey, {
      set: function (shadowToken) {
          var oldShadowToken = this[ShadowTokenPrivateKey];
          if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {
              removeAttribute.call(this, oldShadowToken);
          }
          if (!isUndefined(shadowToken)) {
              setAttribute.call(this, shadowToken, '');
          }
          this[ShadowTokenPrivateKey] = shadowToken;
      },
      get: function () {
          return this[ShadowTokenPrivateKey];
      },
      configurable: true
  });
  var DomManualPrivateKey = '$$DomManualKey$$';
  var DocumentResolverFn = function () { };
  var portalObserver;
  var portalObserverConfig = {
      childList: true
  };
  function adoptChildNode(node, fn, shadowToken) {
      var previousNodeShadowResolver = getShadowRootResolver(node);
      if (previousNodeShadowResolver === fn) {
          return;
      }
      setShadowRootResolver(node, fn);
      if (node instanceof Element) {
          setShadowToken(node, shadowToken);
          if (isHostElement(node)) {
              return;
          }
          if (isUndefined(previousNodeShadowResolver)) {
              MutationObserverObserve.call(portalObserver, node, portalObserverConfig);
          }
          var childNodes = childNodesGetter.call(node);
          for (var i = 0, len = childNodes.length; i < len; i += 1) {
              adoptChildNode(childNodes[i], fn, shadowToken);
          }
      }
  }
  function initPortalObserver() {
      return new MO(function (mutations) {
          forEach.call(mutations, function (mutation) {
              var elm = mutation.target, addedNodes = mutation.addedNodes, removedNodes = mutation.removedNodes;
              var fn = getShadowRootResolver(elm);
              var shadowToken = getShadowToken(elm);
              for (var i = 0, len = removedNodes.length; i < len; i += 1) {
                  var node = removedNodes[i];
                  if (!(compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
                      adoptChildNode(node, DocumentResolverFn, undefined);
                  }
              }
              for (var i = 0, len = addedNodes.length; i < len; i += 1) {
                  var node = addedNodes[i];
                  if (compareDocumentPosition.call(elm, node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
                      adoptChildNode(node, fn, shadowToken);
                  }
              }
          });
      });
  }
  function markElementAsPortal(elm) {
      if (isUndefined(portalObserver)) {
          portalObserver = initPortalObserver();
      }
      if (isUndefined(getShadowRootResolver(elm))) {
          throw new Error("Invalid Element");
      }
      MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);
  }
  defineProperty(Element.prototype, '$domManual$', {
      set: function (v) {
          this[DomManualPrivateKey] = v;
          if (isTrue$1(v)) {
              markElementAsPortal(this);
          }
      },
      get: function () {
          return this[DomManualPrivateKey];
      },
      configurable: true
  });
  /** version: 1.7.7 */

})));
