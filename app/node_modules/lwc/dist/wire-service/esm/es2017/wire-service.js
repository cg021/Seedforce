/**
 * Copyright (C) 2018 salesforce.com, inc.
 */

/**
 * Copyright (C) 2018 salesforce.com, inc.
 */

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const {
  assign,
  create,
  defineProperties,
  defineProperty,
  freeze,
  getOwnPropertyDescriptor,
  getOwnPropertyNames,
  getPrototypeOf,
  hasOwnProperty,
  isFrozen,
  keys,
  seal,
  setPrototypeOf
} = Object;
const {
  filter: ArrayFilter,
  find: ArrayFind,
  indexOf: ArrayIndexOf,
  join: ArrayJoin,
  map: ArrayMap,
  push: ArrayPush,
  reduce: ArrayReduce,
  reverse: ArrayReverse,
  slice: ArraySlice,
  splice: ArraySplice,
  unshift: ArrayUnshift,
  forEach
} = Array.prototype;
const {
  charCodeAt: StringCharCodeAt,
  replace: StringReplace,
  slice: StringSlice,
  toLowerCase: StringToLowerCase
} = String.prototype;

function isUndefined(obj) {
  return obj === undefined;
}
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

/**
 * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
 * ariaGrabbed) are deprecated:
 * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
 *
 * The above list of 46 aria attributes is consistent with the following resources:
 * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
 * https://wicg.github.io/aom/spec/aria-reflection.html
 */


const AriaPropertyNames = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
const AttrNameToPropNameMap = create(null);
const PropNameToAttrNameMap = create(null); // Synthetic creation of all AOM property descriptors for Custom Elements

forEach.call(AriaPropertyNames, propName => {
  // Typescript infers the wrong function type for this particular overloaded method:
  // https://github.com/Microsoft/TypeScript/issues/27972
  // @ts-ignore type-mismatch
  const attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, 'aria-'));
  AttrNameToPropNameMap[attrName] = propName;
  PropNameToAttrNameMap[propName] = attrName;
});
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
// Inspired from: https://mathiasbynens.be/notes/globalthis

const _globalThis = function () {
  // On recent browsers, `globalThis` is already defined. In this case return it directly.
  if (typeof globalThis === 'object') {
    return globalThis;
  }

  let _globalThis;

  try {
    // eslint-disable-next-line no-extend-native
    Object.defineProperty(Object.prototype, '__magic__', {
      get: function () {
        return this;
      },
      configurable: true
    }); // __magic__ is undefined in Safari 10 and IE10 and older.
    // @ts-ignore
    // eslint-disable-next-line no-undef

    _globalThis = __magic__; // @ts-ignore

    delete Object.prototype.__magic__;
  } catch (ex) {// In IE8, Object.defineProperty only works on DOM objects.
  } finally {
    // If the magic above fails for some reason we assume that we are in a legacy browser.
    // Assume `window` exists in this case.
    if (typeof _globalThis === 'undefined') {
      // @ts-ignore
      _globalThis = window;
    }
  }

  return _globalThis;
}();
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

/*
 * In IE11, symbols are expensive.
 * Due to the nature of the symbol polyfill. This method abstract the
 * creation of symbols, so we can fallback to string when native symbols
 * are not supported. Note that we can't use typeof since it will fail when transpiling.
 */


const hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
const HTML_ATTRIBUTES_TO_PROPERTY = {
  accesskey: 'accessKey',
  readonly: 'readOnly',
  tabindex: 'tabIndex',
  bgcolor: 'bgColor',
  colspan: 'colSpan',
  rowspan: 'rowSpan',
  contenteditable: 'contentEditable',
  crossorigin: 'crossOrigin',
  datetime: 'dateTime',
  formaction: 'formAction',
  ismap: 'isMap',
  maxlength: 'maxLength',
  minlength: 'minLength',
  novalidate: 'noValidate',
  usemap: 'useMap',
  for: 'htmlFor'
};
keys(HTML_ATTRIBUTES_TO_PROPERTY).forEach(attrName => {});
/** version: 1.7.7 */

/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */

const ValueChangedEventType = 'ValueChangedEvent';
/**
 * Event fired by wire adapters to emit a new value.
 */

class ValueChangedEvent {
  constructor(value) {
    this.type = ValueChangedEventType;
    this.value = value;
  }

}
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */


const {
  freeze: freeze$1,
  defineProperty: defineProperty$1,
  isExtensible
} = Object; // This value needs to be in sync with wiring.ts from @lwc/engine

const DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';
const DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';
/**
 * Registers a wire adapter factory for Lightning Platform.
 * @deprecated
 */

function register(adapterId, adapterEventTargetCallback) {
  if (adapterId == null || !isExtensible(adapterId)) {
    throw new TypeError('adapter id must be extensible');
  }

  if (typeof adapterEventTargetCallback !== 'function') {
    throw new TypeError('adapter factory must be a callable');
  }

  if ('adapter' in adapterId) {
    throw new TypeError('adapter id is already associated to an adapter factory');
  }

  const AdapterClass = class extends LegacyWireAdapterBridge {
    constructor(dataCallback) {
      super(dataCallback);
      adapterEventTargetCallback(this.eventTarget);
    }

  };
  freeze$1(AdapterClass);
  freeze$1(AdapterClass.prototype);
  defineProperty$1(adapterId, 'adapter', {
    writable: false,
    configurable: false,
    value: AdapterClass
  });
}
/**
 * Registers the wire service. noop
 * @deprecated
 */


function registerWireService() {}

const {
  forEach: forEach$1,
  splice: ArraySplice$1,
  indexOf: ArrayIndexOf$1
} = Array.prototype; // wire event target life cycle connectedCallback hook event type

const CONNECT = 'connect'; // wire event target life cycle disconnectedCallback hook event type

const DISCONNECT = 'disconnect'; // wire event target life cycle config changed hook event type

const CONFIG = 'config';

function removeListener(listeners, toRemove) {
  const idx = ArrayIndexOf$1.call(listeners, toRemove);

  if (idx > -1) {
    ArraySplice$1.call(listeners, idx, 1);
  }
}

function isEmptyConfig(config) {
  return Object.keys(config).length === 0;
}

function isValidConfig(config, params) {
  // The config is valid if there is no params, or if exist a param for which config[param] !== undefined.
  return params.length === 0 || params.some(param => !isUndefined(config[param]));
}

function isDifferentConfig(newConfig, oldConfig, params) {
  return params.some(param => newConfig[param] !== oldConfig[param]);
}

class LegacyWireAdapterBridge {
  constructor(callback) {
    this.connecting = [];
    this.disconnecting = [];
    this.configuring = [];
    this.isFirstUpdate = true;
    this.callback = callback;
    this.wiredElementHost = callback[DeprecatedWiredElementHost];
    this.dynamicParamsNames = callback[DeprecatedWiredParamsMeta];
    this.eventTarget = {
      addEventListener: (type, listener) => {
        switch (type) {
          case CONNECT:
            {
              this.connecting.push(listener);
              break;
            }

          case DISCONNECT:
            {
              this.disconnecting.push(listener);
              break;
            }

          case CONFIG:
            {
              this.configuring.push(listener);

              if (this.currentConfig !== undefined) {
                listener.call(undefined, this.currentConfig);
              }

              break;
            }

          default:
            throw new Error(`Invalid event type ${type}.`);
        }
      },
      removeEventListener: (type, listener) => {
        switch (type) {
          case CONNECT:
            {
              removeListener(this.connecting, listener);
              break;
            }

          case DISCONNECT:
            {
              removeListener(this.disconnecting, listener);
              break;
            }

          case CONFIG:
            {
              removeListener(this.configuring, listener);
              break;
            }

          default:
            throw new Error(`Invalid event type ${type}.`);
        }
      },
      dispatchEvent: evt => {
        if (evt instanceof ValueChangedEvent) {
          const value = evt.value;
          this.callback(value);
        } else if (evt.type === 'wirecontextevent') {
          // TODO [#1357]: remove this branch
          return this.wiredElementHost.dispatchEvent(evt);
        } else {
          throw new Error(`Invalid event type ${evt.type}.`);
        }

        return false; // canceling signal since we don't want this to propagate
      }
    };
  }

  update(config) {
    if (this.isFirstUpdate) {
      // this is a special case for legacy wire adapters: when all the config params are undefined,
      // the config on the wire adapter should not be called until one of them changes.
      this.isFirstUpdate = false;

      if (!isEmptyConfig(config) && !isValidConfig(config, this.dynamicParamsNames)) {
        return;
      }
    }

    if (isUndefined(this.currentConfig) || isDifferentConfig(config, this.currentConfig, this.dynamicParamsNames)) {
      this.currentConfig = config;
      forEach$1.call(this.configuring, listener => {
        listener.call(undefined, config);
      });
    }
  }

  connect() {
    forEach$1.call(this.connecting, listener => listener.call(undefined));
  }

  disconnect() {
    forEach$1.call(this.disconnecting, listener => listener.call(undefined));
  }

}
/** version: 1.7.7 */

export { ValueChangedEvent, register, registerWireService };
