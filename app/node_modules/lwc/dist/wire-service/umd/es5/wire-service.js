(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.WireService = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    function __extends(d, b) {
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var create = Object.create, keys = Object.keys;
    var _a = Array.prototype, forEach = _a.forEach;
    var _b = String.prototype, StringReplace = _b.replace, StringToLowerCase = _b.toLowerCase;
    function isUndefined(obj) {
        return obj === undefined;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
     * ariaGrabbed) are deprecated:
     * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
     *
     * The above list of 46 aria attributes is consistent with the following resources:
     * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
     * https://wicg.github.io/aom/spec/aria-reflection.html
     */
    var AriaPropertyNames = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
    var AttrNameToPropNameMap = create(null);
    var PropNameToAttrNameMap = create(null); // Synthetic creation of all AOM property descriptors for Custom Elements
    forEach.call(AriaPropertyNames, function (propName) {
        // Typescript infers the wrong function type for this particular overloaded method:
        // https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        var attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, 'aria-'));
        AttrNameToPropNameMap[attrName] = propName;
        PropNameToAttrNameMap[propName] = attrName;
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Inspired from: https://mathiasbynens.be/notes/globalthis
    var _globalThis = function () {
        // On recent browsers, `globalThis` is already defined. In this case return it directly.
        if (typeof globalThis === 'object') {
            return globalThis;
        }
        var _globalThis;
        try {
            // eslint-disable-next-line no-extend-native
            Object.defineProperty(Object.prototype, '__magic__', {
                get: function () {
                    return this;
                },
                configurable: true
            }); // __magic__ is undefined in Safari 10 and IE10 and older.
            // @ts-ignore
            // eslint-disable-next-line no-undef
            _globalThis = __magic__; // @ts-ignore
            delete Object.prototype.__magic__;
        }
        catch (ex) { // In IE8, Object.defineProperty only works on DOM objects.
        }
        finally {
            // If the magic above fails for some reason we assume that we are in a legacy browser.
            // Assume `window` exists in this case.
            if (typeof _globalThis === 'undefined') {
                // @ts-ignore
                _globalThis = window;
            }
        }
        return _globalThis;
    }();
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /*
     * In IE11, symbols are expensive.
     * Due to the nature of the symbol polyfill. This method abstract the
     * creation of symbols, so we can fallback to string when native symbols
     * are not supported. Note that we can't use typeof since it will fail when transpiling.
     */
    var hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';
    var HTML_ATTRIBUTES_TO_PROPERTY = {
        accesskey: 'accessKey',
        readonly: 'readOnly',
        tabindex: 'tabIndex',
        bgcolor: 'bgColor',
        colspan: 'colSpan',
        rowspan: 'rowSpan',
        contenteditable: 'contentEditable',
        crossorigin: 'crossOrigin',
        datetime: 'dateTime',
        formaction: 'formAction',
        ismap: 'isMap',
        maxlength: 'maxLength',
        minlength: 'minLength',
        novalidate: 'noValidate',
        usemap: 'useMap',
        for: 'htmlFor'
    };
    keys(HTML_ATTRIBUTES_TO_PROPERTY).forEach(function (attrName) { });
    /** version: 1.7.7 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ValueChangedEventType = 'ValueChangedEvent';
    /**
     * Event fired by wire adapters to emit a new value.
     */
    var ValueChangedEvent = /** @class */ (function () {
        function ValueChangedEvent(value) {
            this.type = ValueChangedEventType;
            this.value = value;
        }
        return ValueChangedEvent;
    }());
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var freeze$1 = Object.freeze, defineProperty$1 = Object.defineProperty, isExtensible = Object.isExtensible; // This value needs to be in sync with wiring.ts from @lwc/engine
    var DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';
    var DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';
    /**
     * Registers a wire adapter factory for Lightning Platform.
     * @deprecated
     */
    function register(adapterId, adapterEventTargetCallback) {
        if (adapterId == null || !isExtensible(adapterId)) {
            throw new TypeError('adapter id must be extensible');
        }
        if (typeof adapterEventTargetCallback !== 'function') {
            throw new TypeError('adapter factory must be a callable');
        }
        if ('adapter' in adapterId) {
            throw new TypeError('adapter id is already associated to an adapter factory');
        }
        var AdapterClass = /** @class */ (function (_super) {
            __extends(AdapterClass, _super);
            function AdapterClass(dataCallback) {
                var _this = _super.call(this, dataCallback) || this;
                adapterEventTargetCallback(_this.eventTarget);
                return _this;
            }
            return AdapterClass;
        }(LegacyWireAdapterBridge));
        freeze$1(AdapterClass);
        freeze$1(AdapterClass.prototype);
        defineProperty$1(adapterId, 'adapter', {
            writable: false,
            configurable: false,
            value: AdapterClass
        });
    }
    /**
     * Registers the wire service. noop
     * @deprecated
     */
    function registerWireService() { }
    var _c = Array.prototype, forEach$1 = _c.forEach, ArraySplice$1 = _c.splice, ArrayIndexOf$1 = _c.indexOf; // wire event target life cycle connectedCallback hook event type
    var CONNECT = 'connect'; // wire event target life cycle disconnectedCallback hook event type
    var DISCONNECT = 'disconnect'; // wire event target life cycle config changed hook event type
    var CONFIG = 'config';
    function removeListener(listeners, toRemove) {
        var idx = ArrayIndexOf$1.call(listeners, toRemove);
        if (idx > -1) {
            ArraySplice$1.call(listeners, idx, 1);
        }
    }
    function isEmptyConfig(config) {
        return Object.keys(config).length === 0;
    }
    function isValidConfig(config, params) {
        // The config is valid if there is no params, or if exist a param for which config[param] !== undefined.
        return params.length === 0 || params.some(function (param) { return !isUndefined(config[param]); });
    }
    function isDifferentConfig(newConfig, oldConfig, params) {
        return params.some(function (param) { return newConfig[param] !== oldConfig[param]; });
    }
    var LegacyWireAdapterBridge = /** @class */ (function () {
        function LegacyWireAdapterBridge(callback) {
            var _this = this;
            this.connecting = [];
            this.disconnecting = [];
            this.configuring = [];
            this.isFirstUpdate = true;
            this.callback = callback;
            this.wiredElementHost = callback[DeprecatedWiredElementHost];
            this.dynamicParamsNames = callback[DeprecatedWiredParamsMeta];
            this.eventTarget = {
                addEventListener: function (type, listener) {
                    switch (type) {
                        case CONNECT:
                            {
                                _this.connecting.push(listener);
                                break;
                            }
                        case DISCONNECT:
                            {
                                _this.disconnecting.push(listener);
                                break;
                            }
                        case CONFIG:
                            {
                                _this.configuring.push(listener);
                                if (_this.currentConfig !== undefined) {
                                    listener.call(undefined, _this.currentConfig);
                                }
                                break;
                            }
                        default:
                            throw new Error("Invalid event type " + type + ".");
                    }
                },
                removeEventListener: function (type, listener) {
                    switch (type) {
                        case CONNECT:
                            {
                                removeListener(_this.connecting, listener);
                                break;
                            }
                        case DISCONNECT:
                            {
                                removeListener(_this.disconnecting, listener);
                                break;
                            }
                        case CONFIG:
                            {
                                removeListener(_this.configuring, listener);
                                break;
                            }
                        default:
                            throw new Error("Invalid event type " + type + ".");
                    }
                },
                dispatchEvent: function (evt) {
                    if (evt instanceof ValueChangedEvent) {
                        var value = evt.value;
                        _this.callback(value);
                    }
                    else if (evt.type === 'wirecontextevent') {
                        // TODO [#1357]: remove this branch
                        return _this.wiredElementHost.dispatchEvent(evt);
                    }
                    else {
                        throw new Error("Invalid event type " + evt.type + ".");
                    }
                    return false; // canceling signal since we don't want this to propagate
                }
            };
        }
        LegacyWireAdapterBridge.prototype.update = function (config) {
            if (this.isFirstUpdate) {
                // this is a special case for legacy wire adapters: when all the config params are undefined,
                // the config on the wire adapter should not be called until one of them changes.
                this.isFirstUpdate = false;
                if (!isEmptyConfig(config) && !isValidConfig(config, this.dynamicParamsNames)) {
                    return;
                }
            }
            if (isUndefined(this.currentConfig) || isDifferentConfig(config, this.currentConfig, this.dynamicParamsNames)) {
                this.currentConfig = config;
                forEach$1.call(this.configuring, function (listener) {
                    listener.call(undefined, config);
                });
            }
        };
        LegacyWireAdapterBridge.prototype.connect = function () {
            forEach$1.call(this.connecting, function (listener) { return listener.call(undefined); });
        };
        LegacyWireAdapterBridge.prototype.disconnect = function () {
            forEach$1.call(this.disconnecting, function (listener) { return listener.call(undefined); });
        };
        return LegacyWireAdapterBridge;
    }());
    /** version: 1.7.7 */

    exports.ValueChangedEvent = ValueChangedEvent;
    exports.register = register;
    exports.registerWireService = registerWireService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
